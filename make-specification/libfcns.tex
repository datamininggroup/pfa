\usepackage{xstring}

\newcommand{\libfcn}[1]{%
    \par\noindent%
    \IfEqCase*{#1}{%
    {+}{\hypertarget{+}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"+":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18000:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18001:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {-}{\hypertarget{-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"-":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract {\PFAp y} from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18010:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18011:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {*}{\hypertarget{*}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"*":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18020:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18021:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {/}{\hypertarget{/}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"/":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning a floating-point number (even if {\PFAp x} and {\PFAp y} are integers). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function returns an infinite value if {\PFAp x} is non-zero and {\PFAp y} is zero and NaN if both are zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {//}{\hypertarget{//}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"//":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide {\PFAp y} from {\PFAp x}, returning the largest whole number {\PFAc N} for which {\PFAc N} $\leq$ {\PFAp x}/{\PFAp y} (integral floor division). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18040:} If {\PFAp y} is zero, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {u-}{\hypertarget{u-}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"u-":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the additive inverse of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18050:} For exactly one integer value, -2147483648, this function raises an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18051:} For exactly one long value, -9223372036854775808, this function raises a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\%}{\hypertarget{\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp k} modulo {\PFAp n}; the result has the same sign as the modulus {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Python, {\PFAc mod}/{\PFAc modulo} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18060:} If {\PFAp n} is zero and {\PFAp k} and {\PFAp n} are int or long, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\%\%}{\hypertarget{\%\%}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\%\%":$\!$ [k, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc n \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the remainder of {\PFAp k} divided by {\PFAp n}; the result has the same sign as the dividend {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the {\PFAc \%} operator in Fortran, C/C++, and Java, {\PFAc rem}/{\PFAc remainder} in Ada, Haskell, and Scheme.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18070:} If {\PFAp n} is zero and {\PFAp k} and {\PFAp n} are int or long, this function raises a ``integer division by zero'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {**}{\hypertarget{**}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"**":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Raise {\PFAp x} to the power {\PFAp n}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or NaN values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#18080:} Integer results above or below -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#18081:} Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cmp}{\hypertarget{cmp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cmp":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc 1} if {\PFAp x} is greater than {\PFAp y}, {\PFAc -1} if {\PFAp x} is less than {\PFAp y}, and {\PFAc 0} if {\PFAp x} and {\PFAp y} are equal. \vspace{0.2 cm} \\ }}%
    {==}{\hypertarget{==}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"==":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {>=}{\hypertarget{>=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {>}{\hypertarget{>}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{">":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is greater than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {!=}{\hypertarget{!=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is not equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {<}{\hypertarget{<}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {<=}{\hypertarget{<=}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"<=":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is less than or equal to {\PFAp y}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {max}{\hypertarget{max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"max":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} $\geq$ {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the maximum of more than two values, see {\PFAf \hyperlink{a.max}{a.max}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {min}{\hypertarget{min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"min":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc y \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp x} if {\PFAp x} < {\PFAp y}, {\PFAp y} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For the minimum of more than two values, see {\PFAf \hyperlink{a.min}{a.min}}\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\&\&}{\hypertarget{\&\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\&\&":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} and {\PFAp y} are both {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {||}{\hypertarget{||}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"||":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if either {\PFAp x} or {\PFAp y} (or both) are {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\^{}\^{}}{\hypertarget{\^{}\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\^{}\^{}":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & \PFAc y \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc true} and {\PFAp y} is {\PFAc false} or if {\PFAp x} is {\PFAc false} and {\PFAp y} is {\PFAc true}, but return {\PFAc false} for any other case. \vspace{0.2 cm} \\ }}%
    {!}{\hypertarget{!}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false} and {\PFAc false} if {\PFAp x} is {\PFAc true}. \vspace{0.2 cm} \\ }}%
    {\&\&\&}{\hypertarget{\&\&\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"\&\&\&":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & \PFAc y \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc false} if {\PFAp x} or {\PFAp y} is {\PFAc false}, {\PFAc true} if {\PFAp x} and {\PFAp y} are {\PFAc true}, and {\PFAc null} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown. \vspace{0.1 cm} \\ If {\PFAp x} is {\PFAc false}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {|||}{\hypertarget{|||}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"|||":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & \PFAc y \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} or {\PFAp y} is {\PFAc true}, {\PFAc false} if both {\PFAp x} and {\PFAp y} is {\PFAc false}, or {\PFAc null} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown. \vspace{0.1 cm} \\ If {\PFAp x} is {\PFAc true}, {\PFAp y} won't be evaluated.  (Only relevant for arguments with side effects.)\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {!!!}{\hypertarget{!!!}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"!!!":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{boolean, null\} \\  & {\it (returns)} & union of \{boolean, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc false}, {\PFAc false} if {\PFAp x} is {\PFAc true}, or {\PFAc null} if {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This corresponds to Kleene's three-state logic, in which {\PFAc null} represents a boolean quantity whose value is unknown.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {\&}{\hypertarget{\&}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\&":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-and of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {|}{\hypertarget{|}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"|":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {\^{}}{\hypertarget{\^{}}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\^{}":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc y \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc y \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-exclusive-or of {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {TILDE}{\hypertarget{TILDE}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"\textasciitilde{}":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the bitwise-not of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {m.pi}{\hypertarget{m.pi}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.pi":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $\pi$, the ratio of a circumference of a circle to its diameter. \vspace{0.2 cm} \\ }}%
    {m.e}{\hypertarget{m.e}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.e":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} The double-precision number that is closer than any other to $e$, the base of natural logarithms. \vspace{0.2 cm} \\ }}%
    {m.abs}{\hypertarget{m.abs}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.abs":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the absolute value of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27020:} For exactly one integer value, -2147483648, this function produces an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#27021:} For exactly one long value, -9223372036854775808, this function produces a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.acos}{\hypertarget{m.acos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.acos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-cosine (inverse of the cosine function) of {\PFAp x} as an angle in radians between $0$ and $\pi$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.asin}{\hypertarget{m.asin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.asin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-sine (inverse of the sine function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.atan}{\hypertarget{m.atan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp x} as an angle in radians between $-\pi/2$ and $\pi/2$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.atan2}{\hypertarget{m.atan2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.atan2":$\!$ [y, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc y \rm & double \\  & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arc-tangent (inverse of the tangent function) of {\PFAp y}/{\PFAp x} without loss of precision for small {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real plane; no pair of inputs is invalid. \vspace{0.1 cm} \\ Note that {\PFAp y} is the first parameter and {\PFAp x} is the second parameter.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ceil}{\hypertarget{m.ceil}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ceil":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.copysign}{\hypertarget{m.copysign}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.copysign":$\!$ [mag, sign]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mag \rm & any {\PFAtp A} of \{int, long, float, double\} \\  & \PFAc sign \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a number with the magnitude of {\PFAp mag} and the sign of {\PFAp sign}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real or integer plane; no pair of inputs is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.cos}{\hypertarget{m.cos}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cos":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric cosine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.cosh}{\hypertarget{m.cosh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.cosh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic cosine of {\PFAp x}, which is equal to $\frac{e^x + e^{-x}}{2}$ \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.exp}{\hypertarget{m.exp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.exp":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAf \hyperlink{m.e}{m.e}} raised to the power of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.expm1}{\hypertarget{m.expm1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.expm1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $e^x - 1$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.floor}{\hypertarget{m.floor}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.floor":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the largest (closest to positive infinity) whole number that is less than or equal to the input. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.hypot}{\hypertarget{m.hypot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.hypot":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $\sqrt{x^2 + y^2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln}{\hypertarget{m.ln}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural logarithm of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.log10}{\hypertarget{m.log10}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log10":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm base 10 of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.log}{\hypertarget{m.log}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.log":$\!$ [x, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc base \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the logarithm of {\PFAp x} with a given {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27170:} If {\PFAp base} is less than or equal to zero, this function produces a ``base must be positive'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.ln1p}{\hypertarget{m.ln1p}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.ln1p":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return $ln(x^2 + 1)$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Avoids round-off or overflow errors in the intermediate steps. \vspace{0.1 cm} \\ The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.round}{\hypertarget{m.round}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.round":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding up if the fractional part is exactly one-half. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Equal to {\PFAf \hyperlink{m.floor}{m.floor}} of ({\PFAp x} + 0.5).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#27190:} Integer results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error. \vspace{0.1 cm} \\ {\bf \#27191:} Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.rint}{\hypertarget{m.rint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.rint":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the closest whole number to {\PFAp x}, rounding toward the nearest even number if the fractional part is exactly one-half. \vspace{0.2 cm} \\ }}%
    {m.signum}{\hypertarget{m.signum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.signum":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return 0 if {\PFAp x} is zero, 1 if {\PFAp x} is positive, and -1 if {\PFAp x} is negative. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sin}{\hypertarget{m.sin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sin":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric sine of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sinh}{\hypertarget{m.sinh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sinh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic sine of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{2}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.sqrt}{\hypertarget{m.sqrt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.sqrt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the positive square root of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is {\PFAc NaN}, not an exception (see IEEE 754).  Use {\PFAf \hyperlink{impute.ensureFinite}{impute.ensureFinite}} to produce errors from infinite or {\PFAc NaN} values."\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tan}{\hypertarget{m.tan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tan":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the trigonometric tangent of {\PFAp x}, which is assumed to be in radians. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.tanh}{\hypertarget{m.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.tanh":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the hyperbolic tangent of {\PFAp x}, which is equal to $\frac{e^x - e^{-x}}{e^x + e^{-x}}$. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The domain of this function is the whole real line; no input is invalid.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.nChooseK}{\hypertarget{m.special.nChooseK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.nChooseK":$\!$ [n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:}  The number of ways to choose {\PFAp k} elements from a set of {\PFAp n} elements. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Total number of elements.  \\  & \PFAc k \rm & Numer of elements chosen.  \\  & {\it (return value)} \rm & With $n$ and $k$, this function evaluates the binomial coefficient. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#36000:} Raises ``domain error'' if $k \leq 0$ or $k \geq n$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.lnBeta}{\hypertarget{m.special.lnBeta}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnBeta":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the beta function parameterized by {\PFAp a} and {\PFAp b}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & With $a$ and $b$, this function evaluates natural logarithm of the beta function. The beta function is $\int_{0}^{1} t^{a - 1}(1 - t)^{b - 1} dt $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#36010:} Raises ``domain error'' if $a \leq 0$ or if $b \leq 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.special.erf}{\hypertarget{m.special.erf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erf":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the error function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {m.special.erfc}{\hypertarget{m.special.erfc}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.erfc":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the complimentary error function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {m.special.lnGamma}{\hypertarget{m.special.lnGamma}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.special.lnGamma":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the natural log of the gamma function of {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {m.link.softmax}{\hypertarget{m.link.softmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softmax":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softmax function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(x_i)/\sum_j \exp(x_j)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#25000:} If {\PFAp x} is an empty array or an empty map, this function raises an ``empty input'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.link.logit}{\hypertarget{m.link.logit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.logit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the logit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 / (1 + \exp(-x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.probit}{\hypertarget{m.link.probit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.probit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the probit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $(\mbox{erf}(x_i/\sqrt{2}) + 1)/2$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.cloglog}{\hypertarget{m.link.cloglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cloglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cloglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $1 - \exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.loglog}{\hypertarget{m.link.loglog}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.loglog":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the loglog function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\exp(-\exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.cauchit}{\hypertarget{m.link.cauchit}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.cauchit":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the cauchit function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $0.5 + (1/\pi) \tan^{-1}(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.softplus}{\hypertarget{m.link.softplus}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.softplus":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the softplus function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.relu}{\hypertarget{m.link.relu}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.relu":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the rectified linear unit (ReLu) function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\log(1.0 + \exp(x_i))$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.link.tanh}{\hypertarget{m.link.tanh}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"m.link.tanh":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Normalize a prediction with the hyperbolic tangent function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Each element $x_i$ is mapped to $\tanh(x_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {m.kernel.linear}{\hypertarget{m.kernel.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.linear":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Linear kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & {\it (return value)} \rm & Returns the dot product of {\PFAp x} and {\PFAp y}, $\sum_{i=1}^{n} x_{i} y_{j}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23000:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.kernel.rbf}{\hypertarget{m.kernel.rbf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.rbf":$\!$ [x, y, gamma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Radial Basis Function (RBF) kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & {\it (return value)} \rm & Returns the result of $\mathrm{exp}(-\gamma || x - y ||^{2})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23010:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.kernel.poly}{\hypertarget{m.kernel.poly}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.poly":$\!$ [x, y, gamma, intercept, degree]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & \PFAc intercept \rm & double \\  & \PFAc degree \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Polynomial kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & \PFAc intecept \rm & Intercept constant.  \\  & \PFAc degree \rm & Degree of the polynomial kernel.  \\  & {\it (return value)} \rm & Returns the result of $(\gamma \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})^{\mathrm{degree}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23020:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {m.kernel.sigmoid}{\hypertarget{m.kernel.sigmoid}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"m.kernel.sigmoid":$\!$ [x, y, gamma, intercept]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & \PFAc gamma \rm & double \\  & \PFAc intercept \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Sigmoid kernel function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Length {\PFAp n} vector.  \\  & \PFAc y \rm & Length {\PFAp n} vector.  \\  & \PFAc gamma \rm & Gamma coefficient.  \\  & \PFAc intecept \rm & Intercept constant.  \\  & {\it (return value)} \rm & Returns the result of $\mathrm{tanh}( \mathrm{gamma} \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#23030:} Raises a ``arrays must have same length'' error if the lengths of {\PFAp x} and {\PFAp y} are not the same.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.map}{\hypertarget{la.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.map":$\!$ [x, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc fcn \rm & function (double) $\to$ double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element from {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform scalar multiplication on a matrix: supply a function that multiplies each element by a constant. \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.scale}{\hypertarget{la.scale}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.scale":$\!$ [x, alpha]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc alpha \rm & double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Scale vector or matrix {\PFAp x} by factor {\PFAp alpha}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.zipmap}{\hypertarget{la.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.zipmap":$\!$ [x, y, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\  & \PFAc fcn \rm & function (double, double) $\to$ double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each pair of elements from {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This can be used to perform matrix addition: supply a function that adds each pair of elements. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and columns in {\PFAp x} must be equal to the number of rows and columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ The order in which elements are computed is not specified, and may be in parallel.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24020:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.add}{\hypertarget{la.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.add":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Add two vectors or matrices {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24030:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.sub}{\hypertarget{la.sub}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.sub":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Subtract vector or matrix {\PFAp y} from {\PFAp x} (returns $x - y$). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which elements are computed is not specified, and may be in parallel. \vspace{0.1 cm} \\ Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24040:} In the array signature, if any element in {\PFAp x} does not have a corresponding element in {\PFAp y} (or vice-versa), this function raises a ``misaligned matrices'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.dot}{\hypertarget{la.dot}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.dot":$\!$ [x, y]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc y \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc y \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Multiply two matrices or a matrix and a vector, which may be represented as dense arrays or potentially sparse maps. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of columns of {\PFAp x} must be equal to the number of rows (or the number of elements) of {\PFAp y} (dense matrix).  In the map signature, missing values are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ Matrices supplied as maps may be computed using sparse methods.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24050:} In the array signature, if the dimensions of {\PFAp x} do not correspond to the dimension(s) of {\PFAp y}, this function raises a ``misaligned matrices'' error. \vspace{0.1 cm} \\ {\bf \#24051:} If {\PFAp x} or {\PFAp y} has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24052:} If {\PFAp x} or {\PFAp y} contains any non-finite values, this function raises a ``contains non-finite value'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.transpose}{\hypertarget{la.transpose}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.transpose":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Transpose a rectangular matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24060:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24061:} If the columns are ragged (arrays of different lengths or maps with different sets of keys), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.inverse}{\hypertarget{la.inverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.inverse":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the inverse (or Moore-Penrose pseudoinverse, if not square) of {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24070:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24071:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.trace}{\hypertarget{la.trace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.trace":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the trace of a matrix (sum of diagonal elements). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24080:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.det}{\hypertarget{la.det}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.det":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the determinant of a matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24090:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24091:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24092:} In the array signature, if {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.symmetric}{\hypertarget{la.symmetric}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.symmetric":$\!$ [x, tolerance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc tolerance \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if a matrix is symmetric withing tolerance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & Returns {\PFAc true} if the absolute value of element $i$, $j$ minus element $j$, $i$ is less than {\PFAp tolerance}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24100:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24101:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24102:} If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.eigenBasis}{\hypertarget{la.eigenBasis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.eigenBasis":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the eigenvalues and eigenvectors of a real, symmetric matrix {\PFAp x} (which are all real). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & A matrix in which each row (first level of array or map hierarchy) is a normalized eigenvector of {\PFAp x} divided by the square root of the corresponding eigenvalue (The sign is chosen such that the first component is positive.).  If provided as an array, the rows are in decreasing order of eigenvalue (increasing order of inverse square root eigenvalue).  If provided as a map, the rows are keyed by string representations of integers starting with {\PFAc ``0''}, and increasing row keys are in decreasing order of eigenvalue. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is the covariance matrix of a zero-mean dataset, the matrix that this function returns would transform the dataset to one with unit variances and zero covariances. \vspace{0.1 cm} \\ If {\PFAp x} is not symmetric or not exactly symmetric, it will first be symmetrized ($(x + x^T)/2$).  For example, a matrix represented by only the upper triangle (other elements are zero or missing from the map) becomes a symmetric matrix with the upper triangle unchanged. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24110:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24111:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error. \vspace{0.1 cm} \\ {\bf \#24112:} If {\PFAp x} is not a square matrix, this function raises a ``non-square matrix'' error. \vspace{0.1 cm} \\ {\bf \#24113:} If {\PFAp x} contains non-finite values, this function raises a ``non-finite matrix'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {la.truncate}{\hypertarget{la.truncate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"la.truncate":$\!$ [x, keep]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of array of double \\  & \PFAc keep \rm & int \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of map of double \\  & \PFAc keep \rm & array of string \\ & {\it (returns)} & map of map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove rows from a matrix so that it becomes a projection operator. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The matrix to truncate.  \\  & \PFAc keep \rm & If {\PFAp x} is an array, this is the number of rows to keep, starting with the first row.  If {\PFAp x} is a map, this is the set of keys to keep.  If {\PFAp keep} is larger than the number of rows or is not a subset of the keys, the excess is ignored.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}In Principle Component Analysis (PCA), this would be applied to the eigenbasis transformation ({\PFAf \hyperlink{la.eigenBasis}{la.eigenBasis}}) to keep only a specified number (or set) of transformed components.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#24120:} If the matrix has fewer than 1 row or fewer than 1 column, this function raises a ``too few rows/cols'' error. \vspace{0.1 cm} \\ {\bf \#24121:} If {\PFAp x} is an array with ragged columns (arrays of different lengths), this function raises a ``ragged columns'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.simpleEuclidean}{\hypertarget{metric.simpleEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleEuclidean":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric without a special similarity function and without any handling of missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Returns $\sqrt{\sum_i (x_i - y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28000:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.absDiff}{\hypertarget{metric.absDiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.absDiff":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns the absolute Euclidean distance between {\PFAp x} and {\PFAp y}. \vspace{0.2 cm} \\ }}%
    {metric.gaussianSimilarity}{\hypertarget{metric.gaussianSimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.gaussianSimilarity":$\!$ [x, y, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Similarity function (1-dimensional metric) that returns $\exp(-\ln(2) (x - y)^2 / \mbox{sigma}^2)$. \vspace{0.2 cm} \\ }}%
    {metric.euclidean}{\hypertarget{metric.euclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.euclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.euclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (any {\PFAtp A}, any {\PFAtp B}) $\to$ double \\  & \PFAc x \rm & array of union of \{null, {\PFAtp A}\} \\  & \PFAc y \rm & array of union of \{null, {\PFAtp B}\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric, which is the distance function for ordinary space, given by the Pythagorean formula (also known as the 2-norm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $\sqrt{(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sqrt{\sum_i \mbox{similarity}(x_i,y_i)^2}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28030:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.squaredEuclidean}{\hypertarget{metric.squaredEuclidean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.squaredEuclidean":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.squaredEuclidean":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Euclidean metric squared, which has the same ordering as the Euclidean metric, but avoids a square root calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)^2$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28040:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.chebyshev}{\hypertarget{metric.chebyshev}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.chebyshev":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.chebyshev":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Chebyshev metric, also known as the infinity norm or chessboard distance (since it is the number of moves required for a chess king to travel between two points). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\max_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\max_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28050:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.taxicab}{\hypertarget{metric.taxicab}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.taxicab":$\!$ [similarity, x, y]\} \rm or \PFAc \{"metric.taxicab":$\!$ [similarity, x, y, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Taxicab metric, also known as the 1-norm, city-block or Manhattan distance (since it is the distance when confined to a rectilinear city grid). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $\sum_i \mbox{similarity}(x_i,y_i)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28060:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.minkowski}{\hypertarget{metric.minkowski}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"metric.minkowski":$\!$ [similarity, x, y, p]\} \rm or \PFAc \{"metric.minkowski":$\!$ [similarity, x, y, p, missingWeight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc similarity \rm & function (double, double) $\to$ double \\  & \PFAc x \rm & array of union of \{null, double\} \\  & \PFAc y \rm & array of union of \{null, double\} \\  & \PFAc p \rm & double \\  & \PFAc missingWeight \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Minkowski metric, also known as the p-norm, a generalized norm whose limits include Euclidean, Chebyshev, and Taxicab. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc similarity \rm & Similarity function (1-dimensional metric) that quantifies the distance between components of {\PFAp x} and components of {\PFAp y}.  \\  & \PFAc x \rm & First sample vector, which may have missing values.  \\  & \PFAc y \rm & Second sample vector, which may have missing values.  (Must have the same dimension as {\PFAp x}.)  \\  & \PFAc missingWeight \rm & Optional missing-value weights: a vector with the same dimension as {\PFAp x} and {\PFAp y} that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.  \\  & {\it (return value)} \rm & With $I(x_i,y_i)$ = 0 if component $i$ of {\PFAp x} or {\PFAp y} is missing, 1 otherwise, this function returns $((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^p)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i))^{1/p}$ where $q_i$ are components of the missing-value weights.  Without missing values, it is $(\sum_i \mbox{similarity}(x_i,y_i)^p)^{1/p}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If all values are missing, the function returns {\PFAc NaN}. \vspace{0.1 cm} \\ If {\PFAp p} is positive infinity, this function is equivalent to {\PFAf \hyperlink{metric.chebyshev}{metric.chebyshev}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28070:} Raises ``dimensions of vectors do not match'' if all vectors do not have the same dimension. \vspace{0.1 cm} \\ {\bf \#28071:} Raises ``Minkowski parameter p must be positive'' if {\PFAp p} is less than or equal to zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.simpleMatching}{\hypertarget{metric.simpleMatching}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.simpleMatching":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Simple metric on binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + a_{10} + a_{01} + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28080:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.jaccard}{\hypertarget{metric.jaccard}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.jaccard":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Jaccard similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $a_{11}/(a_{11} + a_{10} + a_{01})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28090:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.tanimoto}{\hypertarget{metric.tanimoto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.tanimoto":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Tanimoto similarity of binary vectors. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(a_{11} + a_{00})/(a_{11} + 2*(a_{10} + a_{01}) + a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28100:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {metric.binarySimilarity}{\hypertarget{metric.binarySimilarity}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"metric.binarySimilarity":$\!$ [x, y, c00, c01, c10, c11, d00, d01, d10, d11]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of boolean \\  & \PFAc y \rm & array of boolean \\  & \PFAc c00 \rm & double \\  & \PFAc c01 \rm & double \\  & \PFAc c10 \rm & double \\  & \PFAc c11 \rm & double \\  & \PFAc d00 \rm & double \\  & \PFAc d01 \rm & double \\  & \PFAc d10 \rm & double \\  & \PFAc d11 \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Genaralized similarity of binary vectors, using {\PFAp c00}, {\PFAp c01}, {\PFAp c10}, {\PFAp c11}, {\PFAp d00}, {\PFAp d01}, {\PFAp d10}, and {\PFAp d11} as parameters to reproduce all other binary similarity metrics. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & First sample vector.  \\  & \PFAc y \rm & Second sample vector.  (Must have the same dimension as {\PFAp x}.)  \\  & {\it (return value)} \rm & Where $a_{11}$ is the number of {\PFAp x}, {\PFAp y} coordinate pairs that are equal to {\PFAc true, true}, $a_{10}$ is the number of {\PFAc true, false}, $a_{01}$ is the number of {\PFAc false, true}, and $a_{00}$ is the number of {\PFAc false, false}, this function returns $(c_{11}a_{11} + c_{10}a_{10} + c_{01}a_{01} + c_{00}a_{00})/(d_{11}a_{11} + d_{10}a_{10} + d_{01}a_{01} + d_{00}a_{00})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#28110:} Raises ``dimensions of vectors do not match'' if {\PFAp x} and {\PFAp y} do not have the same dimension.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.int}{\hypertarget{rand.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.int":$\!$ []\} \rm or \PFAc \{"rand.int":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random integer, either on the entire entire 32-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34000:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.long}{\hypertarget{rand.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.long":$\!$ []\} \rm or \PFAc \{"rand.long":$\!$ [low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & long \\  & \PFAc high \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random long integer, either on the entire 64-bit range or between {\PFAp low} (inclusive) and {\PFAp high} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34010:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.float}{\hypertarget{rand.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.float":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & float \\  & \PFAc high \rm & float \\  & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random float between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34020:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.double}{\hypertarget{rand.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.double":$\!$ [low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random double between {\PFAp low} and {\PFAp high}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34030:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.choice}{\hypertarget{rand.choice}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choice":$\!$ [population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random item from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34040:} Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.choices}{\hypertarget{rand.choices}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.choices":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (with replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34050:} Raises a ``population must not be empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.sample}{\hypertarget{rand.sample}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.sample":$\!$ [size, population]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of random items (without replacement) from a bag of items. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34060:} Raises a ``population must not be empty'' error if {\PFAp population} is empty. \vspace{0.1 cm} \\ {\bf \#34061:} Raises a ``population smaller than requested subsample'' error if the size of {\PFAp population} is less than {\PFAp size}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.histogram}{\hypertarget{rand.histogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.histogram":$\!$ [distribution]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc distribution \rm & array of any record {\PFAtp A} with \{{\PFApf prob:}$\!$ double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random index of {\PFAp distribution} with probability proportional to the value of that index or a random item from {\PFAp distribution} with probability proportional to the {\PFApf prob} field. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the probabilities do not sum to 1.0, they will be normalized first. \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34070:} Raises a ``distribution must be non-empty'' error if no items of {\PFAp distribution} are non-zero. \vspace{0.1 cm} \\ {\bf \#34071:} Raises a ``distribution must be finite'' error if any items of {\PFAp distribution} are infinite or {\PFAc NaN}. \vspace{0.1 cm} \\ {\bf \#34072:} Raises a ``distribution must be non-negative'' error if any items of {\PFAp distribution} are negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.string}{\hypertarget{rand.string}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.string":$\!$ [size]\} \rm or \PFAc \{"rand.string":$\!$ [size, population]\} \rm or \PFAc \{"rand.string":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random string with {\PFAp size} characters from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of characters in the resulting string.  \\  & \PFAc population \rm & Bag of characters to choose from.  Characters repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum code-point to sample (inclusive).  \\  & \PFAc high \rm & Maximum code-point to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Without a range, this function samples the entire Unicode table up to and including {\PFAc 0xD800}; ASCII characters are rare. \vspace{0.1 cm} \\ The ASCII printable range is {\PFAp low} = 33, {\PFAp high} = 127. \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34080:} Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#34081:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ {\bf \#34082:} Raises an ``invalid char'' error if {\PFAp low} is less than 1 or greater than {\PFAc 0xD800} or if {\PFAp high} is less than 1 or greater than {\PFAc 0xD800}. \vspace{0.1 cm} \\ {\bf \#34083:} Raises an ``population must be non-empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.bytes}{\hypertarget{rand.bytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"rand.bytes":$\!$ [size]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, population]\} \rm or \PFAc \{"rand.bytes":$\!$ [size, low, high]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc population \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc size \rm & int \\  & \PFAc low \rm & int \\  & \PFAc high \rm & int \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAp size} random bytes from a range, if provided. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc size \rm & Number of bytes in the result.  \\  & \PFAc population \rm & Bag of bytes to choose from.  Bytes repeated $N$ times in the {\PFAp population} have probability $N$/{\PFAp size}, but order is irrelevant.  \\  & \PFAc low \rm & Minimum byte value to sample (inclusive).  \\  & \PFAc high \rm & Maximum byte value to sample (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#34090:} Raises a ``size must be positive'' error if {\PFAp size} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#34091:} Raises a ``high must be greater than low'' error if {\PFAp high} is less than or equal to {\PFAp low}. \vspace{0.1 cm} \\ {\bf \#34092:} Raises an ``invalid byte'' error if {\PFAp low} is less than 0 or greater than 255 or if {\PFAp high} is less than 0 or greater than 256. \vspace{0.1 cm} \\ {\bf \#34093:} Raises an ``population must be non-empty'' error if {\PFAp population} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.uuid}{\hypertarget{rand.uuid}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.uuid":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use rand.uuid4 instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random (type 4) UUID with IETF variant (8). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & The return value is a string with the form {\PFAc xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx} where {\PFAc x} are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.uuid4}{\hypertarget{rand.uuid4}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.uuid4":$\!$ []\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random (type 4) UUID with IETF variant (8). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & {\it (return value)} \rm & The return value is a string with the form {\PFAc xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx} where {\PFAc x} are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {rand.gaussian}{\hypertarget{rand.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"rand.gaussian":$\!$ [mu, sigma]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a random number from a Gaussian (normal) distribution with mean {\PFAp mu} and standard deviation {\PFAp sigma}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.len}{\hypertarget{s.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.len":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of string {\PFAp s}. \vspace{0.2 cm} \\ }}%
    {s.substr}{\hypertarget{s.substr}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substr":$\!$ [s, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the substring of {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.substrto}{\hypertarget{s.substrto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.substrto":$\!$ [s, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp s} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.contains}{\hypertarget{s.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.contains":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {s.count}{\hypertarget{s.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.count":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp needle} is an empty string, the result is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.index}{\hypertarget{s.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.index":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {s.rindex}{\hypertarget{s.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rindex":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or -1 if {\PFAp haystack} does not contain {\PFAp needle}. \vspace{0.2 cm} \\ }}%
    {s.startswith}{\hypertarget{s.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.startswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {s.endswith}{\hypertarget{s.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.endswith":$\!$ [haystack, needle]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc needle \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {s.join}{\hypertarget{s.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.join":$\!$ [array, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc array \rm & array of string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Combine strings from {\PFAp array} into a single string, delimited by {\PFAp sep}. \vspace{0.2 cm} \\ }}%
    {s.split}{\hypertarget{s.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.split":$\!$ [s, sep]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc sep \rm & string \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Divide a string into an array of substrings, splitting at and removing delimiters {\PFAp sep}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp s} does not contain {\PFAp sep}, this function returns an array whose only element is {\PFAp s}.  If {\PFAp sep} appears at the beginning or end of {\PFAp s}, the array begins with or ends with an empty string.  These conventions match Python's behavior.  \vspace{0.1 cm} \\ If {\PFAp sep} is an empty string, this function returns an empty array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.hex}{\hypertarget{s.hex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.hex":$\!$ [x]\} \rm or \PFAc \{"s.hex":$\!$ [x, width, zeroPad]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format an unsigned number as a hexidecimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Digits ``a'' (decimal 10) through ``f'' (decimal 15) are represented by lowercase letters.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39110:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ {\bf \#39111:} If {\PFAp x} is negative, a ``negative number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.int}{\hypertarget{s.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.int":$\!$ [x]\} \rm or \PFAc \{"s.int":$\!$ [x, width, zeroPad]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format an integer as a decimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The integer.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide enough precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39240:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.number}{\hypertarget{s.number}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"s.number":$\!$ [x]\} \rm or \PFAc \{"s.number":$\!$ [x, width, zeroPad]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision]\} \rm or \PFAc \{"s.number":$\!$ [x, width, precision, minNoExp, maxNoExp]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use s.int for integers.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc width \rm & int \\  & \PFAc zeroPad \rm & boolean \\ & {\it (returns)} & string \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use s.int for integers.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc width \rm & union of \{int, null\} \\  & \PFAc precision \rm & union of \{int, null\} \\  & \PFAc minNoExp \rm & double \\  & \PFAc maxNoExp \rm & double \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Format a number as a decimal string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number.  Note that different signatures apply to integers and floating point numbers.  \\  & \PFAc width \rm & Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.  \\  & \PFAc zeroPad \rm & If true, pad the integer with zeros to fill up to {\PFAp width}.  \\  & \PFAc precision \rm & Optional precision with which to represent the number.  If omitted, at most six digits after the decimal point will be shown, unless they are zero.  \\  & \PFAc minNoExp \rm & Minimum absolute value that is not presented in scientific notation; 0.0001 if omitted.  \\  & \PFAc maxNoExp \rm & Maxiumum absolute value that is not presented in scientific notation; 100000 if omitted.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp precision} requires more space than {\PFAp width}, the string will be wide enough to accommodate the {\PFAp precision}. \vspace{0.1 cm} \\ Floating point numbers always have a decimal point with at least one digit after the decimal, even if it is zero. \vspace{0.1 cm} \\ Exponents are represented by a lowercase ``e'' which is always followed by a sign, whether positive or negative, and an exponent of two or more digits (single-digit exponents are zero-padded). \vspace{0.1 cm} \\ The base of a number is preceded by a ``-'' if negative, but not a ``+'' if positive. \vspace{0.1 cm} \\ Special floating point values are represented in the following ways: negative zero as zero (no negative sign), not a number as ``nan'', positive infinity as ``inf'', and negative infinity as ``-inf'' (lowercase).  They follow the same precision and width rules as normal numbers, where applicable. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#39120:} If {\PFAp width} is negative and {\PFAp zeroPad} is {\PFAc true}, a ``negative width cannot be used with zero-padding'' error is raised. \vspace{0.1 cm} \\ {\bf \#39121:} If {\PFAp precision} is provided and is less than zero, a ``negative precision'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.concat}{\hypertarget{s.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.concat":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc y \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Append {\PFAp y} to {\PFAp x} to form a single string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}To concatenate an array of strings, use s.join with an empty string as {\PFAp sep}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.repeat}{\hypertarget{s.repeat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.repeat":$\!$ [s, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc n \rm & int \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Create a string by concatenating {\PFAp s} with itself {\PFAp n} times. \vspace{0.2 cm} \\ }}%
    {s.lower}{\hypertarget{s.lower}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lower":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to lower-case. \vspace{0.2 cm} \\ }}%
    {s.upper}{\hypertarget{s.upper}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.upper":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert {\PFAp s} to upper-case. \vspace{0.2 cm} \\ }}%
    {s.lstrip}{\hypertarget{s.lstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.lstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning (left) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.rstrip}{\hypertarget{s.rstrip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.rstrip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the end (right) of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.strip}{\hypertarget{s.strip}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.strip":$\!$ [s, chars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc chars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Remove any characters found in {\PFAp chars} from the beginning or end of {\PFAp s}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of characters in {\PFAp chars} is irrelevant.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {s.replaceall}{\hypertarget{s.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replaceall":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace every instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {s.replacefirst}{\hypertarget{s.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacefirst":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first (leftmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {s.replacelast}{\hypertarget{s.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.replacelast":$\!$ [s, original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc original \rm & string \\  & \PFAc replacement \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last (rightmost) instance of the substring {\PFAp original} from {\PFAp s} with {\PFAp replacement}. \vspace{0.2 cm} \\ }}%
    {s.translate}{\hypertarget{s.translate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"s.translate":$\!$ [s, oldchars, newchars]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & \PFAc oldchars \rm & string \\  & \PFAc newchars \rm & string \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} For each character in {\PFAp s} that is also in {\PFAp oldchars} with some index {\PFAc i}, replace it with the character at index {\PFAc i} in {\PFAp newchars}.  Any character in {\PFAp s} that is not in {\PFAp oldchars} is unchanged.  Any index {\PFAc i} that is greater than the length of {\PFAp newchars} is replaced with nothing. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is the behavior of the the Posix command {\PFAc tr}, where {\PFAp s} takes the place of standard input and {\PFAp oldchars} and {\PFAp newchars} are the {\PFAc tr} commandline options.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.index}{\hypertarget{re.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.index":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indices in {\PFAp haystack} of the begining and end of the first match defined by {\PFAp pattern}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35000:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.contains}{\hypertarget{re.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.contains":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return true if {\PFAp pattern} matches anywhere within {\PFAp haystack}, otherwise return false. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35010:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.count}{\hypertarget{re.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.count":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp pattern} matches in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35020:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.rindex}{\hypertarget{re.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.rindex":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of the last {\PFAp pattern} match in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35030:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.groups}{\hypertarget{re.groups}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groups":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35040:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.indexall}{\hypertarget{re.indexall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.indexall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of every {\PFAp pattern} match in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35050:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findall}{\hypertarget{re.findall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array containing each string that {\PFAp pattern} matched in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35060:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findfirst}{\hypertarget{re.findfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findfirst":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & union of \{string, null\} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & union of \{bytes, null\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first occurance of what {\PFAp pattern} matched in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35070:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findgroupsfirst}{\hypertarget{re.findgroupsfirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsfirst":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at the first occurance of {\PFAp pattern} in {\PFAp haystack}. Regular expressions follow the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35080:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.findgroupsall}{\hypertarget{re.findgroupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.findgroupsall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of strings or bytes for each {\PFAp pattern} sub-match (group-match) at every occurance of {\PFAp pattern} in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35090:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.groupsall}{\hypertarget{re.groupsall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.groupsall":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of array of array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of array of array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the location indices of each {\PFAp pattern} sub-match (group-match) for each occurance of {\PFAp pattern} in {\PFAp haystack}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35100:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replacefirst}{\hypertarget{re.replacefirst}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacefirst":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the first {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35110:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replacelast}{\hypertarget{re.replacelast}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replacelast":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the last {\PFAp pattern} match in {\PFAp haystack} with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35120:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.split}{\hypertarget{re.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.split":$\!$ [haystack, pattern]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\ & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\ & {\it (returns)} & array of bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Break {\PFAp haystack} into an array of strings or bytes on the separator defined by {\PFAp pattern}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35130:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {re.replaceall}{\hypertarget{re.replaceall}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"re.replaceall":$\!$ [haystack, pattern, replacement]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & string \\  & \PFAc pattern \rm & string \\  & \PFAc replacement \rm & string \\ & {\it (returns)} & string \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & bytes \\  & \PFAc pattern \rm & bytes \\  & \PFAc replacement \rm & bytes \\ & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace the all {\PFAp pattern} matches in {\PFAp haystack} with {\PFAp replacement}. The regular expression follows the POSIX extended standard (like {\PFAp grep -e} in Linux and UNIX). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#35140:} If {\PFAp pattern} is not a valid regular expression, a ``bad pattern'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.int}{\hypertarget{parse.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.int":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as an integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33000:} Raises ``not an integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 32-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ {\bf \#33001:} Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.long}{\hypertarget{parse.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.long":$\!$ [str, base]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & \PFAc base \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a long integer with base {\PFAp base}, if possible. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33010:} Raises ``not a long integer'' if the string does not conform to ``{\PFAc [-+]?[0-9a-z]+}'' or the number it evaluates to is too large to represent as a 64-bit integer or uses characters as large as or larger than {\PFAp base} ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35). \vspace{0.1 cm} \\ {\bf \#33011:} Raises ``base out of range'' if {\PFAp base} is less than 2 or greater than 36.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.float}{\hypertarget{parse.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.float":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a single-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a single-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a single-precision float, the resulting value is zero. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33020:} Raises ``not a single-precision float'' if the string does not conform to ``{\PFAc [-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?}'', ``inf'', ``+inf'', ``-inf'', or ``nan''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {parse.double}{\hypertarget{parse.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"parse.double":$\!$ [str]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc str \rm & string \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Parse {\PFAp str} and return its value as a double-precision floating point number. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive. \vspace{0.1 cm} \\ If the string is ``nan'', the resulting value is not-a-number and if the string is ``inf'', ``+inf'', or ``-inf'', the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754). \vspace{0.1 cm} \\ If the number's magnitude is too large to be represented as a double-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a double-precision float, the resulting value is zero. \vspace{0.1 cm} \\ Leading or trailing whitespace and any capitalization is allowed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#33030:} Raises ``not a double-precision float'' if the string does not conform to ``{\PFAc [-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?}'', ``inf'', ``+inf'', ``-inf'', or ``nan''.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.signed}{\hypertarget{cast.signed}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.signed":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into a signed two's complement representation that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function may be negative, zero, or positive.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17000:} If {\PFAp bits} is less than 2 or greater than 64, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.unsigned}{\hypertarget{cast.unsigned}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.unsigned":$\!$ [x, bits]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\  & \PFAc bits \rm & int \\  & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Truncate {\PFAp x} as though its signed long two's complement representation were inserted, bit-for-bit, into an unsigned register that is {\PFAp bits} wide, removing the most significant bits. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The result of this function is always nonnegative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17010:} If {\PFAp bits} is less than 1 or greater than 63, an ``unrepresentable unsigned number'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.int}{\hypertarget{cast.int}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.int":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to an integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17020:} Results outside of -2147483648 and 2147483647 (inclusive) produce an ``int overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.long}{\hypertarget{cast.long}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.long":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a 64-bit integer, rounding if necessary. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17030:} Results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a ``long overflow'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.float}{\hypertarget{cast.float}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.float":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a single-precision floating point number, rounding if necessary. \vspace{0.2 cm} \\ }}%
    {cast.double}{\hypertarget{cast.double}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.double":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & long \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Cast {\PFAp x} to a double-precision floating point number. \vspace{0.2 cm} \\ }}%
    {cast.fanoutBoolean}{\hypertarget{cast.fanoutBoolean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutBoolean":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutBoolean":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17060:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.fanoutInt}{\hypertarget{cast.fanoutInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutInt":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutInt":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17070:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.fanoutLong}{\hypertarget{cast.fanoutLong}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutLong":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutLong":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of long \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17080:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.fanoutFloat}{\hypertarget{cast.fanoutFloat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutFloat":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutFloat":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of float \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17090:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.fanoutDouble}{\hypertarget{cast.fanoutDouble}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"cast.fanoutDouble":$\!$ [x]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, dictionary, outOfRange]\} \rm or \PFAc \{"cast.fanoutDouble":$\!$ [x, minimum, maximum, outOfRange]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc dictionary \rm & array of string \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc minimum \rm & int \\  & \PFAc maximum \rm & int \\  & \PFAc outOfRange \rm & boolean \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fanout {\PFAp x} to an array of booleans, all {\PFAc false} except the matching value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Categorical datum  \\  & \PFAc dictionary \rm & Possible values of {\PFAp x}, which is needed if {\PFAp x} is an arbitrary string.  \\  & \PFAc minimum \rm & Inclusive minimum value of {\PFAp x}.  \\  & \PFAc maximum \rm & Excluded maximum value of {\PFAp x}.  \\  & \PFAc outOfRange \rm & If {\PFAc true}, include an extra item in the output to represent values of {\PFAp x} that are outside of the specified range.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#17100:} If not all values in {\PFAp dictionary} are unique, this function raises a ``non-distinct values in dictionary'' runtime error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.avro}{\hypertarget{cast.avro}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.avro":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode an arbitrary object as Avro bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}May be composed with {\PFAf \hyperlink{bytes.toBase64}{bytes.toBase64}} to get an efficient string representation (e.g. for map keys).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {cast.json}{\hypertarget{cast.json}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"cast.json":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode an arbitrary object as a JSON string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The form of this JSON string (spacing, order of keys in objects, etc.) is not guaranteed from one system to another. \vspace{0.1 cm} \\ Should exclude unnecessary whitespace. \vspace{0.1 cm} \\ {\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.len}{\hypertarget{a.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.len":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of array {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {a.subseq}{\hypertarget{a.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseq":$\!$ [a, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.head}{\hypertarget{a.head}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.head":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15020:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.tail}{\hypertarget{a.tail}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.tail":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the first item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15030:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.last}{\hypertarget{a.last}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.last":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the last item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15040:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.init}{\hypertarget{a.init}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.init":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all but the last item of the array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15050:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.subseqto}{\hypertarget{a.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subseqto":$\!$ [a, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.contains}{\hypertarget{a.contains}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.contains":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.count}{\hypertarget{a.count}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.count":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Count the number of times {\PFAp needle} appears in {\PFAp haystack} or the number of times the {\PFAp needle} function evaluates to {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the {\PFAp needle} is an empty array, the result is zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.index}{\hypertarget{a.index}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.index":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the lowest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }}%
    {a.rindex}{\hypertarget{a.rindex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.rindex":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the highest index where {\PFAp haystack} contains {\PFAp needle} or the {\PFAp needle} function evaluates to {\PFAc true}, $-1$ if there is no such element. \vspace{0.2 cm} \\ }}%
    {a.startswith}{\hypertarget{a.startswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.startswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the first (leftmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {a.endswith}{\hypertarget{a.endswith}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.endswith":$\!$ [haystack, needle]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & array of {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc haystack \rm & array of any {\PFAtp A} \\  & \PFAc needle \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the last (rightmost) subseqence of {\PFAp haystack} is equal to {\PFAp needle}, false otherwise. \vspace{0.2 cm} \\ }}%
    {a.concat}{\hypertarget{a.concat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.concat":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate {\PFAp a} and {\PFAp b} to make a new array of the same type. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The length of the returned array is the sum of the lengths of {\PFAp a} and {\PFAp b}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.append}{\hypertarget{a.append}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.append":$\!$ [a, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.cycle}{\hypertarget{a.cycle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.cycle":$\!$ [a, item, maxLength]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\  & \PFAc maxLength \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by adding {\PFAp item} at the end of {\PFAp a}, but keep the length less than or equal to {\PFAp maxLength} by removing items from the beginning. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15150:} If {\PFAp maxLength} is less than 0, this function raises a ``maxLength out of range'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.insert}{\hypertarget{a.insert}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.insert":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by inserting {\PFAp item} at {\PFAp index} of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one more than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15160:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.replace}{\hypertarget{a.replace}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.replace":$\!$ [a, index, item]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\  & \PFAc item \rm & {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by replacing {\PFAp index} of {\PFAp a} with {\PFAp item}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), following Python's index behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is equal to that of {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15170:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.remove}{\hypertarget{a.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.remove":$\!$ [a, start, end]\} \rm or \PFAc \{"a.remove":$\!$ [a, index]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc index \rm & int \\ & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new array by removing elements from {\PFAp a} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) or just a single {\PFAp index}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior. \vspace{0.1 cm} \\ Note: {\PFAp a} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ The length of the returned array is one less than {\PFAp a}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15180:} If {\PFAp index} is beyond the range of {\PFAp a}, an ``index out of range'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.rotate}{\hypertarget{a.rotate}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.rotate":$\!$ [a, steps]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc steps \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array formed by rotating {\PFAp a} left {\PFAp steps} spaces. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15190:} If {\PFAp steps} is less than zero, a ``steps out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sort}{\hypertarget{a.sort}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sort":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sortLT}{\hypertarget{a.sortLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sortLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in ascending order as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.shuffle}{\hypertarget{a.shuffle}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.shuffle":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same elements as {\PFAp a} but in a random order. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp a} is not changed in-place; this is a side-effect-free function (except for updating the random number generator). \vspace{0.1 cm} \\ {\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reverse}{\hypertarget{a.reverse}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reverse":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the elements of {\PFAp a} in reversed order. \vspace{0.2 cm} \\ }}%
    {a.max}{\hypertarget{a.max}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.max":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15240:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.min}{\hypertarget{a.min}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.min":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15250:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.maxLT}{\hypertarget{a.maxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15260:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minLT}{\hypertarget{a.minLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15270:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.maxN}{\hypertarget{a.maxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15280:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15281:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minN}{\hypertarget{a.minN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15290:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15291:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.maxNLT}{\hypertarget{a.maxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.maxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15300:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15301:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.minNLT}{\hypertarget{a.minNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.minNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15310:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15311:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmax}{\hypertarget{a.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmax":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15320:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmin}{\hypertarget{a.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmin":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15330:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxLT}{\hypertarget{a.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the maximum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the maximum is not unique, this function returns the index of the first maximal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15340:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminLT}{\hypertarget{a.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminLT":$\!$ [a, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the index of the minimum value in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the minimum is not unique, this function returns the index of the first minimal value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15350:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxN}{\hypertarget{a.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15360:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15361:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminN}{\hypertarget{a.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminN":$\!$ [a, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15370:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15371:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argmaxNLT}{\hypertarget{a.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argmaxNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15380:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15381:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.argminNLT}{\hypertarget{a.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.argminNLT":$\!$ [a, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the indexes of the {\PFAp n} lowest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their indexes will be returned in ascending order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15390:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15391:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.sum}{\hypertarget{a.sum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.sum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15400:} If the array items have integer type and the final result is too large or small to be represented as an integer, an ``int overflow'' error is raised. \vspace{0.1 cm} \\ {\bf \#15401:} If the array items have long integer type and the final result is too large or small to be represented as a long integer, an ``long overflow'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.product}{\hypertarget{a.product}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.product":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} of \{int, long, float, double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the product of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns one if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15410:} If the array items have integer type and the final result is too large or small to be represented as an integer, an ``int overflow'' error is raised. \vspace{0.1 cm} \\ {\bf \#15411:} If the array items have long integer type and the final result is too large or small to be represented as a long integer, an ``long overflow'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.lnsum}{\hypertarget{a.lnsum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.lnsum":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the sum of the natural logarithm of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns zero if the array is empty and {\PFAc NaN} if any value in the array is zero or negative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mean}{\hypertarget{a.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the arithmetic mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.geomean}{\hypertarget{a.geomean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.geomean":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the geometric mean of numbers in {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.median}{\hypertarget{a.median}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.median":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is in the center of a sorted version of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an odd number of elements, the median is the exact center of the sorted array.  If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15450:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.ntile}{\hypertarget{a.ntile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.ntile":$\!$ [a, p]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc p \rm & double \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the value that is at the ``n-tile'' of {\PFAp a} (like a percentile). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc a \rm & Array of objects to be take the percentile of.  \\  & \PFAc p \rm & A double between 0 and 1.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp a} has an even number of elements and is a {\PFAc float} or {\PFAc double}, this function will take the average of the two elements closest to the center of the sorted array.  For any other type, it returns the left (first) of the two elements closest to the center of the sorted array.  If {\PFAp p} is exactly one (or greater), the max of the array is returned.  If {\PFAp p} is zero (or less), the min of the array is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15460:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15461:} If {\PFAp p} is NaN, this function raises a ``p not a number'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mode}{\hypertarget{a.mode}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mode":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the mode (most common) value of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If several different values are equally common, the median of these is returned.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15470:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.logsumexp}{\hypertarget{a.logsumexp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.logsumexp":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute $z = \\log(\\sum_{n = 1}^{N} e^{x_n})$ in a numerically stable way. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Returns {\PFAc NaN} if the array is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.distinct}{\hypertarget{a.distinct}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.distinct":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array with the same contents as {\PFAp a} but with duplicates removed. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original array is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.seteq}{\hypertarget{a.seteq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.seteq":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are equivalent, ignoring order and duplicates, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.union}{\hypertarget{a.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the union of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.intersection}{\hypertarget{a.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the intersection of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.diff}{\hypertarget{a.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.symdiff}{\hypertarget{a.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array that represents the symmetric difference of {\PFAp a} and {\PFAp b}, treated as sets (ignoring order and duplicates). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The symmetric difference is ({\PFAp a} diff {\PFAp b}) union ({\PFAp b} diff {\PFAp a}). \vspace{0.1 cm} \\ The order of the original arrays is preserved.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.subset}{\hypertarget{a.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & array of any {\PFAtp A} \\  & \PFAc big \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp little} is a subset of {\PFAp big}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.disjoint}{\hypertarget{a.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp a} and {\PFAp b} are disjoint, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {a.map}{\hypertarget{a.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.map":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.mapWithIndex}{\hypertarget{a.mapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.mapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to index, element pairs from {\PFAp a} and return an array of the results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filter}{\hypertarget{a.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filter":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterWithIndex}{\hypertarget{a.filterWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the elements for which {\PFAp fcn} returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterMap}{\hypertarget{a.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.filterMapWithIndex}{\hypertarget{a.filterMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.filterMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and return an array of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatMap}{\hypertarget{a.flatMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMap":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatMapWithIndex}{\hypertarget{a.flatMapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatMapWithIndex":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}) $\to$ array of any {\PFAtp B} \\  & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each index, element pair of {\PFAp a} and flatten the resulting arrays into a single array. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it will be called exactly once for each element.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.zipmap}{\hypertarget{a.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.zipmap":$\!$ [a, b, fcn]\} \rm or \PFAc \{"a.zipmap":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"a.zipmap":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc d \rm & array of any {\PFAtp D} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15650:} Raises a ``misaligned arrays'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same length.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.zipmapWithIndex}{\hypertarget{a.zipmapWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"a.zipmapWithIndex":$\!$ [a, b, fcn]\} \rm or \PFAc \{"a.zipmapWithIndex":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"a.zipmapWithIndex":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc c \rm & array of any {\PFAtp C} \\  & \PFAc d \rm & array of any {\PFAtp D} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & array of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the indexes and elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15660:} Raises a ``misaligned arrays'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same length.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reduce}{\hypertarget{a.reduce}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduce":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15670:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.reduceRight}{\hypertarget{a.reduceRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.reduceRight":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15680:} If {\PFAp a} is empty, an ``empty array'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.fold}{\hypertarget{a.fold}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.fold":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp B}, {\PFAtp A}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is the running tally and the second parameter is an element from {\PFAp a}. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.foldRight}{\hypertarget{a.foldRight}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.foldRight":$\!$ [a, zero, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc zero \rm & any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ {\PFAtp B} \\  & {\it (returns)} & {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each element of {\PFAp a} and accumulate a tally, starting with {\PFAp zero}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The first parameter of {\PFAp fcn} is an element from {\PFAp a} and the second parameter is the running tally. \vspace{0.1 cm} \\ The order in which {\PFAp fcn} is called on elements of {\PFAp a} is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, {\PFAp fcn} should be associative with {\PFAp zero} as its identity; that is, {\PFAc fcn(zero, zero) = zero}.  It need not be commutative.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.takeWhile}{\hypertarget{a.takeWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.takeWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of the longest prefix that returns {\PFAc true}, stopping with the first {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.dropWhile}{\hypertarget{a.dropWhile}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.dropWhile":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to elements of {\PFAp a} and create an array of all elements after the longest prefix that returns {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Beyond the prefix, the number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.any}{\hypertarget{a.any}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.any":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for any element in {\PFAp a} (logical or). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.all}{\hypertarget{a.all}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.all":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} for all elements in {\PFAp a} (logical and). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.corresponds}{\hypertarget{a.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of elements, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.correspondsWithIndex}{\hypertarget{a.correspondsWithIndex}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.correspondsWithIndex":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc b \rm & array of any {\PFAtp B} \\  & \PFAc fcn \rm & function (int, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of index, element from {\PFAp a}, element from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the lengths of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.slidingWindow}{\hypertarget{a.slidingWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.slidingWindow":$\!$ [a, size, step]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & \PFAc step \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return an array of subsequences of {\PFAp a} with length {\PFAp size} that slide through {\PFAp a} in steps of length {\PFAp step} from left to right. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15770:} If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#15771:} If {\PFAp step} is non-positive, a ``step < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.combinations}{\hypertarget{a.combinations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.combinations":$\!$ [a, size]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc size \rm & int \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all combinations of elements of {\PFAp a} with length {\PFAp size}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#15780:} If {\PFAp size} is non-positive, a ``size < 1'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.permutations}{\hypertarget{a.permutations}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.permutations":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & array of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return all permutations of elements of {\PFAp a}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {a.flatten}{\hypertarget{a.flatten}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.flatten":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of array of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Concatenate the arrays in {\PFAp a}. \vspace{0.2 cm} \\ }}%
    {a.groupby}{\hypertarget{a.groupby}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"a.groupby":$\!$ [a, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ string \\  & {\it (returns)} & map of array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Groups elements of {\PFAp a} by the string that {\PFAp fcn} maps them to. \vspace{0.2 cm} \\ }}%
    {map.len}{\hypertarget{map.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.len":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of a map. \vspace{0.2 cm} \\ }}%
    {map.keys}{\hypertarget{map.keys}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.keys":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of a map (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.values}{\hypertarget{map.values}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.values":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the values of a map (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.containsKey}{\hypertarget{map.containsKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsKey":$\!$ [m, key]\} \rm or \PFAc \{"map.containsKey":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the keys of {\PFAp m} contains {\PFAp key} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {map.containsValue}{\hypertarget{map.containsValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.containsValue":$\!$ [m, value]\} \rm or \PFAc \{"map.containsValue":$\!$ [m, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if the values of {\PFAp m} contains {\PFAp value} or {\PFAp fcn} evaluates to {\PFAc true} for some key of {\PFAp m}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {map.add}{\hypertarget{map.add}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.add":$\!$ [m, key, value]\} \rm or \PFAc \{"map.add":$\!$ [m, item]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & \PFAc value \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc item \rm & {\PFAtp A} \\ & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by adding the {\PFAp key} {\PFAp value} pair to {\PFAp m} or a new set by adding the {\PFAp item} to set {\PFAp m}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is in {\PFAp m}, its value will be replaced. \vspace{0.1 cm} \\ The serialization format for keys of sets is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.remove}{\hypertarget{map.remove}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.remove":$\!$ [m, key]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc key \rm & string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map by removing {\PFAp key} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If {\PFAp key} is not in {\PFAp m}, the return value is simply {\PFAp m}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.only}{\hypertarget{map.only}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.only":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping only {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.except}{\hypertarget{map.except}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.except":$\!$ [m, keys]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc keys \rm & array of string \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map, keeping all but {\PFAp keys} from {\PFAp m}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ If some {\PFAp keys} are not in {\PFAp m}, they are ignored and do not appear in the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.update}{\hypertarget{map.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.update":$\!$ [base, overlay]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc base \rm & map of any {\PFAtp A} \\  & \PFAc overlay \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return a new map with key-value pairs from {\PFAp overlay} in place of or in addition to key-value pairs from {\PFAp base}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Note: {\PFAp m} is not changed in-place; this is a side-effect-free function. \vspace{0.1 cm} \\ Keys of {\PFAp overlay} that are not in {\PFAp base} are added to those in {\PFAp base} and keys of {\PFAp overlay} that are in {\PFAp base} supersede those in {\PFAp base}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.split}{\hypertarget{map.split}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.split":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Split the map into an array of maps, each containing only one key-value pair (in no particular order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.join}{\hypertarget{map.join}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.join":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of map of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Join an array of maps into one map, overlaying from left to right. \vspace{0.2 cm} \\ }}%
    {map.argmax}{\hypertarget{map.argmax}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmax":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the highest value in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26120:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argmin}{\hypertarget{map.argmin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmin":$\!$ [m]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the lowest value in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26130:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argmaxLT}{\hypertarget{map.argmaxLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxLT":$\!$ [m, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the highest value in {\PFAp m} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26140:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argminLT}{\hypertarget{map.argminLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminLT":$\!$ [m, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the key of the lowest value in {\PFAp m} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26150:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argmaxN}{\hypertarget{map.argmaxN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxN":$\!$ [m, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26160:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26161:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argminN}{\hypertarget{map.argminN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminN":$\!$ [m, n]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} lowest values in {\PFAp m} (as defined by Avro's sort order). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26170:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26171:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argmaxNLT}{\hypertarget{map.argmaxNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argmaxNLT":$\!$ [m, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26180:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26181:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.argminNLT}{\hypertarget{map.argminNLT}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.argminNLT":$\!$ [m, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the keys of the {\PFAp n} highest values in {\PFAp a} as defined by the {\PFAp lessThan} function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If any values are not unique, their keys will be returned in lexicographic order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26190:} If {\PFAp m} is empty, an ``empty map'' runtime error is raised. \vspace{0.1 cm} \\ {\bf \#26191:} If {\PFAp n} is negative, an ``n < 0'' runtime error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.toset}{\hypertarget{map.toset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.toset":$\!$ [a]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & array of any {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an array of objects into a set of objects, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.fromset}{\hypertarget{map.fromset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.fromset":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a set of objects into an array of objects (in no particular order), where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only values, not keys. \vspace{0.1 cm} \\ {\bf Nondeterministic: unordered.} This function gives the same set of values every time it is executed on all systems, but the values may have a different order.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.in}{\hypertarget{map.in}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.in":$\!$ [s, x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & map of any {\PFAtp A} \\  & \PFAc x \rm & {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is contained in set {\PFAp s}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.union}{\hypertarget{map.union}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.union":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the union of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.intersection}{\hypertarget{map.intersection}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.intersection":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the intersection of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.diff}{\hypertarget{map.diff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.diff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.symdiff}{\hypertarget{map.symdiff}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.symdiff":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the difference of sets {\PFAp a} and {\PFAp b}, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.subset}{\hypertarget{map.subset}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.subset":$\!$ [little, big]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc little \rm & map of any {\PFAtp A} \\  & \PFAc big \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp little} is a subset of set {\PFAp big}, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.disjoint}{\hypertarget{map.disjoint}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.disjoint":$\!$ [a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of {\PFAtp A} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if set {\PFAp a} and set {\PFAp b} are disjoint, {\PFAc false} otherwise, where a set is represented as a map from serialized objects to objects. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The serialization format is base64-encoded Avro. \vspace{0.1 cm} \\ This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.map}{\hypertarget{map.map}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.map":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.mapWithKey}{\hypertarget{map.mapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.mapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key, value pair of {\PFAp m} and return a map of transformed values (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value. \vspace{0.1 cm} \\ To transform both keys and values, consider applying {\PFAf \hyperlink{map.split}{map.split}}, {\PFAf \hyperlink{a.map}{a.map}}, then {\PFAf \hyperlink{map.join}{map.join}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filter}{\hypertarget{map.filter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filter":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filterWithKey}{\hypertarget{map.filterWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & map of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the values for which {\PFAp fcn} returns {\PFAc true} (keys are unchanged). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filterMap}{\hypertarget{map.filterMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMap":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.filterMapWithKey}{\hypertarget{map.filterMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.filterMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ union of \{any {\PFAtp B}, null\} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of the results that are not {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.flatMap}{\hypertarget{map.flatMap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.flatMap":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function ({\PFAtp A}) $\to$ map of any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each value of {\PFAp m} and return a map of overlaid results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.flatMapWithKey}{\hypertarget{map.flatMapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.flatMapWithKey":$\!$ [m, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc m \rm & map of any {\PFAtp A} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}) $\to$ map of any {\PFAtp B} \\  & {\it (returns)} & map of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to each key-value pair of {\PFAp m} and return a map of overlaid results. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The order in which {\PFAp fcn} is called on items in {\PFAp m} is not guaranteed, though it will be called exactly once for each value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.zipmap}{\hypertarget{map.zipmap}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.zipmap":$\!$ [a, b, fcn]\} \rm or \PFAc \{"map.zipmap":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"map.zipmap":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc d \rm & map of any {\PFAtp D} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26370:} Raises a ``misaligned maps'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same keys.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.zipmapWithKey}{\hypertarget{map.zipmapWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"map.zipmapWithKey":$\!$ [a, b, fcn]\} \rm or \PFAc \{"map.zipmapWithKey":$\!$ [a, b, c, fcn]\} \rm or \PFAc \{"map.zipmapWithKey":$\!$ [a, b, c, d, fcn]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc c \rm & map of any {\PFAtp C} \\  & \PFAc d \rm & map of any {\PFAtp D} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}, {\PFAtp C}, {\PFAtp D}) $\to$ any {\PFAtp Z} \\ & {\it (returns)} & map of {\PFAtp Z} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp fcn} to the keys and elements of {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} in lock-step and return a result for row. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#26380:} Raises a ``misaligned maps'' error if {\PFAp a}, {\PFAp b}, {\PFAp c}, {\PFAp d} do not all have the same keys.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.corresponds}{\hypertarget{map.corresponds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.corresponds":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all pairs of values, one from {\PFAp a} and the other from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {map.correspondsWithKey}{\hypertarget{map.correspondsWithKey}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"map.correspondsWithKey":$\!$ [a, b, fcn]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc a \rm & map of any {\PFAtp A} \\  & \PFAc b \rm & map of any {\PFAtp B} \\  & \PFAc fcn \rm & function (string, {\PFAtp A}, {\PFAtp B}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp fcn} is {\PFAc true} when applied to all triples of key, value from {\PFAp a}, value from {\PFAp b} (logical relation). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The number of {\PFAp fcn} calls is not guaranteed. \vspace{0.1 cm} \\ If the key sets of {\PFAp a} and {\PFAp b} are not equal, this function returns {\PFAc false}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.len}{\hypertarget{bytes.len}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.len":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the length of byte array {\PFAp x}. \vspace{0.2 cm} \\ }}%
    {bytes.subseq}{\hypertarget{bytes.subseq}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseq":$\!$ [x, start, end]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the subsequence of {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.subseqto}{\hypertarget{bytes.subseqto}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.subseqto":$\!$ [x, start, end, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & \PFAc start \rm & int \\  & \PFAc end \rm & int \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAp x} from {\PFAp start} (inclusive) until {\PFAp end} (exclusive) with {\PFAp replacement}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and {\PFAp end} $\leq$ {\PFAp start} specifies a zero-length subsequence just before the {\PFAp start} character.  All of these rules follow Python's slice behavior.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.isAscii}{\hypertarget{bytes.isAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isAscii":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid ASCII; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.isLatin1}{\hypertarget{bytes.isLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isLatin1":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid latin-1 (ISO-8859-1); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.isUtf8}{\hypertarget{bytes.isUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf8":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-8; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16}{\hypertarget{bytes.isUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid utf-16 (byte order identified by optional byte-order mark); {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16be}{\hypertarget{bytes.isUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16be":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid big endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.isUtf16le}{\hypertarget{bytes.isUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"bytes.isUtf16le":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if {\PFAp x} is valid little endian utf-16; {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {bytes.decodeAscii}{\hypertarget{bytes.decodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeAscii":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as an ASCII string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16090:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeLatin1}{\hypertarget{bytes.decodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeLatin1":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a latin-1 (ISO-8859-1) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16100:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf8}{\hypertarget{bytes.decodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf8":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-8 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16110:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16}{\hypertarget{bytes.decodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a utf-16 (byte order identified by optional byte-order mark) string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16120:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16be}{\hypertarget{bytes.decodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16be":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a big endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16130:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.decodeUtf16le}{\hypertarget{bytes.decodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.decodeUtf16le":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Decode a bytes object as a little endian utf-16 string. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16140:} Raises an ``invalid bytes'' error if the bytes cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeAscii}{\hypertarget{bytes.encodeAscii}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeAscii":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as ASCII bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16150:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeLatin1}{\hypertarget{bytes.encodeLatin1}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeLatin1":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as latin-1 (ISO-8859-1) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16160:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf8}{\hypertarget{bytes.encodeUtf8}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf8":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-8 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16170:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16}{\hypertarget{bytes.encodeUtf16}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as utf-16 (byte order identified by optional byte-order mark) bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16180:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16be}{\hypertarget{bytes.encodeUtf16be}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16be":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as big endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16190:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.encodeUtf16le}{\hypertarget{bytes.encodeUtf16le}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.encodeUtf16le":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Encode a string as little endian utf-16 bytes. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16200:} Raises an ``invalid string'' error if the string cannot be converted.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {bytes.toBase64}{\hypertarget{bytes.toBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.toBase64":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & bytes \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert an arbitrary bytes object to a base64-encoded string. \vspace{0.2 cm} \\ }}%
    {bytes.fromBase64}{\hypertarget{bytes.fromBase64}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"bytes.fromBase64":$\!$ [s]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc s \rm & string \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert a base64-encoded string to a bytes object. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#16220:} Raises an ``invalid base64'' error if the string is not valid base64.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {fixed.toBytes}{\hypertarget{fixed.toBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.toBytes":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any fixed {\PFAtp A} \\  & {\it (returns)} & bytes \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Convert fixed-length, named bytes into arbitrary-length, anonymous bytes. \vspace{0.2 cm} \\ }}%
    {fixed.fromBytes}{\hypertarget{fixed.fromBytes}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"fixed.fromBytes":$\!$ [original, replacement]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc original \rm & any fixed {\PFAtp A} \\  & \PFAc replacement \rm & bytes \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Overlay {\PFAp replacement} on top of {\PFAp original}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp replacement} is shorter than {\PFAp original}, the bytes beyond {\PFAp replacement}'s length are taken from {\PFAp original}. \vspace{0.1 cm} \\ If {\PFAp replacement} is longer than {\PFAp original}, the excess bytes are truncated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {enum.toString}{\hypertarget{enum.toString}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toString":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & string \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the string representation of an enum. \vspace{0.2 cm} \\ }}%
    {enum.toInt}{\hypertarget{enum.toInt}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.toInt":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the integer representation of an enum. \vspace{0.2 cm} \\ }}%
    {enum.numSymbols}{\hypertarget{enum.numSymbols}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"enum.numSymbols":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any enum {\PFAtp A} \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the number of symbols associated with this enum (a constant). \vspace{0.2 cm} \\ }}%
    {time.year}{\hypertarget{time.year}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.year":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the four-digit year that the timestamp falls within. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40000:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40001:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.monthOfYear}{\hypertarget{time.monthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.monthOfYear":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the month that the timestamp falls within, with 1 being January and 12 being December. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40010:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40011:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.dayOfYear}{\hypertarget{time.dayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfYear":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the year that the timestamp falls within, from 1 to 365 or 366 inclusive, depending on leap year. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40020:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40021:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.dayOfMonth}{\hypertarget{time.dayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfMonth":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the month that the timestamp falls within, a number from 1 to 28, 29, 30, or 31, inclusive, depending on month. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40030:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40031:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.dayOfWeek}{\hypertarget{time.dayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.dayOfWeek":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the day of the week that the timestamp falls within, with 0 being Monday and 6 being Sunday. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40040:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40041:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.hourOfDay}{\hypertarget{time.hourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.hourOfDay":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the hour of the day that the timestamp falls within, from 0 to 23 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40050:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40051:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.minuteOfHour}{\hypertarget{time.minuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.minuteOfHour":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the minute of the hour that the timestamp falls within, from 0 to 59 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40060:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40061:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.secondOfMinute}{\hypertarget{time.secondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.secondOfMinute":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Get the second of the minute that the timestamp falls within, from 0 to 59 inclusive. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40070:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40071:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.makeTimestamp}{\hypertarget{time.makeTimestamp}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.makeTimestamp":$\!$ [year, month, day, hour, minute, second, millisecond, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc year \rm & int \\  & \PFAc month \rm & int \\  & \PFAc day \rm & int \\  & \PFAc hour \rm & int \\  & \PFAc minute \rm & int \\  & \PFAc second \rm & int \\  & \PFAc millisecond \rm & int \\  & \PFAc zone \rm & string \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Given the date and time that this time occurs in, return the timestamp. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc year \rm & The four-digit year, from 1 to 9999 inclusive.  \\  & \PFAc month \rm & The month of the year, from 1 to 12 inclusive.  \\  & \PFAc day \rm & The day of the month, from 1 to 28, 29, 30, or 31 inclusive, depending on month.  \\  & \PFAc hour \rm & The hour of the day, from 0 to 23 inclusive.  \\  & \PFAc minute \rm & The minute of the hour, from 0 to 59 inclusive.  \\  & \PFAc second \rm & The second of the minute, from 0 to 59 inclusive.  \\  & \PFAc millisecond \rm & The millisecond of the second, from 0 to 999 inclusive.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & {\it (return value)} \rm & The number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40080:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40081:} Raises ``timestamp undefined for given parameters'' if any one (or more) of the inputs have impossible values.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isSecondOfMinute}{\hypertarget{time.isSecondOfMinute}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isSecondOfMinute":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of seconds in any minute. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of seconds (inclusive).  \\  & \PFAc high \rm & Maximum number of seconds (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40090:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40091:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40092:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isMinuteOfHour}{\hypertarget{time.isMinuteOfHour}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMinuteOfHour":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of minutes in any hour. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of minutes (inclusive)  \\  & \PFAc high \rm & Maximum number of minutes (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40100:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40101:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40102:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isHourOfDay}{\hypertarget{time.isHourOfDay}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isHourOfDay":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified number of hours in any day. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum number of hours (inclusive).  \\  & \PFAc high \rm & Maximum number of hours (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40110:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40111:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40112:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isDayOfWeek}{\hypertarget{time.isDayOfWeek}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfWeek":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of week range, with 0 being Monday and 6 being Sunday. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of the week (inclusive).  \\  & \PFAc high \rm & Maximum day of the week (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40120:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40121:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40122:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isDayOfMonth}{\hypertarget{time.isDayOfMonth}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfMonth":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of month range, with 1 being the first of the month.. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of the month (inclusive).  \\  & \PFAc high \rm & Maximum day of the month (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40130:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40131:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40132:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isMonthOfYear}{\hypertarget{time.isMonthOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isMonthOfYear":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified month of year range, with 1 being January and 12 being December. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum month of the year (inclusive).  \\  & \PFAc high \rm & Maximum month of the year (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40140:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40141:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40142:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isDayOfYear}{\hypertarget{time.isDayOfYear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isDayOfYear":$\!$ [ts, zone, low, high]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determines if a timestamp falls within a specified day of year range, with 1 being the first of the year. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\  & \PFAc low \rm & Minimum day of year (inclusive).  \\  & \PFAc high \rm & Maximum day of year (exclusive).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40150:} Raises ``bad time range'' if low $\mathrm{low} \geq \mathrm{high}$. \vspace{0.1 cm} \\ {\bf \#40151:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40152:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isWeekend}{\hypertarget{time.isWeekend}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWeekend":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if the timestamp falls on a Saturday or Sunday, {\PFAc false} otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40160:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40161:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {time.isWorkHours}{\hypertarget{time.isWorkHours}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"time.isWorkHours":$\!$ [ts, zone]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc ts \rm & double \\  & \PFAc zone \rm & string \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Returns {\PFAc true} if the timestamp falls between 9 am (inclusive) and 5 pm (exclusive) on Monday through Friday, otherwise {\PFAc false}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc ts \rm & Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.  \\  & \PFAc zone \rm & Timezone name from the Olson timezone database, version 2015f (UTC if blank).  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#40170:} Raises ``unrecognized timezone string'' if {\PFAp zone} is not in the Olson 2015f database. \vspace{0.1 cm} \\ {\bf \#40171:} Raises ``timestamp out of range'' if {\PFAp ts} less than -62135596800 or greater than 253402300799.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.errorOnNull}{\hypertarget{impute.errorOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.errorOnNull":$\!$ [x]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Skip an action by raising a runtime error when {\PFAp x} is {\PFAc null}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#21000:} Raises an ``encountered null'' error if {\PFAp x} is {\PFAc null}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.defaultOnNull}{\hypertarget{impute.defaultOnNull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"impute.defaultOnNull":$\!$ [x, default]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & union of \{any {\PFAtp A}, null\} \\  & \PFAc default \rm & {\PFAtp A} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Replace {\PFAc null} values in {\PFAp x} with {\PFAp default}. \vspace{0.2 cm} \\ }}%
    {impute.isnan}{\hypertarget{impute.isnan}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnan":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is {\PFAc nan}, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {impute.isinf}{\hypertarget{impute.isinf}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isinf":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is positive or negative infinity, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {impute.isnum}{\hypertarget{impute.isnum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.isnum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return {\PFAc true} if {\PFAp x} is neither {\PFAc nan} nor infinite, {\PFAc false} otherwise. \vspace{0.2 cm} \\ }}%
    {impute.errorOnNonNum}{\hypertarget{impute.errorOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.errorOnNonNum":$\!$ [x]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, but raise an error otherwise. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#21050:} Raises an ``encountered nan'' if {\PFAp x} is {\PFAc nan}. \vspace{0.1 cm} \\ {\bf \#21051:} Raises an ``encountered +inf'' if {\PFAp x} is positive infinity. \vspace{0.1 cm} \\ {\bf \#21052:} Raises an ``encountered -inf'' if {\PFAp x} is negative infinity.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {impute.defaultOnNonNum}{\hypertarget{impute.defaultOnNonNum}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"impute.defaultOnNonNum":$\!$ [x, default]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & float \\  & \PFAc default \rm & float \\ & {\it (returns)} & float \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc default \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Pass through {\PFAp x} if it is neither {\PFAc nan} nor infinite, and return {\PFAp default} otherwise. \vspace{0.2 cm} \\ }}%
    {interp.bin}{\hypertarget{interp.bin}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.bin":$\!$ [x, numbins, low, high]\} \rm or \PFAc \{"interp.bin":$\!$ [x, origin, width]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc numbins \rm & int \\  & \PFAc low \rm & double \\  & \PFAc high \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc origin \rm & double \\  & \PFAc width \rm & double \\ & {\it (returns)} & int \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the bin that contains {\PFAp x}, declared either as {\PFAp numbins} between two endpoints or a bin {\PFAp width} starting at some {\PFAp origin}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Bins are inclusive on the low end and exclusive on the high end, so if {\PFAp x} equal {\PFAp low} or {\PFAp origin}, the resulting bin is {\PFAc 0}, but if {\PFAp x} is equal to {\PFAp high}, it is out of range. \vspace{0.1 cm} \\ If the first signature is used, the resulting bin must be between {\PFAc 0} (inclusive) and {\PFAp numbins} (exclusive). If the second signature is used, the resulting bin may be any integer, including negative numbers.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22000:} If {\PFAp low} is greater or equal to {\PFAp high} or {\PFAp origin} is not finite, raises ``bad histogram range'' \vspace{0.1 cm} \\ {\bf \#22001:} If {\PFAp numbins} is less than {\PFAc 1} or {\PFAp width} is less or equal to {\PFAc 0}, raises ``bad histogram scale'' \vspace{0.1 cm} \\ {\bf \#22002:} Raises ``x out of range'' if {\PFAp x} is less than {\PFAp low} or greater or equal to {\PFAp high}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.nearest}{\hypertarget{interp.nearest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.nearest":$\!$ [x, table]\} \rm or \PFAc \{"interp.nearest":$\!$ [x, table, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ any {\PFAtp T}\} \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp X1} \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ any {\PFAtp X2}, {\PFApf to:}$\!$ any {\PFAtp T}\} \\  & \PFAc metric \rm & function ({\PFAtp X1}, {\PFAtp X2}) $\to$ double \\ & {\it (returns)} & {\PFAtp T} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} value in the {\PFAp table} to the input {\PFAp x} and returns the corresponding {\PFApf to} value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22010:} Raises a ``table must have at least one entry'' error if {\PFAp table} has fewer than one entry. \vspace{0.1 cm} \\ {\bf \#22011:} Raises an ``inconsistent dimensionality'' error if any input {\PFAp x} and record {\PFApf x} have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linear}{\hypertarget{interp.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linear":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Finds the closest {\PFApf x} values in the {\PFAp table} that are below and above the input {\PFAp x} and linearly projects their {\PFApf to} values to the input {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22020:} Raises a ``table must have at least two distinct x values'' error if fewer than two of the {\PFAp table} {\PFApf x} entries are unique. \vspace{0.1 cm} \\ {\bf \#22021:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linearFlat}{\hypertarget{interp.linearFlat}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearFlat":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns the closest entry's {\PFApf to} if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22030:} Raises a ``table must have at least two distinct x values'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ {\bf \#22031:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {interp.linearMissing}{\hypertarget{interp.linearMissing}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"interp.linearMissing":$\!$ [x, table]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\ & {\it (returns)} & union of \{null, double\} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\ & {\it (returns)} & union of \{null, array of double\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Like {\PFAf \hyperlink{interp.linear}{interp.linear}}, but returns a missing value ({\PFAc null}) if the input {\PFAp x} is beyond the {\PFAp table}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Any ties in distance are resolved in favor of the first instance in the {\PFAp table}. \vspace{0.1 cm} \\ If the {\PFApf to} values are arrays, each component will be interpolated.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#22040:} Raises a ``table must have at least two distinct x values'' error if {\PFAp table} has fewer than two entries. \vspace{0.1 cm} \\ {\bf \#22041:} Raises an ``inconsistent dimensionality'' error if the {\PFApf to} values of the two closest entries have different numbers of dimensions.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gaussianLL}{\hypertarget{prob.dist.gaussianLL}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianLL":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianLL":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the log-likelihood of a Gaussian (normal) distribution parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the log-likelihood.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $-(x - \mu)^2/(2 \sigma^2) - \log(\sigma \sqrt{2\pi})$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13000:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13001:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gaussianCDF}{\hypertarget{prob.dist.gaussianCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianCDF":$\!$ [x, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianCDF":$\!$ [x, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the cumultive distribution function (CDF) for the normal distribution, parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $0.5 * ( 1.0 + \mathrm{Erf}(\frac{x - \mu}{\sigma \sqrt{2}}))$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13010:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13011:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gaussianQF}{\hypertarget{prob.dist.gaussianQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"prob.dist.gaussianQF":$\!$ [p, mu, sigma]\} \rm or \PFAc \{"prob.dist.gaussianQF":$\!$ [p, params]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc mu \rm & double \\  & \PFAc sigma \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc params \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the normal quantile (QF, the inverse of the CDF) parameterized by {\PFAp mu} and {\PFAp sigma} or a record {\PFAp params}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Probability at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc mu \rm & Centroid of the distribution (same as {\PFApf mean}).  \\  & \PFAc sigma \rm & Width of the distribution (same as the square root of {\PFApf variance}).  \\  & \PFAc params \rm & Alternate way of specifying the parameters of the distribution; this record could be created by {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & With $\mu$ = {\PFAp mu} or {\PFApf mean} and $\sigma$ = {\PFAp sigma} or the square root of {\PFApf variance}, this function returns $\mu + \sigma \sqrt{2} \mathrm{Erf}^{-1} (2p - 1)$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13020:} Raises an ``invalid parameterization'' error if {\PFAp sigma} or {\PFApf variance} is negative or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13021:} Raises an ``invalid input'' error if {\PFAp p} is less than zero or greater than one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialPDF}{\hypertarget{prob.dist.exponentialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialPDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\lambda \mathrm{e}^{- \lambda x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13030:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13031:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialCDF}{\hypertarget{prob.dist.exponentialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialCDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13040:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13041:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.exponentialQF}{\hypertarget{prob.dist.exponentialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.exponentialQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the exponential distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Rate parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13050:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13051:} Raises an ``invalid input'' error if {\PFAp p} is less than zero or greater than one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2PDF}{\hypertarget{prob.dist.chi2PDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2PDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{2^{\frac{\mathrm{df}}{2}} \Gamma(\frac{\mathrm{df}}{2})} x^{\frac{\mathrm{df}}{2}-1}\mathrm{e}^{-\frac{x}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13060:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13061:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2CDF}{\hypertarget{prob.dist.chi2CDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2CDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13070:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13071:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.chi2QF}{\hypertarget{prob.dist.chi2QF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.chi2QF":$\!$ [p, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the Chi-squared distribution parameterized by its degrees of freedom {\PFAp dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $x1$, $x1$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13080:} Raises ``invalid parameterization'' if {\PFAp dof} < 0 or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13081:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonPDF}{\hypertarget{prob.dist.poissonPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonPDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\lambda^{x}}{x!} \mathrm{e}^{-\lambda}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13090:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonCDF}{\hypertarget{prob.dist.poissonCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonCDF":$\!$ [x, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13100:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13101:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.poissonQF}{\hypertarget{prob.dist.poissonQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.poissonQF":$\!$ [p, lambda]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc lambda \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the poisson distribution parameterized by {\PFAp lambda}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc lambda \rm & Mean and variance parameter.  \\  & {\it (return value)} \rm & With $lambda$, $lambda$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13110:} Raises ``invalid parameterization'' if $lambda < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13111:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaPDF}{\hypertarget{prob.dist.gammaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{s^{a} \Gamma(a)} x^{a - 1} \mathrm{e}^{-\frac{x}{s}}  $. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13120:} Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13121:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaCDF}{\hypertarget{prob.dist.gammaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x)~= P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13130:} Raises ``invalid parameterization'' if the $shape < 0$ OR if $scale < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13131:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.gammaQF}{\hypertarget{prob.dist.gammaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.gammaQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the gamma distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13140:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13141:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.betaPDF}{\hypertarget{prob.dist.betaPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaPDF":$\!$ [x, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF, defined between zero and one.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(a + n)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13150:} Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13151:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.betaCDF}{\hypertarget{prob.dist.betaCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaCDF":$\!$ [x, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13160:} Raises ``invalid parameterization'' if $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13161:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.betaQF}{\hypertarget{prob.dist.betaQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.betaQF":$\!$ [p, a, b]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc a \rm & double \\  & \PFAc b \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the beta distribution parameterized by {\PFAp shape1} and {\PFAp shape2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc a \rm & First shape parameter.  \\  & \PFAc b \rm & Second shape parameter.  \\  & {\it (return value)} \rm & With $a$, $b$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13170:} Raises ``invalid parameterization'' if the $a \leq 0$ OR if $b \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13171:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyPDF}{\hypertarget{prob.dist.cauchyPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyPDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc location \rm & Location parameter (l).  \\  & \PFAc scale \rm & Scale parameter (s).  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{(\pi s (1 + (\frac{x - l}{s})^{2})) }$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13180:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13181:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyCDF}{\hypertarget{prob.dist.cauchyCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyCDF":$\!$ [x, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13190:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13191:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.cauchyQF}{\hypertarget{prob.dist.cauchyQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.cauchyQF":$\!$ [p, location, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc location \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the cauchy distribution parameterized by {\PFAp location} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc location \rm & Location parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $location$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13200:} Raises ``invalid parameterization'' if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13201:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fPDF}{\hypertarget{prob.dist.fPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fPDF":$\!$ [x, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{d1 + d2}{2})}{\Gamma(\frac{d1}{2})\Gamma(\frac{d2}{2})} \frac{d1}{d2}^{\frac{d1}{2}-1}(1 + \frac{d1}{d2} x)^{-\frac{d1 + d2}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13210:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13211:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fCDF}{\hypertarget{prob.dist.fCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fCDF":$\!$ [x, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13220:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13221:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.fQF}{\hypertarget{prob.dist.fQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.fQF":$\!$ [p, d1, d2]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc d1 \rm & int \\  & \PFAc d2 \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the F distribution parameterized by {\PFAp d1} and {\PFAp d2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc d1 \rm & Numerator degrees of freedom parameter.  \\  & \PFAc d2 \rm & Denominator degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $d1$, $d2$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13230:} Raises ``invalid parameterization'' if the $d1 \leq 0$ OR if $d2 \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13231:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalPDF}{\hypertarget{prob.dist.lognormalPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalPDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale ($\mu$).  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale ($\sigma$).  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\sqrt{2 \pi} \sigma x} \mathrm{e}^{-\frac{\mathrm{log}(x) - \mu}{2 \sigma^{2}}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13240:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13241:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalCDF}{\hypertarget{prob.dist.lognormalCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalCDF":$\!$ [x, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13250:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13251:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.lognormalQF}{\hypertarget{prob.dist.lognormalQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.lognormalQF":$\!$ [p, meanlog, sdlog]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc meanlog \rm & double \\  & \PFAc sdlog \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the lognormal distribution parameterized by {\PFAp meanlog} and {\PFAp sdlog}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc meanlog \rm & Mean of the distribution on the log scale.  \\  & \PFAc sdlog \rm & Standard deviation of the distribution on the log scale.  \\  & {\it (return value)} \rm & With $meanlog$, $sdlog$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13260:} Raises ``invalid parameterization'' if $sdlog \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13261:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tPDF}{\hypertarget{prob.dist.tPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tPDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(\frac{\mathrm{df}+1}{2})}{\sqrt{\mathrm{df}\pi} \Gamma{\frac{\mathrm{df}}{2}}}(1 + x^{\frac{2}{n}})^{-\frac{\mathrm{df} + 1}{2}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13270:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13271:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tCDF}{\hypertarget{prob.dist.tCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tCDF":$\!$ [x, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13280:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13281:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.tQF}{\hypertarget{prob.dist.tQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.tQF":$\!$ [p, dof]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc dof \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the student's t distribution parameterized by {\PFAp dof} and {\PFAp x2}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc dof \rm & Degrees of freedom parameter.  \\  & {\it (return value)} \rm & With $dof$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13290:} Raises ``invalid parameterization'' if $df \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13291:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialPDF}{\hypertarget{prob.dist.binomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc size \rm & The number of trials (n).  \\  & \PFAc prob \rm & The probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\mathrm{choose}(n, x) p^{x} (1 - p)^{n - x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13300:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13301:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialCDF}{\hypertarget{prob.dist.binomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13310:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13311:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.binomialQF}{\hypertarget{prob.dist.binomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.binomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & The number of trials.  \\  & \PFAc prob \rm & The probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13320:} Raises ``invalid parameterization'' if $size < 0$ OR if $prob < 0$ OR if $prob > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13321:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformPDF}{\hypertarget{prob.dist.uniformPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformPDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{1}{\mathrm{max} - \mathrm{min}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13330:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13331:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformCDF}{\hypertarget{prob.dist.uniformCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformCDF":$\!$ [x, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13340:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13341:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.uniformQF}{\hypertarget{prob.dist.uniformQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.uniformQF":$\!$ [p, min, max]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc min \rm & double \\  & \PFAc max \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the uniform distribution parameterized by {\PFAp min} and {\PFAp max}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc min \rm & Lower bound.  \\  & \PFAc max \rm & Upper bound.  \\  & {\it (return value)} \rm & With $min$, $max$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13350:} Raises ``invalid parameterization'' if $min \geq max$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13351:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricPDF}{\hypertarget{prob.dist.geometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricPDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc prob \rm & Probability of success of each trial (p).  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $p (1 - p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13360:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13361:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricCDF}{\hypertarget{prob.dist.geometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricCDF":$\!$ [x, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13370:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13371:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.geometricQF}{\hypertarget{prob.dist.geometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.geometricQF":$\!$ [p, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the geometric distribution parameterized by {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc prob \rm & Probability of success of each trial.  \\  & {\it (return value)} \rm & With $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13380:} Raises ``invalid parameterization'' if $\mathrm{prob} \leq 0$ OR if $\mathrm{prob} > 1$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13381:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricPDF}{\hypertarget{prob.dist.hypergeometricPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricPDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement from the urn.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\mathrm{choose}(m, x) \mathrm{choose}(n, k-x)}{\mathrm{choose}(m+n, k)} $.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13390:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricCDF}{\hypertarget{prob.dist.hypergeometricCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricCDF":$\!$ [x, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & The number of white balls drawn without replacement.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13400:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$. \vspace{0.1 cm} \\ {\bf \#13401:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.hypergeometricQF}{\hypertarget{prob.dist.hypergeometricQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.hypergeometricQF":$\!$ [p, m, n, k]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc m \rm & int \\  & \PFAc n \rm & int \\  & \PFAc k \rm & int \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the hypergeometric distribution parameterized by {\PFAp m}, {\PFAp n} and {\PFAp k}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc m \rm & The number of white balls in the urn.  \\  & \PFAc n \rm & The number of black balls in the urn.  \\  & \PFAc k \rm & The number of balls drawn from the urn.  \\  & {\it (return value)} \rm & With $m$, $n$ and $k$ at $p$, this function returns the value $x$ such that $F_{X}(x)~:= P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13410:} Raises ``invalid parameterization'' if $\mathrm{m} + \mathrm{n} < \mathrm{k}$, $m < 0$, $n < 0$, $m + n = 0$, or $k < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13411:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullPDF}{\hypertarget{prob.dist.weibullPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullPDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF.  \\  & \PFAc shape \rm & Shape parameter (a).  \\  & \PFAc scale \rm & Scale parameter (b).  \\  & {\it (return value)} \rm & With $shape$, $scale$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{a}{b}(\frac{x}{b})^{a - 1}\mathrm{e}^{-(\frac{x}{b})^{a}}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13420:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13421:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullCDF}{\hypertarget{prob.dist.weibullCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullCDF":$\!$ [x, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X~\leq~x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13430:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13431:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.weibullQF}{\hypertarget{prob.dist.weibullQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.weibullQF":$\!$ [p, shape, scale]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc shape \rm & double \\  & \PFAc scale \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the weibull distribution parameterized by {\PFAp shape} and {\PFAp scale}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc shape \rm & Shape parameter.  \\  & \PFAc scale \rm & Scale parameter.  \\  & {\it (return value)} \rm & With $shape$, $scale$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X~\leq~x)~=~p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13440:} Raises ``invalid parameterization'' if the $shape \leq 0$ OR if $scale \leq 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13441:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialPDF}{\hypertarget{prob.dist.negativeBinomialPDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialPDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & int \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the density (PDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the PDF (integer) .  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials (n).  \\  & \PFAc prob \rm & Probability of success in each trial (p).  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function evaluates the probability density function at $x$.  The PDF implemented is $\frac{\Gamma(x+n)}{\Gamma(n) x!} p^{n} (1-p)^{x}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13450:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$ or if $size < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13451:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialCDF}{\hypertarget{prob.dist.negativeBinomialCDF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialCDF":$\!$ [x, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the distribution function (CDF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value at which to compute the CDF.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $x$, this function returns the value $p$ where $p = F_{X}(x) = P(X \leq x)$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13460:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$, or if $size < 0$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13461:} Raises ``invalid input'' if {\PFAp x} is not finite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {prob.dist.negativeBinomialQF}{\hypertarget{prob.dist.negativeBinomialQF}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"prob.dist.negativeBinomialQF":$\!$ [p, size, prob]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc p \rm & double \\  & \PFAc size \rm & int \\  & \PFAc prob \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compute the quantile function (QF) of the negative binomial distribution parameterized by {\PFAp size} and {\PFAp prob}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc p \rm & Value at which to compute the QF.  Must be a value between 0 and 1.  \\  & \PFAc size \rm & Size parameter (integer).  Target number of successful trials.  \\  & \PFAc prob \rm & Probability of success in each trial.  \\  & {\it (return value)} \rm & With $size$, $prob$ and $p$, this function returns the value $x$ such that $F_{X}(x) := P(X \leq x) = p$.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#13470:} Raises ``invalid parameterization'' if $\mathrm{prob} < 0$, if $\mathrm{prob} > 1$, or if $size \leq 0$, or if $size$ or any argument is not finite. \vspace{0.1 cm} \\ {\bf \#13471:} Raises ``invalid input'' if $p < 0$ OR if $p > 1$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.test.kolmogorov}{\hypertarget{stat.test.kolmogorov}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.kolmogorov":$\!$ [x, y]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc y \rm & array of double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare two datasets using the Kolmogorov-Smirnov test to determine if they might have been drawn from the same parent distribution. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & A bag of data.  \\  & \PFAc y \rm & Another bag of data.  \\  & {\it (return value)} \rm & Returns a value between 0.0 and 1.0 representing the cumulative probability that {\PFAp x} and {\PFAp y} were drawn from the same distribution: 1.0 indicates a perfect match. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If both datasets (ignoring NaN values) are empty, this function returns 1.0\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.test.residual}{\hypertarget{stat.test.residual}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.residual":$\!$ [observation, prediciton]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38010:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.test.pull}{\hypertarget{stat.test.pull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.pull":$\!$ [observation, prediciton, uncertainty]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\  & \PFAc uncertainty \rm & double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\  & \PFAc uncertainty \rm & array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\  & \PFAc uncertainty \rm & map of double \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & \PFAc uncertainty \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction} divided by {\PFAp uncertainty}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38020:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#38021:} Raises a ``misaligned uncertainty'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp uncertainty}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.test.mahalanobis}{\hypertarget{stat.test.mahalanobis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.mahalanobis":$\!$ [observation, prediction, covariance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediction \rm & array of double \\  & \PFAc covariance \rm & array of array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediction \rm & map of double \\  & \PFAc covariance \rm & map of map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Vector of observations $\vec{o}$.  \\  & \PFAc prediction \rm & Vector of predictions $\vec{p}$.  \\  & \PFAc covariance \rm & Matrix of covariance $C$.  \\  & {\it (return value)} \rm & Scalar result of a similarity transformation: $\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38030:} Raises a ``too few rows/cols'' error if {\PFAp observation} has fewer than one element. \vspace{0.1 cm} \\ {\bf \#38031:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes or keys as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#38032:} Raises a ``misaligned covariance'' error if {\PFAp covariance} does not have the same indexes or keys as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.test.updateChi2}{\hypertarget{stat.test.updateChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.test.updateChi2":$\!$ [pull, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & array of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & map of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a chi-square calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc pull \rm & Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.  \\  & \PFAc state \rm & Record of the previous {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {stat.test.reducedChi2}{\hypertarget{stat.test.reducedChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.reducedChi2":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the reduced chi-square, which is {\PFApf chi2}/{\PFApf dof}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {stat.test.chi2Prob}{\hypertarget{stat.test.chi2Prob}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.test.chi2Prob":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf dof:}$\!$ int\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the chi-square probability, which is the CDF of the chi-square function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf dof}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#38060:} Raises ``invalid parameterization'' if {\PFApf dof} is less than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.update}{\hypertarget{stat.sample.update}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.update":$\!$ [x, w, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}. \item[\PFAc mean:] The mean of {\PFAp x}, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current mean of all {\PFAp x}, and {\PFApf variance} updated to the current variance of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateCovariance}{\hypertarget{stat.sample.updateCovariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.updateCovariance":$\!$ [x, w, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ array of double, {\PFApf covariance:}$\!$ array of array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & map of double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ map of map of double, {\PFApf mean:}$\!$ map of double, {\PFApf covariance:}$\!$ map of map of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a covariance calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample vector, expressed as an array or map; must have at least two components.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Record of the previous {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}.                                           \begin{description*}\item[\PFAc count:] The sum of weights {\PFAp w}.  If {\PFAp x} is an array, then {\PFApf count} is a single value representing the sum of weights for all records seen so far.  If {\PFAp x} is a map, then {\PFApf count} is a matrix in which entry $i$, $j$ is the sum of weights for records in which key $i$ and key $j$ both appear in {\PFAp x}. \item[\PFAc mean:] The componentwise mean of {\PFAp x}, weighted by {\PFAp w}. \item[\PFAc covariance:] The covariance matrix of all pairs of components of {\PFAp x}, weighted by {\PFAp w}.  If {\PFAp x} is an array, this matrix is represented by a list of lists.  If {\PFAp x} is a map, this matrix is represented by a map of maps. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp state} with {\PFApf count} incremented by {\PFAp w}, {\PFApf mean} updated to the current componentwise mean of all {\PFAp x}, and {\PFApf covariance} updated to the current covariance matrix of all {\PFAp x}.  If the {\PFAp state} has fields other than {\PFApf count}, {\PFApf mean}, and {\PFApf covariance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, indexes of {\PFAp x} correspond to the same indexes of {\PFApf mean} and rows and columns of {\PFApf covariance}, where a row is an index of {\PFApf covariance} and a column is an index of an element of {\PFApf covariance}.  In the map signature, keys of {\PFAp x} correspond to the same keys of {\PFApf mean}, as well as rows and columns of {\PFApf count} and {\PFApf covariance}, where a row is a key of the object and a column is a key of a value of the object.  In the array signature, all arrays must have equal length (including the nested arrays within {\PFApf covariance}) and all components are updated with each call.  In the map signature, a previously unseen key in {\PFAp x} creates a new key in {\PFApf mean} with value {\PFAp x}, a new row and column in {\PFApf count} with value {\PFAp w} for all key pairs existing in {\PFAp x} and zero for key pairs not in {\PFAp x}, as well as a new row and column in {\PFApf covariance} filled with zeros. \vspace{0.1 cm} \\ In the map signature, missing keys in {\PFAp x} are equivalent to contributions with zero weight.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14011:} If {\PFAp x} has fewer than 2 components, a ``too few components'' error is raised. \vspace{0.1 cm} \\ {\bf \#14012:} If {\PFAp x}, {\PFApf mean}, and {\PFApf covariance} are arrays with unequal lengths, an ``unequal length arrays'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateWindow}{\hypertarget{stat.sample.updateWindow}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateWindow":$\!$ [x, w, state, windowSize]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc state \rm & array of any record {\PFAtp A} with \{{\PFApf x:}$\!$ double, {\PFApf w:}$\!$ double, {\PFApf count:}$\!$ double\} \\  & \PFAc windowSize \rm & int \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a counter, a counter and a mean, or a counter, mean, and variance, within a window of {\PFAp windowSize} recent samples. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc state \rm & Array of previous {\PFApf count}, {\PFApf mean}, and/or {\PFApf variance} and samples in the window.                                                                 \begin{description*}\item[\PFAc x:] Sample value, saved so that it can be removed from the running mean and variance when it goes out of scope. \item[\PFAc w:] Sample weight, saved for the same reason. \item[\PFAc count:] The sum of weights {\PFAp w} within the window. \item[\PFAc mean:] The mean of {\PFAp x} within the window, weighted by {\PFAp w}.  This field is optional, but if provided, it must be a {\PFAc double}. \item[\PFAc variance:] The variance of $x - \mbox{mean}$ within the window, weighted by {\PFAp w}.  This field is optional, but if it is provided, it must be a {\PFAc double}, and there must be a {\PFApf mean} as well.  No attempt is made to unbias the estimator, so multiply this by $\mbox{count}/(\mbox{count} - 1)$ to correct for the bias due to centering on the mean. \end{description*} \\  & \PFAc windowSize \rm & Size of the window.  When the length of {\PFAp state} is less than {\PFAp windowSize}, this function is equivalent to {\PFAf \hyperlink{stat.sample.update}{stat.sample.update}}.  \\  & {\it (return value)} \rm & If the length of {\PFAp state} is zero, this function returns a singleton array with {\PFApf count} = {\PFAp w}, {\PFApf mean} = {\PFAp x}, and/or {\PFApf variance} = 0.  If the length of {\PFAp state} is less than {\PFAp windowSize}, then it returns a copy of {\PFAp state} with the next record added.  Otherwise, it is trunctated to {\PFAp windowSize}, removing the old values from the running count/mean/variance.  In all cases, the {\PFAf \hyperlink{a.last}{a.last}} item is the latest result. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14020:} If {\PFAp windowSize} is less than 2, a ``windowSize must be at least 2'' error is raised. \vspace{0.1 cm} \\ {\bf \#14021:} If {\PFAp state} is empty and the record type has fields other than {\PFApf x}, {\PFApf w}, {\PFApf count}, {\PFApf mean}, and {\PFApf variance}, then a ``cannot initialize unrecognized fields'' error is raised.  Unrecognized fields are only allowed if an initial record is provided.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateEWMA}{\hypertarget{stat.sample.updateEWMA}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateEWMA":$\!$ [x, alpha, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of an exponentially weighted moving average (EWMA). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data; if {\PFAp alpha} is close to 0, the EWMA approaches a simple mean.  \\  & \PFAc state \rm & Record of the previous {\PFApf mean} and {\PFApf variance}.                                \begin{description*}\item[\PFAc mean:] The exponentially weighted mean of {\PFAp x}, weighted by {\PFAp alpha}. \item[\PFAc variance:] The exponentially weighted variance of {\PFAp x}, weighted by {\PFAp alpha}.  This field is optional, but if provided, it must be a {\PFAc double}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated {\PFApf mean} and {\PFApf variance}.  If the input {\PFAp state} has fields other than {\PFApf mean} and {\PFApf variance}, they are copied unaltered to the output state. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14030:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateHoltWinters}{\hypertarget{stat.sample.updateHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWinters":$\!$ [x, alpha, beta, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level} and {\PFApf trend}.                                \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$ and $b_t$ = the {\PFApf trend} at a time $t$, $a_t = \alpha x + (1 - \alpha)(a_{t-1} + b_{t-1})$ and $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14040:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14041:} If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.updateHoltWintersPeriodic}{\hypertarget{stat.sample.updateHoltWintersPeriodic}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.updateHoltWintersPeriodic":$\!$ [x, alpha, beta, gamma, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc alpha \rm & double \\  & \PFAc beta \rm & double \\  & \PFAc gamma \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double, {\PFApf cycle:}$\!$ array of double, {\PFApf multiplicative:}$\!$ boolean\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a time series analysis with an exponentially weighted periodic-plus-linear fit. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc alpha \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf level}.  If {\PFAp alpha} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc beta \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf trend}.  If {\PFAp beta} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc gamma \rm & Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the {\PFApf cycle}.  If {\PFAp gamma} is close to 1, recent data are heavily weighted at the expense of old data.  \\  & \PFAc state \rm & Record of the previous {\PFApf level}, {\PFApf trend}, and {\PFApf cycle}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data, weighted by {\PFAp alpha}. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data, weighted by {\PFAp beta}. \item[\PFAc cycle:] The history of the previous cycle, weighted by {\PFAp gamma}.  If the length of this array is $L$, then the built-in period is $L$ time steps long. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of the {\PFAp state}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}Use {\PFAf \hyperlink{stat.sample.forecast1HoltWinters}{stat.sample.forecast1HoltWinters}} or {\PFAf \hyperlink{stat.sample.forecastHoltWinters}{stat.sample.forecastHoltWinters}} to make predictions from the state record. \vspace{0.1 cm} \\ For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, $a_t = \alpha x_t / c_{t-L} + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma x_t / a_t + (1 - \gamma) c_{t-L}$ for the multiplicative case and $a_t = \alpha (x_t - c_{t-L}) + (1 - \alpha)(a_{t-1} + b_{t-1})$, $b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}$, and $c_t = \gamma (x_t - a_t) + (1 - \gamma) c_{t-L}$ for the additive case. \vspace{0.1 cm} \\ In each call to this function, {\PFApf cycle} is rotated left, such that the first item is $c_t$.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14050:} If {\PFAp alpha} is less than 0 or greater than 1, an ``alpha out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14051:} If {\PFAp beta} is less than 0 or greater than 1, an ``beta out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14052:} If {\PFAp gamma} is less than 0 or greater than 1, an ``gamma out of range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14053:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.forecast1HoltWinters}{\hypertarget{stat.sample.forecast1HoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecast1HoltWinters":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast one time-step from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be an array of {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a prediction of the next time-step. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + b_t$ (non-periodic), $(a_t + b_t) c_{t+1}$ (multiplicative), or $a_t + b_t + c_{t+1}$ (additive) for each $i$ from $0$ to $n - 1$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14060:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.forecastHoltWinters}{\hypertarget{stat.sample.forecastHoltWinters}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.forecastHoltWinters":$\!$ [n, state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf level:}$\!$ double, {\PFApf trend:}$\!$ double\} \\  & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Forecast {\PFAp n} time-steps from a state record prepared by {\PFAf \hyperlink{stat.state.updateHoltWinters}{stat.state.updateHoltWinters}} or {\PFAf \hyperlink{stat.state.updateHoltWintersPeriodic}{stat.state.updateHoltWintersPeriodic}}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of {\PFApf level}, {\PFApf trend}, and possibly {\PFApf cycle} and {\PFApf multiplicative}.                                                      \begin{description*}\item[\PFAc level:] The constant term in an exponentially weighted linear fit of recent data. \item[\PFAc trend:] The linear term in an exponentially weighted linear fit of recent data. \item[\PFAc cycle:] The history of the previous cycle.  This field is optional, but if provided, it must be a {\PFAc double} and must be accompanied by {\PFApf multiplicative}. \item[\PFAc multiplicative:] If {\PFAc true}, interpret {\PFApf cycle} as multiplicative; if {\PFAc false}, interpret it as additive.  This field is optional, but if provided, it must be a {\PFAc boolean} and must be accompanied by {\PFApf cycle}. \end{description*} \\  & {\it (return value)} \rm & Returns a series of predictions for the next {\PFAp n} time-steps. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}For $a_t$ = the {\PFApf level} at a time $t$, $b_t$ = the {\PFApf trend} at a time $t$, and $c_t$ = the {\PFApf cycle} at a time $t$ with period $L$, this function returns $a_t + i b_t$ (non-periodic), $(a_t + i b_t) c_{(t + i) \mbox{mod} n}$ (multiplicative), or $a_t + i b_t + c_{(t + i) \mbox{mod} n}$ (additive) for each $i$ from $1$ to $n$\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14070:} If {\PFApf cycle} is empty, an ``empty cycle'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.fillHistogram}{\hypertarget{stat.sample.fillHistogram}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.sample.fillHistogram":$\!$ [x, w, histogram]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf numbins:}$\!$ int, {\PFApf low:}$\!$ double, {\PFApf high:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf low:}$\!$ double, {\PFApf binsize:}$\!$ double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf ranges:}$\!$ array of array of double, {\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.  It must have {\PFApf numbins}, {\PFApf low}, {\PFApf high}, and {\PFApf values} (fixed bins) xor it must have {\PFApf low}, {\PFApf binsize}, and {\PFApf values} (number of equal-sized bins grows), xor it must have {\PFApf ranges} and {\PFApf values} (arbitrary interval bins).  Only one set of required fields is allowed (semantic error otherwise), and the rest of the fields are optional.                                                                                                                        \begin{description*}\item[\PFAc numbins:] The fixed number of bins in the histogram. \item[\PFAc low:] The low edge of the histogram range (inclusive). \item[\PFAc high:] The high edge of the histogram range (exclusive). \item[\PFAc binsize:] The size of a bin for a histogram whose number of bins and right edge grows with the data. \item[\PFAc ranges:] Pairs of values describing arbitrary interval bins.  The first number of each pair is the inclusive left edge and the second number is the exclusive right edge. \item[\PFAc values:] Histogram contents, which are updated by this function. \item[\PFAc underflow:] If present, this double-valued field counts {\PFAp x} values that are less than {\PFApf low} or not contained in any {\PFApf ranges}. \item[\PFAc overflow:] If present, this double-valued field counts {\PFAp x} values that are greater than {\PFApf high}. \item[\PFAc nanflow:] If present, this double-valued field counts {\PFAp x} values that are {\PFAc nan}.  {\PFAc nan} values would never enter {\PFApf values}, {\PFApf underflow}, or {\PFApf overflow}. \item[\PFAc :] If present, this double-valued field counts {\PFAp x} values that are infinite.  Infinite values would only enter {\PFApf underflow} or {\PFApf overflow} if {\PFApf infflow} is not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values}, {\PFApf underflow}, {\PFApf overflow}, {\PFApf nanflow}, and {\PFApf infflow}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}) and {\PFAp x} minus {\PFApf low} is greater than or equal to {\PFApf binsize} times the length of {\PFApf values}, the {\PFApf values} will be padded with zeros to reach it. \vspace{0.1 cm} \\ If the histogram is growable (described by {\PFApf low} and {\PFApf binsize}), only finite values can extend the size of the histogram: infinite values are entered into {\PFApf overflow} or {\PFApf infflow}, depending on whether {\PFApf infflow} is present. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and an element of {\PFApf ranges} contains two equal values, then {\PFAp x} is considered in the interval if it is exactly equal to the value. \vspace{0.1 cm} \\ If the histogram is described by {\PFApf ranges} and {\PFAp x} falls within multiple, overlapping intervals, then all matching counters are updated (values can be double-counted).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14080:} If the length of {\PFApf values} is not equal to {\PFApf numbins} or the length of {\PFApf ranges}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ {\bf \#14081:} If {\PFApf low} is greater than or equal to {\PFApf high}, then a ``bad histogram range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14082:} If {\PFApf numbins} is less than 1 or {\PFApf binsize} is less than or equal to 0, then a ``bad histogram scale'' error is raised. \vspace{0.1 cm} \\ {\bf \#14083:} If {\PFApf ranges} contains an array of doubles with length not equal to 2 or if the first element is greater than the second element, then a ``bad histogram ranges'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.fillHistogram2d}{\hypertarget{stat.sample.fillHistogram2d}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.fillHistogram2d":$\!$ [x, y, w, histogram]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc y \rm & double \\  & \PFAc w \rm & double \\  & \PFAc histogram \rm & any record {\PFAtp A} with \{{\PFApf xnumbins:}$\!$ int, {\PFApf xlow:}$\!$ double, {\PFApf xhigh:}$\!$ double, {\PFApf ynumbins:}$\!$ int, {\PFApf ylow:}$\!$ double, {\PFApf yhigh:}$\!$ double, {\PFApf values:}$\!$ array of array of double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a two-dimensional histogram by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample x value.  \\  & \PFAc y \rm & Sample y value.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The histogram prior to filling.                                                                                                                                                                                                     \begin{description*}\item[\PFAc xnumbins:] The number of bins in the x dimension. \item[\PFAc xlow:] The low edge of the histogram range in the x dimension (inclusive). \item[\PFAc xhigh:] The high edge of the histogram range in the x dimension (exclusive). \item[\PFAc ynumbins:] The number of bins in the y dimension. \item[\PFAc ylow:] The low edge of the histogram range in the y dimension (inclusive). \item[\PFAc yhigh:] The high edge of the histogram range in the y dimension (exclusive). \item[\PFAc values:] Histogram contents, which are updated by this function.  The outer array iterates over {\PFAp x} and the inner array iterates over {\PFAp y}. \item[\PFAc underunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc undermidflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc underoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is less than {\PFApf xlow} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc midunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc midoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is between {\PFApf xlow} (inclusive) and {\PFApf xhigh} (exclusive) and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc overunderflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is less than {\PFApf ylow}. \item[\PFAc overmidflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} between {\PFApf ylow} (inclusive) and {\PFApf yhigh} (exclusive). \item[\PFAc overoverflow:] If present, this double-valued field counts instances in which {\PFAp x} is greater than or equal to {\PFApf xhigh} and {\PFAp y} is greater than or equal to {\PFApf yhigh}. \item[\PFAc nanflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is {\PFAc nan}.  {\PFAc nan} values would never enter any other counter. \item[\PFAc infflow:] If present, this double-valued field counts instances in which {\PFAp x} or {\PFAp y} is infinite.  Infinite values would only enter the other under/mid/overflow counters if {\PFApf infflow} were not present, so that they are not double-counted. \end{description*} \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp histogram}: all fields are unchanged except for {\PFApf values} and the under/mid/over/nan/infflow counters. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp x} is infinite and {\PFAp y} is {\PFAc nan} or {\PFAp x} is {\PFAc nan} and {\PFAp y} is infinite, the entry is counted as {\PFAc nan}, rather than infinite.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#14090:} If the length of {\PFApf values} is not equal to {\PFApf xnumbins} or the length of any element of {\PFApf values} is not equal to {\PFApf ynumbins}, then a ``wrong histogram size'' error is raised. \vspace{0.1 cm} \\ {\bf \#14091:} If {\PFApf xlow} is greater than or equal to {\PFApf xhigh} or if {\PFApf ylow} is greater than or equal to {\PFApf yhigh}, then a ``bad histogram range'' error is raised. \vspace{0.1 cm} \\ {\bf \#14092:} If {\PFApf xnumbins} is less than 1 or {\PFApf ynumbins} is less than 1, then a ``bad histogram scale'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.fillCounter}{\hypertarget{stat.sample.fillCounter}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.fillCounter":$\!$ [x, w, counter]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & string \\  & \PFAc w \rm & double \\  & \PFAc counter \rm & any record {\PFAtp A} with \{{\PFApf values:}$\!$ map of double\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a counter (sparse histogram) by filling it with one value. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample category.  \\  & \PFAc w \rm & Sample weight; set to 1 for no weights.  \\  & \PFAc histogram \rm & The counter prior to filling.                     \begin{description*}\item[\PFAc values:] Number of instances seen of each category. \end{description*} \\  & {\it (return value)} \rm & Returns the updated counter. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If a category is not present in the initial {\PFApf values}, it is added with initial value zero prior to filling.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.sample.topN}{\hypertarget{stat.sample.topN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.sample.topN":$\!$ [x, top, n, lessThan]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & any {\PFAtp A} \\  & \PFAc top \rm & array of {\PFAtp A} \\  & \PFAc n \rm & int \\  & \PFAc lessThan \rm & function ({\PFAtp A}, {\PFAtp A}) $\to$ boolean \\  & {\it (returns)} & array of {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update an array of the top {\PFAp n} sorted items by potentially adding {\PFAp x} to that array, using {\PFAp lessThan} as a comparison function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Sample value.  \\  & \PFAc top \rm & Array of items to which {\PFAp x} might be added.  This array is assumed to be sorted according to {\PFAp lessThan}.  \\  & \PFAc n \rm & Maximum number of items to keep.  \\  & \PFAc lessThan \rm & Comparison function; should return {\PFAc true} if its first argument is less than its second argument, {\PFAc false} otherwise.  \\  & {\it (return value)} \rm & Returns an updated version of {\PFAp top}.  If {\PFAp x} is among the top {\PFAp n} values seen, then it is included in the output.  Otherwise, the output is {\PFAp top}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp x} value is inserted after the first element of {\PFAp top} that it is greater than or equal to ({\PFAp lessThan} applied to that array element and {\PFAp x} returns {\PFAc true}) and the result is truncated to size {\PFAp n}.  Thus, the result only represents a top-n list if {\PFAp top} is already sorted and equal elements already in the array get precedence. \vspace{0.1 cm} \\ The {\PFAp top} array is unchanged by this function because all values in PFA are immutable.  The updated array is the return value.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.change.updateTrigger}{\hypertarget{stat.change.updateTrigger}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateTrigger":$\!$ [predicate, history]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc predicate \rm & boolean \\  & \PFAc history \rm & any record {\PFAtp A} with \{{\PFApf numEvents:}$\!$ int, {\PFApf numRuns:}$\!$ int, {\PFApf currentRun:}$\!$ int, {\PFApf longestRun:}$\!$ int\} \\  & {\it (returns)} & {\PFAtp A} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a trigger that counts the number of times {\PFAp predicate} is satisfied ({\PFAc true}), as well as the number and lengths of runs of {\PFAc true}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc predicate \rm & Expression that evaluates to {\PFAc true} or {\PFAc false}.  \\  & \PFAc history \rm & Summary of previous results of the {\PFAp predicate}.                                                      \begin{description*}\item[\PFAc numEvents:] The number of times {\PFAp predicate} evaluated to {\PFAc true}. \item[\PFAc numRuns:] The number of contiguous intervals in which {\PFAp predicate} was {\PFAc true}, including the current one. \item[\PFAc currentRun:] If {\PFAp predicate} is {\PFAc false}, {\PFApf currentRun} is 0.  Otherwise, {\PFApf currentRun} is incremented (greater than or equal to 1 if {\PFAp predicate} evaluated to {\PFAc true}). \item[\PFAc longestRun:] The longest run observed so far; may be equal to {\PFApf currentRun}. \end{description*} \\  & {\it (return value)} \rm & Returns a new record with updated fields: {\PFApf numEvents} is always incremented; {\PFApf numRuns} is incremented if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is zero; {\PFApf currentRun} is incremented if {\PFAp predicate} is {\PFAc true} and set to zero if {\PFAp predicate} is {\PFAc false}; {\PFApf longestRun} is set to {\PFApf currentRun} if {\PFAp predicate} is {\PFAc true} and {\PFApf currentRun} is longer than {\PFApf longestRun}.  If the input {\PFAp history} has fields other than {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, or {\PFApf longestRun}, they are copied unaltered to the output. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#37000:} If any of {\PFApf numEvents}, {\PFApf numRuns}, {\PFApf currentRun}, and {\PFApf longestRun} are less than 0, a ``counter out of range'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {stat.change.zValue}{\hypertarget{stat.change.zValue}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"stat.change.zValue":$\!$ [x, meanVariance]\} \rm or \PFAc \{"stat.change.zValue":$\!$ [x, meanVariance, unbiased]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanVariance \rm & any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc meanVariance \rm & any record {\PFAtp A} with \{{\PFApf count:}$\!$ double, {\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\  & \PFAc unbiased \rm & boolean \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Calculate the z-value between {\PFAp x} and a normal distribution with a given mean and variance. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Value to test.  \\  & \PFAc meanVariance \rm & A record with {\PFApf mean}, {\PFApf variance}, and possibly {\PFApf count}, such as the output of {\PFAf \hyperlink{stat.sample.Update}{stat.sample.Update}}.  \\  & \PFAc unbiased \rm & If {\PFAc true}, use {\PFApf count} to correct for the bias due to the fact that a variance centered on the mean has one fewer degrees of freedom than the dataset that it was sampled from (Bessel's correction).  \\  & {\it (return value)} \rm & If {\PFAp unbiased} is {\PFAc false}, $(x - mean)/\sqrt{variance}$; otherwise $(x - mean)(1/\sqrt{variance})\sqrt{count/(count - 1)}$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {stat.change.updateCUSUM}{\hypertarget{stat.change.updateCUSUM}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"stat.change.updateCUSUM":$\!$ [logLikelihoodRatio, last, reset]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc logLikelihoodRatio \rm & double \\  & \PFAc last \rm & double \\  & \PFAc reset \rm & double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cumulative sum (CUSUM) to detect the transition of a dataset from one distribution to another. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc logLikelihoodRatio \rm & The logarithm of the ratio of the likelihood of a value for the alterate and baseline distributions: $\ln(\mbox{alt}_{L}/\mbox{base}_{L})$, which is $\mbox{alt}_{LL} - \mbox{base}_{LL}$ where $L$ is likelihood and $LL$ is log-likelihood.  Consider using something like {\PFAc {``-'': [{``prob.dist.gaussianLL'': [...]}, {``prob.dist.gaussianLL'': [...]}]}}.  \\  & \PFAc last \rm & The previous return value from this function.  \\  & \PFAc reset \rm & A low value (usually consistent with the baseline hypothesis, such as 0) at which the cumulative sum resets, rather than accumulate very low values and become insensitive to future changes.  \\  & {\it (return value)} \rm & An incremented cumulative sum.  The output is $\max\{logLikelihoodRatio + last, reset\}$. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.reg.linear}{\hypertarget{model.reg.linear}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linear":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ array of array of double, {\PFApf const:}$\!$ array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of double, {\PFApf const:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf coeff:}$\!$ map of map of double, {\PFApf const:}$\!$ map of double\} \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply matrix {\PFAp model} to independent variables {\PFAp datum} to predict the dependent, predicted variables. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                                \begin{description*}\item[\PFAc coeff:] Vector or matrix of coefficients that multiply the input variables, which has $p$ rows and $d$ columns. \item[\PFAc const:] Scalar or vector of constant offsets, which has $p$ dimensions. \end{description*} \\  & {\it (return value)} \rm & Returns a $p$ dimensional vector of dependent, predicted variables. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix). \vspace{0.1 cm} \\ The simpler signature is may be used in the $p = 1$case.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31000:} The array signature raises a ``misaligned coeff'' error if any row of {\PFApf coeff} does not have the same indexes as {\PFAp datum}. \vspace{0.1 cm} \\ {\bf \#31001:} The array signature raises a ``misaligned const'' error if {\PFApf const} does not have the same indexes as {\PFAp coeff}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.linearVariance}{\hypertarget{model.reg.linearVariance}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.linearVariance":$\!$ [datum, model]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ array of array of array of double\} \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc model \rm & any record {\PFAtp M} with \{{\PFApf covar:}$\!$ map of map of map of double\} \\ & {\it (returns)} & map of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Propagate variances from {\PFAp model} {\PFApf covar} (covariance matrix) to the dependent, predicted variable(s). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables $\vec{o}$ with $d$ dimensions.  \\  & \PFAc model \rm & Parameters of the linear model.                     \begin{description*}\item[\PFAc covar:] Covariance matrix $C$ or array/map of covariance matrices, one for each dependent, predicted variable.  Each matrix has $d + 1$ rows and $d + 1$ columns: the last (array) or empty string (map) row and column corresponds to the model's constant term.  If there are $p$ dependent, predicted variables, the outermost array/map has $p$ items. \end{description*} \\  & {\it (return value)} \rm & Propagated variance(s) $\vec{o}^T C \vec{o}$ for each dependent, predicted variable. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The ``error'' or ``uncertainty'' in the predicted variable(s) is the square root of this value/these values. \vspace{0.1 cm} \\ The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in {\PFAp x} must be equal to the number of rows and/or columns of {\PFAp y}, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31010:} The array signature raises a ``misaligned covariance'' error if any covariance matrix does not have the same indexes as {\PFAp datum} plus the implicit index for a constant (last in array signature).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.gaussianProcess}{\hypertarget{model.reg.gaussianProcess}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.gaussianProcess":$\!$ [x, table, krigingWeight, kernel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ double, {\PFApf to:}$\!$ array of double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc x \rm & array of double \\  & \PFAc table \rm & array of any record {\PFAtp R} with \{{\PFApf x:}$\!$ array of double, {\PFApf to:}$\!$ array of double\} \\  & \PFAc krigingWeight \rm & union of \{null, double\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Fit the training data in {\PFAp table} with a Gaussian Process model and predict the value of model at {\PFAp x}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc x \rm & Position (scalar or vector) at which to predict the value of the model.  \\  & \PFAc table \rm & Training data for the Gaussian Process.                                           \begin{description*}\item[\PFAc x:] Independent variable (scalar or vector, but same as {\PFAp x}) of a training datum. \item[\PFAc to:] Dependent variable (scalar or vector) of a training datum. \item[\PFAc sigma:] Optional uncertainty for the datum. If present, it must have the same type as {\PFApf to} and is used in the Gaussian Process fit as a nugget. \end{description*} \\  & \PFAc krigingWeight \rm & If a number, the Gaussian Process is performed with the specified Kriging weight. If {\PFAc null}, universal Kriging is performed.  \\  & \PFAc kernel \rm & A function to use as a kernel. For instance, {\PFAf \hyperlink{m.kernel.rbf}{m.kernel.rbf}} (radial basis function) with partially applied {\PFAc gamma} is a squared exponential kernel.  \\  & {\it (return value)} \rm & Returns a scalar or vector prediction with the same type as {\PFApf to}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: unstable.} This function gives the same results every time it is executed, but those results may not be exactly the same on all systems.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31080:} If {\PFAp table} is empty, a ``table must have at least 1 entry'' error is raised. \vspace{0.1 cm} \\ {\bf \#31081:} If {\PFAp x} is an empty array, an ``x must have at least 1 feature'' error is raised. \vspace{0.1 cm} \\ {\bf \#31082:} If any {\PFApf x} in the {\PFAp table} has a different length than the input parameter {\PFAp x}, a ``table must have the same number of features as x'' error is raised. \vspace{0.1 cm} \\ {\bf \#31083:} If any {\PFApf to} in the {\PFAp table} is an empty array, a ``table outputs must have at least 1 dimension'' error is raised. \vspace{0.1 cm} \\ {\bf \#31084:} If the {\PFApf to} fields in {\PFAp table} do not all have the same dimensions, a ``table outputs must all have the same number of dimensions'' error is raised. \vspace{0.1 cm} \\ {\bf \#31085:} If {\PFAp x} or a component of {\PFAp x} is not finite, an ``x is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31086:} If any value in the {\PFAp table} is not finite, a ``table value is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31087:} If {\PFAp krigingWeight} is a number but is not finite, a ``krigingWeight is not finite'' error is raised. \vspace{0.1 cm} \\ {\bf \#31088:} If evaluating {\PFAp kernel} on all combinations of {\PFAp table} {\PFApf x} (with $1 + (\mbox{sigma}/\mbox{to})^2$ on the diagonal) yields a non-positive definite matrix, a ``matrix of kernel results is not positive definite'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.residual}{\hypertarget{model.reg.residual}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.residual":$\!$ [observation, prediciton]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\ & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.residual instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\ & {\it (returns)} & array of double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.residual instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\ & {\it (returns)} & map of double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.residual instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31020:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.pull}{\hypertarget{model.reg.pull}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.pull":$\!$ [observation, prediciton, uncertainty]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & double \\  & \PFAc prediciton \rm & double \\  & \PFAc uncertainty \rm & double \\ & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.pull instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediciton \rm & array of double \\  & \PFAc uncertainty \rm & array of double \\ & {\it (returns)} & array of double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.pull instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediciton \rm & map of double \\  & \PFAc uncertainty \rm & map of double \\ & {\it (returns)} & map of double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.pull instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Scalar or vector of observations.  \\  & \PFAc prediction \rm & Scalar or vector of predictions.  \\  & \PFAc uncertainty \rm & Scalar or vector of predictions.  \\  & {\it (return value)} \rm & Scalar or vector of {\PFAp observation} minus {\PFAp prediction} divided by {\PFAp uncertainty}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31030:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#31031:} Raises a ``misaligned uncertainty'' error if {\PFAp prediction} does not have the same indexes as {\PFAp uncertainty}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.mahalanobis}{\hypertarget{model.reg.mahalanobis}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.mahalanobis":$\!$ [observation, prediction, covariance]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & array of double \\  & \PFAc prediction \rm & array of double \\  & \PFAc covariance \rm & array of array of double \\ & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.mahalanobis instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc observation \rm & map of double \\  & \PFAc prediction \rm & map of double \\  & \PFAc covariance \rm & map of map of double \\ & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.mahalanobis instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc observation \rm & Vector of observations $\vec{o}$.  \\  & \PFAc prediction \rm & Vector of predictions $\vec{p}$.  \\  & \PFAc covariance \rm & Matrix of covariance $C$.  \\  & {\it (return value)} \rm & Scalar result of a similarity transformation: $\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}$. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31040:} Raises a ``too few rows/cols'' error if {\PFAp observation} has fewer than one element. \vspace{0.1 cm} \\ {\bf \#31041:} Raises a ``misaligned prediction'' error if {\PFAp prediction} does not have the same indexes as {\PFAp observation}. \vspace{0.1 cm} \\ {\bf \#31042:} Raises a ``misaligned covariance'' error if {\PFAp covariance} does not have the same indexes as {\PFAp observation}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.reg.updateChi2}{\hypertarget{model.reg.updateChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.reg.updateChi2":$\!$ [pull, state]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.updateChi2 instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & array of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.updateChi2 instead.} \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc pull \rm & map of double \\  & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\ & {\it (returns)} & {\PFAtp A} \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.updateChi2 instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update the state of a chi-square calculation. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc pull \rm & Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.  \\  & \PFAc state \rm & Record of the previous {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.reg.reducedChi2}{\hypertarget{model.reg.reducedChi2}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.reg.reducedChi2":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\  & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.reducedChi2 instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the reduced chi-square, which is {\PFApf chi2}/{\PFApf DOF}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.reg.chi2Prob}{\hypertarget{model.reg.chi2Prob}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.reg.chi2Prob":$\!$ [state]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc state \rm & any record {\PFAtp A} with \{{\PFApf chi2:}$\!$ double, {\PFApf DOF:}$\!$ int\} \\  & {\it (returns)} & double \\ \\ \vspace{-0.8 cm} \fbox{\bf Deprecated; exists until PFA 0.9.0: use stat.test.chi2Prob instead.} \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the chi-square probability, which is the CDF of the chi-square function. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc state \rm & Record of the {\PFApf chi2} and {\PFApf DOF}.  \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#31070:} Raises ``invalid parameterization'' if {\PFApf DOF} is less than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.simpleTest}{\hypertarget{model.tree.simpleTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}), ``isMissing'' (ignore {\PFApf value}, return {\PFAc true} iff the field of {\PFAp datum} is {\PFAc null}), and ``notMissing'' (ignore {\PFApf value}, return {\PFAc false} iff the field of {\PFAp datum} is {\PFAc null}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & Returns {\PFAc true} if the field of {\PFAp datum} <op> {\PFApf value} is {\PFAc true}, {\PFAc false} otherwise, where <op> is the {\PFApf operator}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32000:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse'', ``isMissing'', ``notMissing''. \vspace{0.1 cm} \\ {\bf \#32001:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.missingTest}{\hypertarget{model.tree.missingTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingTest":$\!$ [datum, comparison]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparison \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}\} \\  & {\it (returns)} & union of \{null, boolean\} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Determine if {\PFAp datum} passes a test defined by {\PFAp comparison}, allowing for missing values. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparison \rm & Record that describes a test.                                           \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \end{description*} \\  & {\it (return value)} \rm & If the field of {\PFAp datum} is {\PFAc null}, this function returns {\PFAc null} (unknown test result).  Otherwise, it returns {\PFAp datum} field <op> {\PFApf value}, where <op> is the {\PFApf operator} \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32010:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse''. \vspace{0.1 cm} \\ {\bf \#32011:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.compoundTest}{\hypertarget{model.tree.compoundTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.compoundTest":$\!$ [datum, operator, comparisons, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc operator \rm & string \\  & \PFAc comparisons \rm & array of any record {\PFAtp T} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp test} to an array of {\PFAp comparisons}, returning their logical and, or, or xor, depending on {\PFAp operator}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Simple value to test.  \\  & \PFAc operator \rm & If ``and'', return {\PFAc true} if no {\PFAc false} is encountered, if ``or'', return {\PFAc true} if any {\PFAc true} is encountered, and if ``xor'', return {\PFAc true} if an odd number of {\PFAc true} is encountered among the {\PFAp comparisons}.  \\  & \PFAc comparisons \rm & Array of records that describe the tests.  \\  & \PFAc test \rm & Test function applied to each item of {\PFAp comparisons} until the result is certain.  \\  & {\it (return value)} \rm & Logical combination of {\PFAp comparisons}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp operator} is ``and'', the {\PFAp test} will only be applied until the first {\PFAc false} is encountered. If {\PFAp operator} is ``or'', the {\PFAp test} will only be applied until the first {\PFAc true} is encountered. If {\PFAp operator} is ``xor'', the {\PFAp test} will be applied to all items of {\PFAp comparisons}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32020:} If {\PFAp operator} is not ``and'', ``or'', or ``xor'', an ``unrecognized logical operator'' error is raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.surrogateTest}{\hypertarget{model.tree.surrogateTest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.surrogateTest":$\!$ [datum, comparisons, missingTest]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc comparisons \rm & array of any record {\PFAtp T} \\  & \PFAc missingTest \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & boolean \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply {\PFAp missingTest} to an array of {\PFAp comparisons} until one yields a non-null result. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc comparisons \rm & Array of records that describe the tests.  \\  & \PFAc missingTest \rm & Test function applied to each item of {\PFAp comparisons} until one returns a non-null result.  \\  & {\it (return value)} \rm & Returns the value of the first test that returns {\PFAc true} or {\PFAc false}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32030:} If all tests return {\PFAc null}, this function raises a ``no successful surrogate'' error.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.tree.simpleWalk}{\hypertarget{model.tree.simpleWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ boolean \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass} or {\PFApf fail} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true} or {\PFAc false}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.tree.missingWalk}{\hypertarget{model.tree.missingWalk}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.missingWalk":$\!$ [datum, treeNode, test]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}, {\PFApf missing:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & \PFAc test \rm & function ({\PFAtp D}, {\PFAtp T}) $\to$ union of \{null, boolean\} \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing the fields of {\PFAp datum} with the {\PFAp test} function using {\PFAp treeNode} to define the comparison, continuing to {\PFApf pass}, {\PFApf fail}, or {\PFApf missing} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Node of the tree, which contains a predicate to be interpreted by {\PFAp test}.                                           \begin{description*}\item[\PFAc pass:] Branch to follow if {\PFAp test} returns {\PFAc true}. \item[\PFAc fail:] Branch to follow if {\PFAp test} returns {\PFAc false}. \item[\PFAc missing:] Branch to follow if {\PFAp test} returns {\PFAc null}. \end{description*} \\  & \PFAc test \rm & Test function that converts {\PFAp datum} and {\PFAp treeNode} into {\PFAc true}, {\PFAc false}, or {\PFAc null}.  \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.tree.simpleTree}{\hypertarget{model.tree.simpleTree}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.tree.simpleTree":$\!$ [datum, treeNode]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any record {\PFAtp D} \\  & \PFAc treeNode \rm & any record {\PFAtp T} with \{{\PFApf field:}$\!$ enum F of fields of D, {\PFApf operator:}$\!$ string, {\PFApf value:}$\!$ any {\PFAtp V}, {\PFApf pass:}$\!$ union of \{{\PFAtp T}, any {\PFAtp S}\}, {\PFApf fail:}$\!$ union of \{{\PFAtp T}, {\PFAtp S}\}\} \\  & {\it (returns)} & {\PFAtp S} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Descend through a tree, testing {\PFAp datum} with {\PFApf field}, {\PFApf operator}, {\PFApf value}, following {\PFApf pass} or {\PFApf fail} until reaching a leaf node of type {\PFAtp S} (score). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample value to test.  \\  & \PFAc treeNode \rm & Record that describes a tree node (predicate test with branches).                                                                 \begin{description*}\item[\PFAc field:] Field name from {\PFAp datum}: the enumeration type must include all fields of {\PFAtp D} in their declaration order. \item[\PFAc operator:] One of the following: ``=='' (equal), ``!='' (not equal), ``<'' (less than), ``<='' (less or equal), ``>'' (greater than), ``>='' (greater or equal), ``in'' (member of a set), ``notIn'' (not a member of a set), ``alwaysTrue'' (ignore {\PFApf value}, return {\PFAc true}), ``alwaysFalse'' (ignore {\PFApf value}, return {\PFAc false}), ``isMissing'' (ignore {\PFApf value}, return {\PFAc true} iff the field of {\PFAp datum} is {\PFAc null}), and ``notMissing'' (ignore {\PFApf value}, return {\PFAc false} iff the field of {\PFAp datum} is {\PFAc null}). \item[\PFAc value:] Value to which the field of {\PFAp datum} is compared. \item[\PFAc pass:] Branch to follow if the comparison is successful. \item[\PFAc fail:] Branch to follow if the comparison fails. \end{description*} \\  & {\it (return value)} \rm & Leaf node of type {\PFAtp S}, which must be different from the tree nodes.  For a classification tree, {\PFAtp S} could be a string or an enumeration set.  For a regression tree, {\PFAtp S} would be a numerical type.  For a multivariate regression tree, {\PFAtp S} would be an array of numbers, etc. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}This is a convenience function, a combination of {\PFAf \hyperlink{model.tree.simpleWalk}{model.tree.simpleWalk}} with {\PFAf \hyperlink{model.tree.simpleTest}{model.tree.simpleTest}}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#32060:} Raises an ``invalid comparison operator'' if {\PFApf operator} is not one of ``=='', ``!='', ``<'', ``<='', ``>'', ``>='', ``in'', ``notIn'', ``alwaysTrue'', ``alwaysFalse'', ``isMissing'', ``notMissing''. \vspace{0.1 cm} \\ {\bf \#32061:} Raises a ``bad value type'' if the {\PFApf field} of {\PFAp datum} and {\PFAtp V} are not both numbers and the {\PFApf field} cannot be upcast to {\PFAtp V}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.closest}{\hypertarget{model.cluster.closest}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closest":$\!$ [datum, clusters]\} \rm or \PFAc \{"model.cluster.closest":$\!$ [datum, clusters, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ any {\PFAtp B}\} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the cluster {\PFAtp C} whose {\PFApf center} is closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & Returns the closest cluster record. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29000:} Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.closestN}{\hypertarget{model.cluster.closestN}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.cluster.closestN":$\!$ [n, datum, clusters]\} \rm or \PFAc \{"model.cluster.closestN":$\!$ [n, datum, clusters, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\ & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc n \rm & int \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ any {\PFAtp B}\} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp n} clusters {\PFAtp C} whose {\PFApf centers} are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc n \rm & Number of clusters to search for.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest cluster records in order from the closest to the farthest.  The length of the array is minimum of {\PFAp n} and the length of {\PFAp clusters}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp metric} is not provided, a Euclidean metric over floating point numbers is assumed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29010:} If {\PFAp n} is negative, an ``n must be nonnegative'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.randomSeeds}{\hypertarget{model.cluster.randomSeeds}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.randomSeeds":$\!$ [data, k, newCluster]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc k \rm & int \\  & \PFAc newCluster \rm & function (int, array of {\PFAtp A}) $\to$ any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Call {\PFAp newCluster} to create {\PFAp k} cluster records with random, unique cluster centers drawn from {\PFAp data}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc k \rm & Number of times to call {\PFAp newCluster}.  \\  & \PFAc newCluster \rm & Function that creates a cluster record, given an index (ranges from zero up to but not including {\PFAp k}) and a random vector from {\PFAp data}.  \\  & {\it (return value)} \rm & The cluster records created by {\PFAp newCluster}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf Nondeterministic: pseudorandom.} This function intentionally gives different results every time it is executed.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29020:} Raises a ``k must be greater than zero'' error if {\PFAp k} is less than or equal to zero. \vspace{0.1 cm} \\ {\bf \#29021:} Raises a ``not enough unique points'' error if {\PFAp data} has fewer than {\PFAp k} unique elements. \vspace{0.1 cm} \\ {\bf \#29022:} Raises a ``dimensions of vectors do not match'' error if the elements of {\PFAp data} are not all the same size.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.kmeansIteration}{\hypertarget{model.cluster.kmeansIteration}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.kmeansIteration":$\!$ [data, clusters, metric, update]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of any {\PFAtp A} \\  & \PFAc clusters \rm & array of any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of any {\PFAtp B}\} \\  & \PFAc metric \rm & function (array of {\PFAtp A}, array of {\PFAtp B}) $\to$ double \\  & \PFAc update \rm & function (array of array of {\PFAtp A}, {\PFAtp C}) $\to$ {\PFAtp C} \\  & {\it (returns)} & array of {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster set by applying one iteration of k-means (Lloyd's algorithm). \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc data \rm & Sample data.  \\  & \PFAc clusters \rm & Set of clusters; the record type {\PFAtp C} may contain additional identifying information for post-processing.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} with the {\PFApf center} of the {\PFAp clusters}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & \PFAc update \rm & Function of matched data and old cluster records that yields new cluster records.  (See, for example, {\PFAf \hyperlink{model.cluster.updateMean}{model.cluster.updateMean}} with {\PFAp weight} = 0.)  \\  & {\it (return value)} \rm & Returns a new cluster set with each of the {\PFAtp centers} located at the average of all points that match the corresponding cluster in the old cluster set. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}The {\PFAp update} function is only called if the number of matched data points is greater than zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29030:} Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ {\bf \#29031:} Raises a ``no clusters'' error if {\PFAp clusters} is empty.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.cluster.updateMean}{\hypertarget{model.cluster.updateMean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.cluster.updateMean":$\!$ [data, cluster, weight]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc data \rm & array of array of double \\  & \PFAc cluster \rm & any record {\PFAtp C} with \{{\PFApf center:}$\!$ array of double\} \\  & \PFAc weight \rm & double \\  & {\it (returns)} & {\PFAtp C} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Update a cluster record by computing the mean of the {\PFAp data} vectors and {\PFAp weight} times the old {\PFAp cluster} center. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}If {\PFAp weight} is zero, the new center is equal to the mean of {\PFAp data}, ignoring the old {\PFAp center}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#29040:} Raises a ``no data'' error if {\PFAp data} is empty. \vspace{0.1 cm} \\ {\bf \#29041:} Raises a ``dimensions of vectors do not match'' error if all elements of {\PFAp data} and the {\PFAp cluster} center do not match.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neighbor.mean}{\hypertarget{model.neighbor.mean}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.mean":$\!$ [points]\} \rm or \PFAc \{"model.neighbor.mean":$\!$ [points, weight]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc points \rm & array of array of double \\  & \PFAc weight \rm & function (array of double) $\to$ double \\ & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Return the vector-wise mean of {\PFAp points}, possibly weighted by {\PFAp weight}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc points \rm & Points from a codebook, for instance from {\PFAf \hyperlink{model.neighbor.nearestK}{model.neighbor.nearestK}}.  \\  & \PFAc weight \rm & Optional weighting function from each element of {\PFAp points} to a value.  If these values do not add up to 1.0, they will be internally normalized.  \\  & {\it (return value)} \rm & The vector-wise mean, which is by construction within the convex hull of the {\PFAp points}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#30000:} If {\PFAp points} is empty, a ``not enough points'' error will be raised. \vspace{0.1 cm} \\ {\bf \#30001:} If the {\PFAp points} have different sizes, an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neighbor.nearestK}{\hypertarget{model.neighbor.nearestK}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.nearestK":$\!$ [k, datum, codebook]\} \rm or \PFAc \{"model.neighbor.nearestK":$\!$ [k, datum, codebook, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc k \rm & int \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the {\PFAp k} items in the {\PFAp codebook} that are closest to the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc k \rm & Number of {\PFAp codebook} points to attempt to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the closest {\PFAp codebook} elements in any order.  The length of the array is minimum of {\PFAp k} and the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#30010:} If {\PFAp k} is negative, an ``k must be nonnegative'' error will be raised. \vspace{0.1 cm} \\ {\bf \#30011:} If arrays in the {\PFAp codebook} or the {\PFAp codebook} and the {\PFAp datum} have different sizes (without a {\PFAp metric}), an ``inconsistent dimensionality'' error will be raised.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neighbor.ballR}{\hypertarget{model.neighbor.ballR}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.neighbor.ballR":$\!$ [r, datum, codebook]\} \rm or \PFAc \{"model.neighbor.ballR":$\!$ [r, datum, codebook, metric]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & array of double \\  & \PFAc codebook \rm & array of array of double \\ & {\it (returns)} & array of array of double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc r \rm & double \\  & \PFAc datum \rm & any {\PFAtp A} \\  & \PFAc codebook \rm & array of any {\PFAtp B} \\  & \PFAc metric \rm & function ({\PFAtp A}, {\PFAtp B}) $\to$ double \\ & {\it (returns)} & array of {\PFAtp B} \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Find the items in {\PFAp codebook} that are within {\PFAp r} of the {\PFAp datum}, according to the {\PFAp metric}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc r \rm & Maximum distance (exclusive) of points to return.  \\  & \PFAc datum \rm & Sample datum.  \\  & \PFAc codebook \rm & Set of training data that is compared to the {\PFAp datum}.  \\  & \PFAc metric \rm & Function used to compare each {\PFAp datum} to each element of the {\PFAp codebook}.  (See, for example, {\PFAf \hyperlink{metric.euclidean}{metric.euclidean}}.)  \\  & {\it (return value)} \rm & An array of the {\PFAp codebook} elements within a distance {\PFAp r} in any order.  The length of the array could be as low as zero or as high as the length of {\PFAp codebook}. \\ \end{tabular} \vspace{0.2 cm} \\ }}%
    {model.naive.gaussian}{\hypertarget{model.naive.gaussian}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.gaussian":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & array of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & map of any record {\PFAtp A} with \{{\PFApf mean:}$\!$ double, {\PFApf variance:}$\!$ double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Gaussian Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm &  Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm &  Array or map of $d$ records, each containing the {\PFAp mean} and {\PFAp variance} of each of independent variable, for one class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood that {\PFAp datum} is a member of the class specified by {\PFAp classModel}. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10000:} Raises a ``datum and classModel misaligned'' error if {\PFAp datum} and {\PFAp classModel} have different lengths, of if their keys if using the map signature don't match one to one. \vspace{0.1 cm} \\ {\bf \#10001:} Raises a ``variance less than or equal to zero'' error if a variance inside of {\PFAp classModel} is incorrectly specified.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.naive.multinomial}{\hypertarget{model.naive.multinomial}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.multinomial":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & array of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ array of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & map of double \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Multinomial Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions.   \\  & \PFAc classModel \rm & Array or map of multinomial ($d$ different) likelihoods of each independent variable for this class. The record form is for histograms built by {\PFAf \hyperlink{stat.sample.fillHistogram}{stat.sample.fillHistogram}} or {\PFAf \hyperlink{stat.sample.fillCounter}{stat.sample.fillCounter}}.  \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Details:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\PFAp datum} or {\PFAp classModel} may be expressed as arrays (indexed by integers), or maps (indexed by strings).\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10010:} Raises a ``datum and classModel misaligned'' error if when using the map signature the keys of {\PFAp datum} and {\PFAp classModel} don't match one to one, of if when using the array signature they are different lengths. \vspace{0.1 cm} \\ {\bf \#10011:} Raises a ``classModel must be non-empty and strictly positive'' error if classModel is empty or any items are less than or equal to zero.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.naive.bernoulli}{\hypertarget{model.naive.bernoulli}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc\{"model.naive.bernoulli":$\!$ [datum, classModel]\}} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of string \\  & \PFAc classModel \rm & map of double \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{1.5 cm}}or \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of string \\  & \PFAc classModel \rm & any record {\PFAtp C} with \{{\PFApf values:}$\!$ map of double\} \\ & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score {\PFAp datum} using a Bernoulli Naive Bayes model. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Vector of independent variables with $d$ dimensions. The record form is for histograms built by {\PFAf \hyperlink{stat.sample.fillCounter}{stat.sample.fillCounter}}.  \\  & \PFAc classModel \rm & Array or map of $d$ likelihoods of the presence of each independent variable for this class.   \\  & {\it (return value)} \rm & Returns the unscaled log-likelihood of {\PFAp datum} for this class. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#10020:} Raises a ``probability in classModel must be strictly between 0 and 1'' error if a value in {\PFAp classModel} is not strictly between zero and one.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.neural.simpleLayers}{\hypertarget{model.neural.simpleLayers}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.neural.simpleLayers":$\!$ [datum, model, activation]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & array of any record {\PFAtp M} with \{{\PFApf weights:}$\!$ array of array of double, {\PFApf bias:}$\!$ array of double\} \\  & \PFAc activation \rm & function (double) $\to$ double \\  & {\it (returns)} & array of double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Apply a feedforward artificial neural network {\PFAp model} to an input {\PFAp datum}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Length {\PFAp d} vector of independent variables.  \\  & \PFAc model \rm & Array containing the parameters of each layer of the feedforward neural network model.  \\  & \PFAc activation \rm & Function applied at the output of each node, except the last.  Usually an ``S''-shaped sigmoid or hyperbolic tangent.  \\  & {\it (return value)} \rm & Returns an array of network outputs.  For a neural network with a single neuron in the last layer (single output), this is an array of length one. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#11000:} Raises a ``no layers'' error if the length of model is zero. \vspace{0.1 cm} \\ {\bf \#11001:} Raises a ``weights, bias, or datum misaligned'' error if there is any misalignment between inputs and outputs through the layers of the network.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    {model.svm.score}{\hypertarget{model.svm.score}{\noindent \mbox{\hspace{0.015\linewidth}} {\bf Signature:} \mbox{\PFAc \{"model.svm.score":$\!$ [datum, model, kernel]\} \vspace{0.2 cm} \\} \vspace{0.2 cm} \\ \rm \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}} & \PFAc datum \rm & array of double \\  & \PFAc model \rm & any record {\PFAtp L} with \{{\PFApf const:}$\!$ double, {\PFApf posClass:}$\!$ array of any record {\PFAtp M} with \{{\PFApf supVec:}$\!$ array of double, {\PFApf coeff:}$\!$ double\}, {\PFApf negClass:}$\!$ array of any record {\PFAtp N} with \{{\PFApf supVec:}$\!$ array of double, {\PFApf coeff:}$\!$ double\}\} \\  & \PFAc kernel \rm & function (array of double, array of double) $\to$ double \\  & {\it (returns)} & double \\  \end{tabular} \vspace{0.3 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Description:} Score an input {\PFAp datum} with a two-class support vector machine classifier given a {\PFAp model} and a kernel function {\PFAp kernel}. \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Parameters:} \vspace{0.2 cm} \\ \begin{tabular}{p{0.01\linewidth} l p{0.8\linewidth}}  & \PFAc datum \rm & Length {\PFAp d} vector of independent variables.  \\  & \PFAc model \rm & Record containing the support vectors, dual space coefficients and constant needed to score new data.  \\  & \PFAc kernel \rm & Kernel function used to map data and support vectors into the dual space.  \\  & {\it (return value)} \rm & Returns the score.  If positive, datum classified as same group as {\PFAp posClass} support vectors.  If negative, datum classified as same group as {\PFAp negClass} support vectors. \\ \end{tabular} \vspace{0.2 cm} \\ \mbox{\hspace{0.015\linewidth}} {\bf Runtime Errors:} \vspace{0.2 cm} \\ \mbox{\hspace{0.045\linewidth}} \begin{minipage}{0.935\linewidth}{\bf \#12000:} Raises a ``no support vectors'' error if the length of {\PFAp negClass} and length of {\PFAp posClass} is zero. \vspace{0.1 cm} \\ {\bf \#12001:} Raises a ``support vectors must have same length as datum'' error if the length of the support vectors is not the same as the length of {\PFAp datum}.\end{minipage} \vspace{0.2 cm} \vspace{0.2 cm} \\ }}%
    }[{\bf FIXME: LaTeX error: wrong libfcn name!}]%
}%

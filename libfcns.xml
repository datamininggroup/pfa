<PFASpecification>
  <version>0.8.1</version>
  <libfcns>
    <fcn name="+">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Add <p>x</p> and <p>y</p>.</desc><error code="18000">Integer results above or below -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error><error code="18001">Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error><detail>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or NaN values.</detail>
      </doc>
    </fcn>

    <fcn name="-">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Subtract <p>y</p> from <p>x</p>.</desc><error code="18010">Integer results above or below -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error><error code="18011">Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error><detail>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or NaN values.</detail>
      </doc>
    </fcn>

    <fcn name="*">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Multiply <p>x</p> and <p>y</p>.</desc><error code="18020">Integer results above or below -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error><error code="18021">Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error><detail>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or NaN values.</detail>
      </doc>
    </fcn>

    <fcn name="/">
      <sig>
        <par name="x">double</par>
        <par name="y">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Divide <p>y</p> from <p>x</p>, returning a floating-point number (even if <p>x</p> and <p>y</p> are integers).</desc>
        <detail>This function returns an infinite value if <p>x</p> is non-zero and <p>y</p> is zero and NaN if both are zero.</detail>
      </doc>
    </fcn>

    <fcn name="//">
      <sig>
        <par name="x"><any label="A" of="int, long"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Divide <p>y</p> from <p>x</p>, returning the largest whole number <c>N</c> for which <c>N</c> ≤ <p>x</p>/<p>y</p> (integral floor division).</desc>
        <error code="18040">If <p>y</p> is zero, this function raises a &quot;integer division by zero&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="u-">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the additive inverse of <p>x</p>.</desc>
        <error code="18050">For exactly one integer value, -2147483648, this function raises an &quot;int overflow&quot; runtime error.</error>
        <error code="18051">For exactly one long value, -9223372036854775808, this function raises a &quot;long overflow&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="%">
      <sig>
        <par name="k"><any label="A" of="int, long, float, double"/></par>
        <par name="n"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return <p>k</p> modulo <p>n</p>; the result has the same sign as the modulus <p>n</p>.</desc>
        <detail>This is the behavior of the <c>%</c> operator in Python, <c>mod</c>/<c>modulo</c> in Ada, Haskell, and Scheme.</detail>
        <error code="18060">If <p>n</p> is zero and <p>k</p> and <p>n</p> are int or long, this function raises a &quot;integer division by zero&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="%%">
      <sig>
        <par name="k"><any label="A" of="int, long, float, double"/></par>
        <par name="n"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the remainder of <p>k</p> divided by <p>n</p>; the result has the same sign as the dividend <p>k</p>.</desc>
        <detail>This is the behavior of the <c>%</c> operator in Fortran, C/C++, and Java, <c>rem</c>/<c>remainder</c> in Ada, Haskell, and Scheme.</detail>
        <error code="18070">If <p>n</p> is zero and <p>k</p> and <p>n</p> are int or long, this function raises a &quot;integer division by zero&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="**">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Raise <p>x</p> to the power <p>n</p>.</desc><error code="18080">Integer results above or below -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error><error code="18081">Long-integer results above or below -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error><detail>Float and double overflows do not produce runtime errors but result in positive or negative infinity, which would be carried through any subsequent calculations (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or NaN values.</detail>
      </doc>
    </fcn>

    <fcn name="cmp">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return <c>1</c> if <p>x</p> is greater than <p>y</p>, <c>-1</c> if <p>x</p> is less than <p>y</p>, and <c>0</c> if <p>x</p> and <p>y</p> are equal.</desc>
      </doc>
    </fcn>

    <fcn name="==">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is equal to <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="&gt;=">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is greater than or equal to <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="&gt;">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is greater than <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="!=">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is not equal to <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="&lt;">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is less than <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="&lt;=">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is less than or equal to <p>y</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="max">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return <p>x</p> if <p>x</p> ≥ <p>y</p>, <p>y</p> otherwise.</desc>
        <detail>For the maximum of more than two values, see <f>a.max</f></detail>
      </doc>
    </fcn>

    <fcn name="min">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="y"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return <p>x</p> if <p>x</p> &lt; <p>y</p>, <p>y</p> otherwise.</desc>
        <detail>For the minimum of more than two values, see <f>a.min</f></detail>
      </doc>
    </fcn>

    <fcn name="&amp;&amp;">
      <sig>
        <par name="x">boolean</par>
        <par name="y">boolean</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> and <p>y</p> are both <c>true</c>, <c>false</c> otherwise.</desc>
        <detail>If <p>x</p> is <c>false</c>, <p>y</p> won't be evaluated.  (Only relevant for arguments with side effects.)</detail>
      </doc>
    </fcn>

    <fcn name="||">
      <sig>
        <par name="x">boolean</par>
        <par name="y">boolean</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if either <p>x</p> or <p>y</p> (or both) are <c>true</c>, <c>false</c> otherwise.</desc>
        <detail>If <p>x</p> is <c>true</c>, <p>y</p> won't be evaluated.  (Only relevant for arguments with side effects.)</detail>
      </doc>
    </fcn>

    <fcn name="^^">
      <sig>
        <par name="x">boolean</par>
        <par name="y">boolean</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is <c>true</c> and <p>y</p> is <c>false</c> or if <p>x</p> is <c>false</c> and <p>y</p> is <c>true</c>, but return <c>false</c> for any other case.</desc>
      </doc>
    </fcn>

    <fcn name="!">
      <sig>
        <par name="x">boolean</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is <c>false</c> and <c>false</c> if <p>x</p> is <c>true</c>.</desc>
      </doc>
    </fcn>

    <fcn name="&amp;&amp;&amp;">
      <sig>
        <par name="x"><union>boolean</union><union>null</union></par>
        <par name="y"><union>boolean</union><union>null</union></par>
        <ret><union>boolean</union><union>null</union></ret>
      </sig>
      <doc>
        <desc>Return <c>false</c> if <p>x</p> or <p>y</p> is <c>false</c>, <c>true</c> if <p>x</p> and <p>y</p> are <c>true</c>, and <c>null</c> otherwise.</desc>
        <detail>This corresponds to Kleene's three-state logic, in which <c>null</c> represents a boolean quantity whose value is unknown.</detail>
        <detail>If <p>x</p> is <c>false</c>, <p>y</p> won't be evaluated.  (Only relevant for arguments with side effects.)</detail>
      </doc>
    </fcn>

    <fcn name="|||">
      <sig>
        <par name="x"><union>boolean</union><union>null</union></par>
        <par name="y"><union>boolean</union><union>null</union></par>
        <ret><union>boolean</union><union>null</union></ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> or <p>y</p> is <c>true</c>, <c>false</c> if both <p>x</p> and <p>y</p> is <c>false</c>, or <c>null</c> otherwise.</desc>
        <detail>This corresponds to Kleene's three-state logic, in which <c>null</c> represents a boolean quantity whose value is unknown.</detail>
        <detail>If <p>x</p> is <c>true</c>, <p>y</p> won't be evaluated.  (Only relevant for arguments with side effects.)</detail>
      </doc>
    </fcn>

    <fcn name="!!!">
      <sig>
        <par name="x"><union>boolean</union><union>null</union></par>
        <ret><union>boolean</union><union>null</union></ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is <c>false</c>, <c>false</c> if <p>x</p> is <c>true</c>, or <c>null</c> if <p>x</p> is <c>null</c>.</desc>
        <detail>This corresponds to Kleene's three-state logic, in which <c>null</c> represents a boolean quantity whose value is unknown.</detail>
      </doc>
    </fcn>

    <fcn name="&amp;">
      <sig>
        <par name="x">int</par>
        <par name="y">int</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <par name="y">long</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Calculate the bitwise-and of <p>x</p> and <p>y</p>.</desc>
      </doc>
    </fcn>

    <fcn name="|">
      <sig>
        <par name="x">int</par>
        <par name="y">int</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <par name="y">long</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Calculate the bitwise-or of <p>x</p> and <p>y</p>.</desc>
      </doc>
    </fcn>

    <fcn name="^">
      <sig>
        <par name="x">int</par>
        <par name="y">int</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <par name="y">long</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Calculate the bitwise-exclusive-or of <p>x</p> and <p>y</p>.</desc>
      </doc>
    </fcn>

    <fcn name="~">
      <sig>
        <par name="x">int</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Calculate the bitwise-not of <p>x</p>.</desc>
      </doc>
    </fcn>

    <fcn name="m.pi">
      <sig>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>The double-precision number that is closer than any other to <m>\pi</m>, the ratio of a circumference of a circle to its diameter.</desc>
      </doc>
    </fcn>

    <fcn name="m.e">
      <sig>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>The double-precision number that is closer than any other to <m>e</m>, the base of natural logarithms.</desc>
      </doc>
    </fcn>

    <fcn name="m.abs">
      <sig>
        <par name="x"><any label="A" of="int, long, float, double"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the absolute value of <p>x</p>.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
        <error code="27020">For exactly one integer value, -2147483648, this function produces an &quot;int overflow&quot; runtime error.</error>
        <error code="27021">For exactly one long value, -9223372036854775808, this function produces a &quot;long overflow&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="m.acos">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the arc-cosine (inverse of the cosine function) of <p>x</p> as an angle in radians between <m>0</m> and <m>\pi</m>.</desc><detail>The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.asin">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the arc-sine (inverse of the sine function) of <p>x</p> as an angle in radians between <m>-\pi/2</m> and <m>\pi/2</m>.</desc><detail>The domain of this function is from -1 to 1 (inclusive).  Beyond this domain, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.atan">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the arc-tangent (inverse of the tangent function) of <p>x</p> as an angle in radians between <m>-\pi/2</m> and <m>\pi/2</m>.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.atan2">
      <sig>
        <par name="y">double</par>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the arc-tangent (inverse of the tangent function) of <p>y</p>/<p>x</p> without loss of precision for small <p>x</p>.</desc><detail>The domain of this function is the whole real plane; no pair of inputs is invalid.</detail>
        <detail>Note that <p>y</p> is the first parameter and <p>x</p> is the second parameter.</detail>
      </doc>
    </fcn>

    <fcn name="m.ceil">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the smallest (closest to negative infinity, not closest to zero) whole number that is greater than or equal to the input.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.copysign">
      <sig>
        <par name="mag"><any label="A" of="int, long, float, double"/></par>
        <par name="sign"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return a number with the magnitude of <p>mag</p> and the sign of <p>sign</p>.</desc><detail>The domain of this function is the whole real or integer plane; no pair of inputs is invalid.</detail>
        <details>The return value is positive if <p>mag</p> is not zero and <p>sign</p> is zero.</details>
      </doc>
    </fcn>

    <fcn name="m.cos">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the trigonometric cosine of <p>x</p>, which is assumed to be in radians.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.cosh">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the hyperbolic cosine of <p>x</p>, which is equal to <m>\frac{e^x + e^{-x}}{2}</m></desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.exp">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return <f>m.e</f> raised to the power of <p>x</p>.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.expm1">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return <m>e^x - 1</m>.</desc><detail>Avoids round-off or overflow errors in the intermediate steps.</detail><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.floor">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the largest (closest to positive infinity) whole number that is less than or equal to the input.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.hypot">
      <sig>
        <par name="x">double</par>
        <par name="y">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return <m>\sqrt{x^2 + y^2}</m>.</desc><detail>Avoids round-off or overflow errors in the intermediate steps.</detail><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.ln">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the natural logarithm of <p>x</p>.</desc>
        <detail>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.log10">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the logarithm base 10 of <p>x</p>.</desc>
        <detail>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.log">
      <sig>
        <par name="x">double</par>
        <par name="base">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the logarithm of <p>x</p> with a given <p>base</p>.</desc>
        <detail>The domain of this function is from 0 to infinity (exclusive).  Given zero, the result is negative infinity, and below zero, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
        <error code="27170">If <p>base</p> is less than or equal to zero, this function produces a &quot;base must be positive&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="m.ln1p">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return <m>ln(x^2 + 1)</m>.</desc><detail>Avoids round-off or overflow errors in the intermediate steps.</detail>
        <detail>The domain of this function is from -1 to infinity (exclusive).  Given -1, the result is negative infinity, and below -1, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.round">
      <sig>
        <par name="x">float</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Return the closest whole number to <p>x</p>, rounding up if the fractional part is exactly one-half.</desc>
        <detail>Equal to <f>m.floor</f> of (<p>x</p> + 0.5).</detail>
        <error code="27190">Integer results outside of -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error>
        <error code="27191">Long-integer results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="m.rint">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the closest whole number to <p>x</p>, rounding toward the nearest even number if the fractional part is exactly one-half.</desc>
      </doc>
    </fcn>

    <fcn name="m.signum">
      <sig>
        <par name="x">double</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return 0 if <p>x</p> is zero, 1 if <p>x</p> is positive, and -1 if <p>x</p> is negative.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.sin">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the trigonometric sine of <p>x</p>, which is assumed to be in radians.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.sinh">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the hyperbolic sine of <p>x</p>, which is equal to <m>\frac{e^x - e^{-x}}{2}</m>.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.sqrt">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the positive square root of <p>x</p>.</desc><detail>The domain of this function is from 0 (inclusive) to infinity.  Beyond this domain, the result is <c>NaN</c>, not an exception (see IEEE 754).  Use <f>impute.ensureFinite</f> to produce errors from infinite or <c>NaN</c> values.&quot;</detail>
      </doc>
    </fcn>

    <fcn name="m.tan">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the trigonometric tangent of <p>x</p>, which is assumed to be in radians.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.tanh">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the hyperbolic tangent of <p>x</p>, which is equal to <m>\frac{e^x - e^{-x}}{e^x + e^{-x}}</m>.</desc><detail>The domain of this function is the whole real line; no input is invalid.</detail>
      </doc>
    </fcn>

    <fcn name="m.special.nChooseK">
      <sig>
        <par name="n">int</par>
        <par name="k">int</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc> The number of ways to choose <p>k</p> elements from a set of <p>n</p> elements.</desc>
          <param name="n">Total number of elements.</param>
          <param name="k">Numer of elements chosen.</param>
        <ret>With <m>n</m> and <m>k</m>, this function evaluates the binomial coefficient.</ret> 
        <error code="36000">Raises &quot;domain error&quot; if <m>k \leq 0</m> or <m>k \geq n</m>.</error>
      </doc>
    </fcn>

    <fcn name="m.special.lnBeta">
      <sig>
        <par name="a">double</par>
        <par name="b">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the beta function parameterized by <p>a</p> and <p>b</p>.</desc>
        <ret>With <m>a</m> and <m>b</m>, this function evaluates natural logarithm of the beta function. The beta function is <m>\int_{0}^{1} t^{a - 1}(1 - t)^{b - 1} dt </m>.</ret> 
        <error code="36010">Raises &quot;domain error&quot; if <m>a \leq 0</m> or if <m>b \leq 0</m>.</error>
      </doc>
    </fcn>

    <fcn name="m.special.erf">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
    <desc>Return the error function of <p>x</p>.</desc>
    </doc>
    </fcn>

    <fcn name="m.special.erfc">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the complimentary error function of <p>x</p>.</desc>
      </doc>
    </fcn>

    <fcn name="m.special.lnGamma">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the natural log of the gamma function of <p>x</p>.</desc>
      </doc>
    </fcn>

    <fcn name="m.link.softmax">
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the softmax function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>\exp(x_i)/\sum_j \exp(x_j)</m>.</ret>
        <error code="25000">If <p>x</p> is an empty array or an empty map, this function raises an &quot;empty input&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="m.link.logit">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the logit function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>1 / (1 + \exp(-x_i))</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.probit">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the probit function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>(\mbox{erf}(x_i/\sqrt{2}) + 1)/2</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.cloglog">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the cloglog function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>1 - \exp(-\exp(x_i))</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.loglog">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the loglog function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>\exp(-\exp(x_i))</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.cauchit">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the cauchit function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>0.5 + (1/\pi) \tan^{-1}(x_i)</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.softplus">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the softplus function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>\log(1.0 + \exp(x_i))</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.relu">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the rectified linear unit (ReLu) function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>\log(1.0 + \exp(x_i))</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.link.tanh">
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Normalize a prediction with the hyperbolic tangent function.</desc>
        <ret>Each element <m>x_i</m> is mapped to <m>\tanh(x_i)</m>.</ret>
      </doc>
    </fcn>

    <fcn name="m.kernel.linear">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Linear kernel function.</desc>
        <param name="x">Length <p>n</p> vector.</param>
        <param name="y">Length <p>n</p> vector.</param>
        <ret>Returns the dot product of <p>x</p> and <p>y</p>, <m>\sum_{i=1}^{n} x_{i} y_{j}</m>.</ret>
        <error code="23000">Raises a &quot;arrays must have same length&quot; error if the lengths of <p>x</p> and <p>y</p> are not the same.</error>
      </doc>
    </fcn>

    <fcn name="m.kernel.rbf">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <par name="gamma">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Radial Basis Function (RBF) kernel function.</desc>
        <param name="x">Length <p>n</p> vector.</param>
        <param name="y">Length <p>n</p> vector.</param>
        <param name="gamma">Gamma coefficient.</param>
        <ret>Returns the result of <m>\mathrm{exp}(-\gamma || x - y ||^{2})</m>.</ret>
        <error code="23010">Raises a &quot;arrays must have same length&quot; error if the lengths of <p>x</p> and <p>y</p> are not the same.</error>
      </doc>
    </fcn>

    <fcn name="m.kernel.poly">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <par name="gamma">double</par>
        <par name="intercept">double</par>
        <par name="degree">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Polynomial kernel function.</desc>
        <param name="x">Length <p>n</p> vector.</param>
        <param name="y">Length <p>n</p> vector.</param>
        <param name="gamma">Gamma coefficient.</param>
        <param name="intecept">Intercept constant.</param>
        <param name="degree">Degree of the polynomial kernel.</param>
        <ret>Returns the result of <m>(\gamma \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})^{\mathrm{degree}}</m>.</ret>
        <error code="23020">Raises a &quot;arrays must have same length&quot; error if the lengths of <p>x</p> and <p>y</p> are not the same.</error>
      </doc>
    </fcn>

    <fcn name="m.kernel.sigmoid">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <par name="gamma">double</par>
        <par name="intercept">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Sigmoid kernel function.</desc>
        <param name="x">Length <p>n</p> vector.</param>
        <param name="y">Length <p>n</p> vector.</param>
        <param name="gamma">Gamma coefficient.</param>
        <param name="intecept">Intercept constant.</param>
        <ret>Returns the result of <m>\mathrm{tanh}( \mathrm{gamma} \sum_{i=1}^{n} x_{i} y_{j} + \mathrm{intercept})</m>.</ret>
        <error code="23030">Raises a &quot;arrays must have same length&quot; error if the lengths of <p>x</p> and <p>y</p> are not the same.</error>
      </doc>
    </fcn>

    <fcn name="la.map">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="fcn">
          <function>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="fcn">
          <function>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element from <p>x</p>.</desc>
        <detail>This can be used to perform scalar multiplication on a matrix: supply a function that multiplies each element by a constant.</detail>
        <detail>The order in which elements are computed is not specified, and may be in parallel.</detail>
      </doc>
    </fcn>

    <fcn name="la.scale">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="alpha">double</par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="alpha">double</par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <par name="alpha">double</par>
        <ret><map>double</map></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="alpha">double</par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Scale vector or matrix <p>x</p> by factor <p>alpha</p>.</desc>
        <detail>The order in which elements are computed is not specified, and may be in parallel.</detail>
    </doc>
    </fcn>

    <fcn name="la.zipmap">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="y"><array><array>double</array></array></par>
        <par name="fcn">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="y"><map><map>double</map></map></par>
        <par name="fcn">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each pair of elements from <p>x</p> and <p>y</p>.</desc>
        <detail>This can be used to perform matrix addition: supply a function that adds each pair of elements.</detail>
        <detail>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and columns in <p>x</p> must be equal to the number of rows and columns of <p>y</p>, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).</detail>
        <detail>The order in which elements are computed is not specified, and may be in parallel.</detail>
        <error code="24020">In the array signature, if any element in <p>x</p> does not have a corresponding element in <p>y</p> (or vice-versa), this function raises a &quot;misaligned matrices&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.add">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="y"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <par name="y"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="y"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Add two vectors or matrices <p>x</p> and <p>y</p>.</desc>
        <detail>The order in which elements are computed is not specified, and may be in parallel.</detail>
        <detail>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in <p>x</p> must be equal to the number of rows and/or columns of <p>y</p>, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).</detail>
        <error code="24030">In the array signature, if any element in <p>x</p> does not have a corresponding element in <p>y</p> (or vice-versa), this function raises a &quot;misaligned matrices&quot; error.</error>
    </doc>
    </fcn>

    <fcn name="la.sub">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="y"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <par name="y"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="y"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Subtract vector or matrix <p>y</p> from <p>x</p> (returns <m>x - y</m>).</desc>
        <detail>The order in which elements are computed is not specified, and may be in parallel.</detail>
        <detail>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of rows and/or columns in <p>x</p> must be equal to the number of rows and/or columns of <p>y</p>, respectively (dense matrix).  In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).</detail>
        <error code="24040">In the array signature, if any element in <p>x</p> does not have a corresponding element in <p>y</p> (or vice-versa), this function raises a &quot;misaligned matrices&quot; error.</error>
    </doc>
    </fcn>

    <fcn name="la.dot">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="y"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="y"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="y"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="y"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Multiply two matrices or a matrix and a vector, which may be represented as dense arrays or potentially sparse maps.</desc>
        <detail>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, the number of columns of <p>x</p> must be equal to the number of rows (or the number of elements) of <p>y</p> (dense matrix).  In the map signature, missing values are assumed to be zero (sparse matrix).</detail>
        <detail>Matrices supplied as maps may be computed using sparse methods.</detail>
        <error code="24050">In the array signature, if the dimensions of <p>x</p> do not correspond to the dimension(s) of <p>y</p>, this function raises a &quot;misaligned matrices&quot; error.</error>
        <error code="24051">If <p>x</p> or <p>y</p> has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24052">If <p>x</p> or <p>y</p> contains any non-finite values, this function raises a &quot;contains non-finite value&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.transpose">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Transpose a rectangular matrix.</desc>
        <error code="24060">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24061">If the columns are ragged (arrays of different lengths or maps with different sets of keys), this function raises a &quot;ragged columns&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.inverse">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Compute the inverse (or Moore-Penrose pseudoinverse, if not square) of <p>x</p>.</desc>
        <error code="24070">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24071">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.trace">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the trace of a matrix (sum of diagonal elements).</desc>
        <error code="24080">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.det">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the determinant of a matrix.</desc>
        <error code="24090">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24091">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
        <error code="24092">In the array signature, if <p>x</p> is not a square matrix, this function raises a &quot;non-square matrix&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.symmetric">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="tolerance">double</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="tolerance">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determine if a matrix is symmetric withing tolerance.</desc>
        <ret>Returns <c>true</c> if the absolute value of element <m>i</m>, <m>j</m> minus element <m>j</m>, <m>i</m> is less than <p>tolerance</p>.</ret>
        <error code="24100">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24101">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
        <error code="24102">If <p>x</p> is not a square matrix, this function raises a &quot;non-square matrix&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.eigenBasis">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Compute the eigenvalues and eigenvectors of a real, symmetric matrix <p>x</p> (which are all real).</desc>
        <ret>A matrix in which each row (first level of array or map hierarchy) is a normalized eigenvector of <p>x</p> divided by the square root of the corresponding eigenvalue (The sign is chosen such that the first component is positive.).  If provided as an array, the rows are in decreasing order of eigenvalue (increasing order of inverse square root eigenvalue).  If provided as a map, the rows are keyed by string representations of integers starting with <c>&quot;0&quot;</c>, and increasing row keys are in decreasing order of eigenvalue.</ret>
        <detail>If <p>x</p> is the covariance matrix of a zero-mean dataset, the matrix that this function returns would transform the dataset to one with unit variances and zero covariances.</detail>
        <detail>If <p>x</p> is not symmetric or not exactly symmetric, it will first be symmetrized (<m>(x + x^T)/2</m>).  For example, a matrix represented by only the upper triangle (other elements are zero or missing from the map) becomes a symmetric matrix with the upper triangle unchanged.</detail>
        <nondeterministic type="unstable"/>
        <error code="24110">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24111">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
        <error code="24112">If <p>x</p> is not a square matrix, this function raises a &quot;non-square matrix&quot; error.</error>
        <error code="24113">If <p>x</p> contains non-finite values, this function raises a &quot;non-finite matrix&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="la.truncate">
      <sig>
        <par name="x"><array><array>double</array></array></par>
        <par name="keep">int</par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="x"><map><map>double</map></map></par>
        <par name="keep"><array>string</array></par>
        <ret><map><map>double</map></map></ret>
      </sig>
      <doc>
        <desc>Remove rows from a matrix so that it becomes a projection operator.</desc>
        <param name="x">The matrix to truncate.</param>
        <param name="keep">If <p>x</p> is an array, this is the number of rows to keep, starting with the first row.  If <p>x</p> is a map, this is the set of keys to keep.  If <p>keep</p> is larger than the number of rows or is not a subset of the keys, the excess is ignored.</param>
        <detail>In Principle Component Analysis (PCA), this would be applied to the eigenbasis transformation (<f>la.eigenBasis</f>) to keep only a specified number (or set) of transformed components.</detail>
        <error code="24120">If the matrix has fewer than 1 row or fewer than 1 column, this function raises a &quot;too few rows/cols&quot; error.</error>
        <error code="24121">If <p>x</p> is an array with ragged columns (arrays of different lengths), this function raises a &quot;ragged columns&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="metric.simpleEuclidean">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Euclidean metric without a special similarity function and without any handling of missing values.</desc>
        <param name="x">First sample vector.</param>
        <param name="y">Second sample vector.  (Must have the same dimension as <p>x</p>.)</param>
        <ret>Returns <m>\sqrt{\sum_i (x_i - y_i)^2}</m>.</ret>
        <error code="28000">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.absDiff">
      <sig>
        <par name="x">double</par>
        <par name="y">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Similarity function (1-dimensional metric) that returns the absolute Euclidean distance between <p>x</p> and <p>y</p>.</desc>
      </doc>
    </fcn>

    <fcn name="metric.gaussianSimilarity">
      <sig>
        <par name="x">double</par>
        <par name="y">double</par>
        <par name="sigma">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Similarity function (1-dimensional metric) that returns <m>\exp(-\ln(2) (x - y)^2 / \mbox{sigma}^2)</m>.</desc>
      </doc>
    </fcn>

    <fcn name="metric.euclidean">
      <sig>
        <par name="similarity">
          <function>
            <par><any label="A"/></par>
            <par><any label="B"/></par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union><ref label="A"/></union></array></par>
        <par name="y"><array><union>null</union><union><ref label="B"/></union></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="similarity">
          <function>
            <par><any label="A"/></par>
            <par><any label="B"/></par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union><ref label="A"/></union></array></par>
        <par name="y"><array><union>null</union><union><ref label="B"/></union></array></par>
        <par name="missingWeight"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Euclidean metric, which is the distance function for ordinary space, given by the Pythagorean formula (also known as the 2-norm).</desc>
        <param name="similarity">Similarity function (1-dimensional metric) that quantifies the distance between components of <p>x</p> and components of <p>y</p>.</param>
        <param name="x">First sample vector, which may have missing values.</param>
        <param name="y">Second sample vector, which may have missing values.  (Must have the same dimension as <p>x</p>.)</param>
        <param name="missingWeight">Optional missing-value weights: a vector with the same dimension as <p>x</p> and <p>y</p> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</param>
        <ret>With <m>I(x_i,y_i)</m> = 0 if component <m>i</m> of <p>x</p> or <p>y</p> is missing, 1 otherwise, this function returns <m>\sqrt{(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)}</m> where <m>q_i</m> are components of the missing-value weights.  Without missing values, it is <m>\sqrt{\sum_i \mbox{similarity}(x_i,y_i)^2}</m>.</ret>
        <detail>If all values are missing, the function returns <c>NaN</c>.</detail>
        <error code="28030">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.squaredEuclidean">
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <par name="missingWeight"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Euclidean metric squared, which has the same ordering as the Euclidean metric, but avoids a square root calculation.</desc>
        <param name="similarity">Similarity function (1-dimensional metric) that quantifies the distance between components of <p>x</p> and components of <p>y</p>.</param>
        <param name="x">First sample vector, which may have missing values.</param>
        <param name="y">Second sample vector, which may have missing values.  (Must have the same dimension as <p>x</p>.)</param>
        <param name="missingWeight">Optional missing-value weights: a vector with the same dimension as <p>x</p> and <p>y</p> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</param>
        <ret>With <m>I(x_i,y_i)</m> = 0 if component <m>i</m> of <p>x</p> or <p>y</p> is missing, 1 otherwise, this function returns <m>(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^2)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)</m> where <m>q_i</m> are components of the missing-value weights.  Without missing values, it is <m>\sum_i \mbox{similarity}(x_i,y_i)^2</m>.</ret>
        <detail>If all values are missing, the function returns <c>NaN</c>.</detail>
        <error code="28040">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.chebyshev">
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <par name="missingWeight"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Chebyshev metric, also known as the infinity norm or chessboard distance (since it is the number of moves required for a chess king to travel between two points).</desc>
        <param name="similarity">Similarity function (1-dimensional metric) that quantifies the distance between components of <p>x</p> and components of <p>y</p>.</param>
        <param name="x">First sample vector, which may have missing values.</param>
        <param name="y">Second sample vector, which may have missing values.  (Must have the same dimension as <p>x</p>.)</param>
        <param name="missingWeight">Optional missing-value weights: a vector with the same dimension as <p>x</p> and <p>y</p> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</param>
        <ret>With <m>I(x_i,y_i)</m> = 0 if component <m>i</m> of <p>x</p> or <p>y</p> is missing, 1 otherwise, this function returns <m>(\max_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)</m> where <m>q_i</m> are components of the missing-value weights.  Without missing values, it is <m>\max_i \mbox{similarity}(x_i,y_i)</m>.</ret>
        <detail>If all values are missing, the function returns <c>NaN</c>.</detail>
        <error code="28050">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.taxicab">
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <par name="missingWeight"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Taxicab metric, also known as the 1-norm, city-block or Manhattan distance (since it is the distance when confined to a rectilinear city grid).</desc>
        <param name="similarity">Similarity function (1-dimensional metric) that quantifies the distance between components of <p>x</p> and components of <p>y</p>.</param>
        <param name="x">First sample vector, which may have missing values.</param>
        <param name="y">Second sample vector, which may have missing values.  (Must have the same dimension as <p>x</p>.)</param>
        <param name="missingWeight">Optional missing-value weights: a vector with the same dimension as <p>x</p> and <p>y</p> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</param>
        <ret>With <m>I(x_i,y_i)</m> = 0 if component <m>i</m> of <p>x</p> or <p>y</p> is missing, 1 otherwise, this function returns <m>(\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i))(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i)</m> where <m>q_i</m> are components of the missing-value weights.  Without missing values, it is <m>\sum_i \mbox{similarity}(x_i,y_i)</m>.</ret>
        <error code="28060">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
        <detail>If all values are missing, the function returns <c>NaN</c>.</detail>
      </doc>
    </fcn>

    <fcn name="metric.minkowski">
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <par name="p">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="similarity">
          <function>
            <par>double</par>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <par name="x"><array><union>null</union><union>double</union></array></par>
        <par name="y"><array><union>null</union><union>double</union></array></par>
        <par name="p">double</par>
        <par name="missingWeight"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Minkowski metric, also known as the p-norm, a generalized norm whose limits include Euclidean, Chebyshev, and Taxicab.</desc>
        <param name="similarity">Similarity function (1-dimensional metric) that quantifies the distance between components of <p>x</p> and components of <p>y</p>.</param>
        <param name="x">First sample vector, which may have missing values.</param>
        <param name="y">Second sample vector, which may have missing values.  (Must have the same dimension as <p>x</p>.)</param>
        <param name="missingWeight">Optional missing-value weights: a vector with the same dimension as <p>x</p> and <p>y</p> that determines the normalized contribution of missing values in the sum.  If not provided, missing-value weights of 1.0 are assumed.</param>
        <ret>With <m>I(x_i,y_i)</m> = 0 if component <m>i</m> of <p>x</p> or <p>y</p> is missing, 1 otherwise, this function returns <m>((\sum_i I(x_i,y_i) \mbox{similarity}(x_i,y_i)^p)(\sum_i q_i)/(\sum_i I(x_i,y_i) q_i))^{1/p}</m> where <m>q_i</m> are components of the missing-value weights.  Without missing values, it is <m>(\sum_i \mbox{similarity}(x_i,y_i)^p)^{1/p}</m>.</ret>
        <error code="28070">Raises &quot;dimensions of vectors do not match&quot; if all vectors do not have the same dimension.</error>
        <error code="28071">Raises &quot;Minkowski parameter p must be positive&quot; if <p>p</p> is less than or equal to zero.</error>
        <detail>If all values are missing, the function returns <c>NaN</c>.</detail>
        <detail>If <p>p</p> is positive infinity, this function is equivalent to <f>metric.chebyshev</f>.</detail>
      </doc>
    </fcn>

    <fcn name="metric.simpleMatching">
      <sig>
        <par name="x"><array>boolean</array></par>
        <par name="y"><array>boolean</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Simple metric on binary vectors.</desc>
        <param name="x">First sample vector.</param>
        <param name="y">Second sample vector.  (Must have the same dimension as <p>x</p>.)</param>
        <ret>Where <m>a_{11}</m> is the number of <p>x</p>, <p>y</p> coordinate pairs that are equal to <c>true, true</c>, <m>a_{10}</m> is the number of <c>true, false</c>, <m>a_{01}</m> is the number of <c>false, true</c>, and <m>a_{00}</m> is the number of <c>false, false</c>, this function returns <m>(a_{11} + a_{00})/(a_{11} + a_{10} + a_{01} + a_{00})</m>.</ret>
        <error code="28080">Raises &quot;dimensions of vectors do not match&quot; if <p>x</p> and <p>y</p> do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.jaccard">
      <sig>
        <par name="x"><array>boolean</array></par>
        <par name="y"><array>boolean</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Jaccard similarity of binary vectors.</desc>
        <param name="x">First sample vector.</param>
        <param name="y">Second sample vector.  (Must have the same dimension as <p>x</p>.)</param>
        <ret>Where <m>a_{11}</m> is the number of <p>x</p>, <p>y</p> coordinate pairs that are equal to <c>true, true</c>, <m>a_{10}</m> is the number of <c>true, false</c>, <m>a_{01}</m> is the number of <c>false, true</c>, and <m>a_{00}</m> is the number of <c>false, false</c>, this function returns <m>a_{11}/(a_{11} + a_{10} + a_{01})</m>.</ret>
        <error code="28090">Raises &quot;dimensions of vectors do not match&quot; if <p>x</p> and <p>y</p> do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.tanimoto">
      <sig>
        <par name="x"><array>boolean</array></par>
        <par name="y"><array>boolean</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Tanimoto similarity of binary vectors.</desc>
        <param name="x">First sample vector.</param>
        <param name="y">Second sample vector.  (Must have the same dimension as <p>x</p>.)</param>
        <ret>Where <m>a_{11}</m> is the number of <p>x</p>, <p>y</p> coordinate pairs that are equal to <c>true, true</c>, <m>a_{10}</m> is the number of <c>true, false</c>, <m>a_{01}</m> is the number of <c>false, true</c>, and <m>a_{00}</m> is the number of <c>false, false</c>, this function returns <m>(a_{11} + a_{00})/(a_{11} + 2*(a_{10} + a_{01}) + a_{00})</m>.</ret>
        <error code="28100">Raises &quot;dimensions of vectors do not match&quot; if <p>x</p> and <p>y</p> do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="metric.binarySimilarity">
      <sig>
        <par name="x"><array>boolean</array></par>
        <par name="y"><array>boolean</array></par>
        <par name="c00">double</par>
        <par name="c01">double</par>
        <par name="c10">double</par>
        <par name="c11">double</par>
        <par name="d00">double</par>
        <par name="d01">double</par>
        <par name="d10">double</par>
        <par name="d11">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Genaralized similarity of binary vectors, using <p>c00</p>, <p>c01</p>, <p>c10</p>, <p>c11</p>, <p>d00</p>, <p>d01</p>, <p>d10</p>, and <p>d11</p> as parameters to reproduce all other binary similarity metrics.</desc>
        <param name="x">First sample vector.</param>
        <param name="y">Second sample vector.  (Must have the same dimension as <p>x</p>.)</param>
        <ret>Where <m>a_{11}</m> is the number of <p>x</p>, <p>y</p> coordinate pairs that are equal to <c>true, true</c>, <m>a_{10}</m> is the number of <c>true, false</c>, <m>a_{01}</m> is the number of <c>false, true</c>, and <m>a_{00}</m> is the number of <c>false, false</c>, this function returns <m>(c_{11}a_{11} + c_{10}a_{10} + c_{01}a_{01} + c_{00}a_{00})/(d_{11}a_{11} + d_{10}a_{10} + d_{01}a_{01} + d_{00}a_{00})</m>.</ret>
        <error code="28110">Raises &quot;dimensions of vectors do not match&quot; if <p>x</p> and <p>y</p> do not have the same dimension.</error>
      </doc>
    </fcn>

    <fcn name="rand.int">
      <sig>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="low">int</par>
        <par name="high">int</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return a random integer, either on the entire entire 32-bit range or between <p>low</p> (inclusive) and <p>high</p> (exclusive).</desc>
        <error code="34000">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.long">
      <sig>
        <ret>long</ret>
      </sig>
      <sig>
        <par name="low">long</par>
        <par name="high">long</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Return a random long integer, either on the entire 64-bit range or between <p>low</p> (inclusive) and <p>high</p> (exclusive).</desc>
        <error code="34010">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.float">
      <sig>
        <par name="low">float</par>
        <par name="high">float</par>
        <ret>float</ret>
      </sig>
      <doc>
        <desc>Return a random float between <p>low</p> and <p>high</p>.</desc>
        <error code="34020">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.double">
      <sig>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return a random double between <p>low</p> and <p>high</p>.</desc>
        <error code="34030">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.choice">
      <sig>
        <par name="population"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return a random item from a bag of items.</desc>
        <error code="34040">Raises a &quot;population must not be empty&quot; error if <p>population</p> is empty.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.choices">
      <sig>
        <par name="size">int</par>
        <par name="population"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array of random items (with replacement) from a bag of items.</desc>
        <error code="34050">Raises a &quot;population must not be empty&quot; error if <p>population</p> is empty.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.sample">
      <sig>
        <par name="size">int</par>
        <par name="population"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array of random items (without replacement) from a bag of items.</desc>
        <error code="34060">Raises a &quot;population must not be empty&quot; error if <p>population</p> is empty.</error>
        <error code="34061">Raises a &quot;population smaller than requested subsample&quot; error if the size of <p>population</p> is less than <p>size</p>.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.histogram">
      <sig>
        <par name="distribution"><array>double</array></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="distribution"><array><record label="A"><field name="prob">double</field></record></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return a random index of <p>distribution</p> with probability proportional to the value of that index or a random item from <p>distribution</p> with probability proportional to the <pf>prob</pf> field.</desc>
        <detail>If the probabilities do not sum to 1.0, they will be normalized first.</detail>
        <error code="34070">Raises a &quot;distribution must be non-empty&quot; error if no items of <p>distribution</p> are non-zero.</error>
        <error code="34071">Raises a &quot;distribution must be finite&quot; error if any items of <p>distribution</p> are infinite or <c>NaN</c>.</error>
        <error code="34072">Raises a &quot;distribution must be non-negative&quot; error if any items of <p>distribution</p> are negative.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.string">
      <sig>
        <par name="size">int</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="size">int</par>
        <par name="population">string</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="size">int</par>
        <par name="low">int</par>
        <par name="high">int</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return a random string with <p>size</p> characters from a range, if provided.</desc>
        <param name="size">Number of characters in the resulting string.</param>
        <param name="population">Bag of characters to choose from.  Characters repeated <m>N</m> times in the <p>population</p> have probability <m>N</m>/<p>size</p>, but order is irrelevant.</param>
        <param name="low">Minimum code-point to sample (inclusive).</param>
        <param name="high">Maximum code-point to sample (exclusive).</param>
        <detail>Without a range, this function samples the entire Unicode table up to and including <c>0xD800</c>; ASCII characters are rare.</detail>
        <detail>The ASCII printable range is <p>low</p> = 33, <p>high</p> = 127.</detail>
        <error code="34080">Raises a &quot;size must be positive&quot; error if <p>size</p> is less than or equal to zero.</error>
        <error code="34081">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <error code="34082">Raises an &quot;invalid char&quot; error if <p>low</p> is less than 1 or greater than <c>0xD800</c> or if <p>high</p> is less than 1 or greater than <c>0xD800</c>.</error>
        <error code="34083">Raises an &quot;population must be non-empty&quot; error if <p>population</p> is empty.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.bytes">
      <sig>
        <par name="size">int</par>
        <ret>bytes</ret>
      </sig>
      <sig>
        <par name="size">int</par>
        <par name="population">bytes</par>
        <ret>bytes</ret>
      </sig>
      <sig>
        <par name="size">int</par>
        <par name="low">int</par>
        <par name="high">int</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Return <p>size</p> random bytes from a range, if provided.</desc>
        <param name="size">Number of bytes in the result.</param>
        <param name="population">Bag of bytes to choose from.  Bytes repeated <m>N</m> times in the <p>population</p> have probability <m>N</m>/<p>size</p>, but order is irrelevant.</param>
        <param name="low">Minimum byte value to sample (inclusive).</param>
        <param name="high">Maximum byte value to sample (exclusive).</param>
        <error code="34090">Raises a &quot;size must be positive&quot; error if <p>size</p> is less than or equal to zero.</error>
        <error code="34091">Raises a &quot;high must be greater than low&quot; error if <p>high</p> is less than or equal to <p>low</p>.</error>
        <error code="34092">Raises an &quot;invalid byte&quot; error if <p>low</p> is less than 0 or greater than 255 or if <p>high</p> is less than 0 or greater than 256.</error>
        <error code="34093">Raises an &quot;population must be non-empty&quot; error if <p>population</p> is empty.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.uuid">
      <sig contingency="use rand.uuid4 instead" death="0.9.0" deprecation="0.7.2">
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return a random (type 4) UUID with IETF variant (8).</desc>
        <ret>The return value is a string with the form <c>xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx</c> where <c>x</c> are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant.</ret>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.uuid4">
      <sig>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return a random (type 4) UUID with IETF variant (8).</desc>
        <ret>The return value is a string with the form <c>xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx</c> where <c>x</c> are random, lowercase hexidecimal digits (0-9a-f), 4 is the version, and 8 is the IETF variant.</ret>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="rand.gaussian">
      <sig>
        <par name="mu">double</par>
        <par name="sigma">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return a random number from a Gaussian (normal) distribution with mean <p>mu</p> and standard deviation <p>sigma</p>.</desc>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="s.len">
      <sig>
        <par name="s">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the length of string <p>s</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.substr">
      <sig>
        <par name="s">string</par>
        <par name="start">int</par>
        <par name="end">int</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the substring of <p>s</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive).</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail>
      </doc>
    </fcn>

    <fcn name="s.substrto">
      <sig>
        <par name="s">string</par>
        <par name="start">int</par>
        <par name="end">int</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Replace <p>s</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive) with <p>replacement</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail>
      </doc>
    </fcn>

    <fcn name="s.contains">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>haystack</p> contains <p>needle</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="s.count">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Count the number of times <p>needle</p> appears in <p>haystack</p>.</desc>
        <detail>If the <p>needle</p> is an empty string, the result is zero.</detail>
      </doc>
    </fcn>

    <fcn name="s.index">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the lowest index where <p>haystack</p> contains <p>needle</p> or -1 if <p>haystack</p> does not contain <p>needle</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.rindex">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the highest index where <p>haystack</p> contains <p>needle</p> or -1 if <p>haystack</p> does not contain <p>needle</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.startswith">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the first (leftmost) subseqence of <p>haystack</p> is equal to <p>needle</p>, false otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="s.endswith">
      <sig>
        <par name="haystack">string</par>
        <par name="needle">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the last (rightmost) subseqence of <p>haystack</p> is equal to <p>needle</p>, false otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="s.join">
      <sig>
        <par name="array"><array>string</array></par>
        <par name="sep">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Combine strings from <p>array</p> into a single string, delimited by <p>sep</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.split">
      <sig>
        <par name="s">string</par>
        <par name="sep">string</par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Divide a string into an array of substrings, splitting at and removing delimiters <p>sep</p>.</desc>
        <detail>If <p>s</p> does not contain <p>sep</p>, this function returns an array whose only element is <p>s</p>.  If <p>sep</p> appears at the beginning or end of <p>s</p>, the array begins with or ends with an empty string.  These conventions match Python's behavior. </detail>
        <detail>If <p>sep</p> is an empty string, this function returns an empty array.</detail>
      </doc>
    </fcn>

    <fcn name="s.hex">
      <sig>
        <par name="x">long</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <par name="width">int</par>
        <par name="zeroPad">boolean</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Format an unsigned number as a hexidecimal string.</desc>
        <param name="x">The number.</param>
        <param name="width">Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.</param>
        <param name="zeroPad">If true, pad the integer with zeros to fill up to <p>width</p>.</param>
        <detail>If the <p>precision</p> requires more space than <p>width</p>, the string will be wide enough to accommodate the <p>precision</p>.</detail>
        <detail>Digits &quot;a&quot; (decimal 10) through &quot;f&quot; (decimal 15) are represented by lowercase letters.</detail>
        <error code="39110">If <p>width</p> is negative and <p>zeroPad</p> is <c>true</c>, a &quot;negative width cannot be used with zero-padding&quot; error is raised.</error>
        <error code="39111">If <p>x</p> is negative, a &quot;negative number&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="s.int">
      <sig>
        <par name="x">long</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <par name="width">int</par>
        <par name="zeroPad">boolean</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Format an integer as a decimal string.</desc>
        <param name="x">The integer.</param>
        <param name="width">Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide enough precision.</param>
        <param name="zeroPad">If true, pad the integer with zeros to fill up to <p>width</p>.</param>
        <error code="39240">If <p>width</p> is negative and <p>zeroPad</p> is <c>true</c>, a &quot;negative width cannot be used with zero-padding&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="s.number">
      <sig contingency="use s.int for integers" death="0.9.0" deprecation="0.7.2">
        <par name="x">long</par>
        <ret>string</ret>
      </sig>
      <sig contingency="use s.int for integers" death="0.9.0" deprecation="0.7.2">
        <par name="x">long</par>
        <par name="width">int</par>
        <par name="zeroPad">boolean</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="width"><union>int</union><union>null</union></par>
        <par name="precision"><union>int</union><union>null</union></par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="width"><union>int</union><union>null</union></par>
        <par name="precision"><union>int</union><union>null</union></par>
        <par name="minNoExp">double</par>
        <par name="maxNoExp">double</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Format a number as a decimal string.</desc>
        <param name="x">The number.  Note that different signatures apply to integers and floating point numbers.</param>
        <param name="width">Width of the string.  If negative, left-justify.  If omitted, the string will be as wide as it needs to be to provide the precision.</param>
        <param name="zeroPad">If true, pad the integer with zeros to fill up to <p>width</p>.</param>
        <param name="precision">Optional precision with which to represent the number.  If omitted, at most six digits after the decimal point will be shown, unless they are zero.</param>
        <param name="minNoExp">Minimum absolute value that is not presented in scientific notation; 0.0001 if omitted.</param>
        <param name="maxNoExp">Maxiumum absolute value that is not presented in scientific notation; 100000 if omitted.</param>
        <detail>If the <p>precision</p> requires more space than <p>width</p>, the string will be wide enough to accommodate the <p>precision</p>.</detail>
        <detail>Floating point numbers always have a decimal point with at least one digit after the decimal, even if it is zero.</detail>
        <detail>Exponents are represented by a lowercase &quot;e&quot; which is always followed by a sign, whether positive or negative, and an exponent of two or more digits (single-digit exponents are zero-padded).</detail>
        <detail>The base of a number is preceded by a &quot;-&quot; if negative, but not a &quot;+&quot; if positive.</detail>
        <detail>Special floating point values are represented in the following ways: negative zero as zero (no negative sign), not a number as &quot;nan&quot;, positive infinity as &quot;inf&quot;, and negative infinity as &quot;-inf&quot; (lowercase).  They follow the same precision and width rules as normal numbers, where applicable.</detail>
        <nondeterministic type="unstable"/>
        <error code="39120">If <p>width</p> is negative and <p>zeroPad</p> is <c>true</c>, a &quot;negative width cannot be used with zero-padding&quot; error is raised.</error>
        <error code="39121">If <p>precision</p> is provided and is less than zero, a &quot;negative precision&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="s.concat">
      <sig>
        <par name="x">string</par>
        <par name="y">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Append <p>y</p> to <p>x</p> to form a single string.</desc>
        <detail>To concatenate an array of strings, use s.join with an empty string as <p>sep</p>.</detail>
      </doc>
    </fcn>

    <fcn name="s.repeat">
      <sig>
        <par name="s">string</par>
        <par name="n">int</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Create a string by concatenating <p>s</p> with itself <p>n</p> times.</desc>
      </doc>
    </fcn>

    <fcn name="s.lower">
      <sig>
        <par name="s">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Convert <p>s</p> to lower-case.</desc>
      </doc>
    </fcn>

    <fcn name="s.upper">
      <sig>
        <par name="s">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Convert <p>s</p> to upper-case.</desc>
      </doc>
    </fcn>

    <fcn name="s.lstrip">
      <sig>
        <par name="s">string</par>
        <par name="chars">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Remove any characters found in <p>chars</p> from the beginning (left) of <p>s</p>.</desc><detail>The order of characters in <p>chars</p> is irrelevant.</detail>
      </doc>
    </fcn>

    <fcn name="s.rstrip">
      <sig>
        <par name="s">string</par>
        <par name="chars">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Remove any characters found in <p>chars</p> from the end (right) of <p>s</p>.</desc><detail>The order of characters in <p>chars</p> is irrelevant.</detail>
      </doc>
    </fcn>

    <fcn name="s.strip">
      <sig>
        <par name="s">string</par>
        <par name="chars">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Remove any characters found in <p>chars</p> from the beginning or end of <p>s</p>.</desc><detail>The order of characters in <p>chars</p> is irrelevant.</detail>
      </doc>
    </fcn>

    <fcn name="s.replaceall">
      <sig>
        <par name="s">string</par>
        <par name="original">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Replace every instance of the substring <p>original</p> from <p>s</p> with <p>replacement</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.replacefirst">
      <sig>
        <par name="s">string</par>
        <par name="original">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Replace the first (leftmost) instance of the substring <p>original</p> from <p>s</p> with <p>replacement</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.replacelast">
      <sig>
        <par name="s">string</par>
        <par name="original">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Replace the last (rightmost) instance of the substring <p>original</p> from <p>s</p> with <p>replacement</p>.</desc>
      </doc>
    </fcn>

    <fcn name="s.translate">
      <sig>
        <par name="s">string</par>
        <par name="oldchars">string</par>
        <par name="newchars">string</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>For each character in <p>s</p> that is also in <p>oldchars</p> with some index <c>i</c>, replace it with the character at index <c>i</c> in <p>newchars</p>.  Any character in <p>s</p> that is not in <p>oldchars</p> is unchanged.  Any index <c>i</c> that is greater than the length of <p>newchars</p> is replaced with nothing.</desc>
        <detail>This is the behavior of the the Posix command <c>tr</c>, where <p>s</p> takes the place of standard input and <p>oldchars</p> and <p>newchars</p> are the <c>tr</c> commandline options.</detail>
      </doc>
    </fcn>

    <fcn name="re.index">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array>int</array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the indices in <p>haystack</p> of the begining and end of the first match defined by <p>pattern</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35000">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.contains">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return true if <p>pattern</p> matches anywhere within <p>haystack</p>, otherwise return false. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35010">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.count">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Count the number of times <p>pattern</p> matches in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35020">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.rindex">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array>int</array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the location indices of the last <p>pattern</p> match in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35030">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.groups">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array><array>int</array></array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array><array>int</array></array></ret>
      </sig>
      <doc>
        <desc>Return the location indices of each <p>pattern</p> sub-match (group-match) in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35040">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.indexall">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array><array>int</array></array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array><array>int</array></array></ret>
      </sig>
      <doc>
        <desc>Return the location indices of every <p>pattern</p> match in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35050">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.findall">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array>string</array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array>bytes</array></ret>
      </sig>
      <doc>
        <desc>Return an array containing each string that <p>pattern</p> matched in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35060">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.findfirst">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><union>string</union><union>null</union></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><union>bytes</union><union>null</union></ret>
      </sig>
      <doc>
       <desc>Return the first occurance of what <p>pattern</p> matched in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35070">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
     </doc>
    </fcn>

    <fcn name="re.findgroupsfirst">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array>string</array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array>bytes</array></ret>
      </sig>
      <doc>
        <desc>Return an array of strings or bytes for each <p>pattern</p> sub-match (group-match) at the first occurance of <p>pattern</p> in <p>haystack</p>. Regular expressions follow the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35080">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.findgroupsall">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array><array>string</array></array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array><array>bytes</array></array></ret>
      </sig>
      <doc>
       <desc>Return an array of strings or bytes for each <p>pattern</p> sub-match (group-match) at every occurance of <p>pattern</p> in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35090">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.groupsall">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array><array><array>int</array></array></array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array><array><array>int</array></array></array></ret>
      </sig>
      <doc>
        <desc>Return the location indices of each <p>pattern</p> sub-match (group-match) for each occurance of <p>pattern</p> in <p>haystack</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35100">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.replacefirst">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <par name="replacement">bytes</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Replace the first <p>pattern</p> match in <p>haystack</p> with <p>replacement</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35110">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.replacelast">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <par name="replacement">bytes</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Replace the last <p>pattern</p> match in <p>haystack</p> with <p>replacement</p>.</desc>
        <error code="35120">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.split">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <ret><array>string</array></ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <ret><array>bytes</array></ret>
      </sig>
      <doc>
        <desc>Break <p>haystack</p> into an array of strings or bytes on the separator defined by <p>pattern</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35130">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="re.replaceall">
      <sig>
        <par name="haystack">string</par>
        <par name="pattern">string</par>
        <par name="replacement">string</par>
        <ret>string</ret>
      </sig>
      <sig>
        <par name="haystack">bytes</par>
        <par name="pattern">bytes</par>
        <par name="replacement">bytes</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Replace the all <p>pattern</p> matches in <p>haystack</p> with <p>replacement</p>. The regular expression follows the POSIX extended standard (like <p>grep -e</p> in Linux and UNIX).</desc>
        <error code="35140">If <p>pattern</p> is not a valid regular expression, a &quot;bad pattern&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="parse.int">
      <sig>
        <par name="str">string</par>
        <par name="base">int</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Parse <p>str</p> and return its value as an integer with base <p>base</p>, if possible.</desc>
        <detail>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</detail>
        <detail>Leading or trailing whitespace and any capitalization is allowed.</detail>
        <error code="33000">Raises &quot;not an integer&quot; if the string does not conform to &quot;<c>[-+]?[0-9a-z]+</c>&quot; or the number it evaluates to is too large to represent as a 32-bit integer or uses characters as large as or larger than <p>base</p> ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35).</error>
        <error code="33001">Raises &quot;base out of range&quot; if <p>base</p> is less than 2 or greater than 36.</error>
      </doc>
    </fcn>

    <fcn name="parse.long">
      <sig>
        <par name="str">string</par>
        <par name="base">int</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Parse <p>str</p> and return its value as a long integer with base <p>base</p>, if possible.</desc>
        <detail>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</detail>
        <detail>Leading or trailing whitespace and any capitalization is allowed.</detail>
        <error code="33010">Raises &quot;not a long integer&quot; if the string does not conform to &quot;<c>[-+]?[0-9a-z]+</c>&quot; or the number it evaluates to is too large to represent as a 64-bit integer or uses characters as large as or larger than <p>base</p> ('0' through '9' encode 0 through 9 and 'a' through 'z' encode 10 through 35).</error>
        <error code="33011">Raises &quot;base out of range&quot; if <p>base</p> is less than 2 or greater than 36.</error>
      </doc>
    </fcn>

    <fcn name="parse.float">
      <sig>
        <par name="str">string</par>
        <ret>float</ret>
      </sig>
      <doc>
        <desc>Parse <p>str</p> and return its value as a single-precision floating point number.</desc>
        <detail>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</detail>
        <detail>If the string is &quot;nan&quot;, the resulting value is not-a-number and if the string is &quot;inf&quot;, &quot;+inf&quot;, or &quot;-inf&quot;, the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754).</detail>
        <detail>If the number's magnitude is too large to be represented as a single-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a single-precision float, the resulting value is zero.</detail>
        <detail>Leading or trailing whitespace and any capitalization is allowed.</detail>
        <error code="33020">Raises &quot;not a single-precision float&quot; if the string does not conform to &quot;<c>[-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?</c>&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot;-inf&quot;, or &quot;nan&quot;.</error>
      </doc>
    </fcn>

    <fcn name="parse.double">
      <sig>
        <par name="str">string</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Parse <p>str</p> and return its value as a double-precision floating point number.</desc>
        <detail>The string is interpreted as though leading and trailing whitespace were removed and is case-insensitive.</detail>
        <detail>If the string is &quot;nan&quot;, the resulting value is not-a-number and if the string is &quot;inf&quot;, &quot;+inf&quot;, or &quot;-inf&quot;, the resulting value is positive infinity, positive infinity, or negative infinity, respectively (see IEEE 754).</detail>
        <detail>If the number's magnitude is too large to be represented as a double-precision float, the resulting value is positive or negative infinity (depending on the sign).  If the numbers magnitude is too small to be represented as a double-precision float, the resulting value is zero.</detail>
        <detail>Leading or trailing whitespace and any capitalization is allowed.</detail>
        <error code="33030">Raises &quot;not a double-precision float&quot; if the string does not conform to &quot;<c>[-+]?(\\.?[0-9]+|[0-9]+\\.[0-9]*)([eE][-+]?[0-9]+)?</c>&quot;, &quot;inf&quot;, &quot;+inf&quot;, &quot;-inf&quot;, or &quot;nan&quot;.</error>
      </doc>
    </fcn>

    <fcn name="cast.signed">
      <sig>
        <par name="x">long</par>
        <par name="bits">int</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Truncate <p>x</p> as though its signed long two's complement representation were inserted, bit-for-bit, into a signed two's complement representation that is <p>bits</p> wide, removing the most significant bits.</desc>
        <detail>The result of this function may be negative, zero, or positive.</detail>
        <error code="17000">If <p>bits</p> is less than 2 or greater than 64, an &quot;unrepresentable unsigned number&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="cast.unsigned">
      <sig>
        <par name="x">long</par>
        <par name="bits">int</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Truncate <p>x</p> as though its signed long two's complement representation were inserted, bit-for-bit, into an unsigned register that is <p>bits</p> wide, removing the most significant bits.</desc>
        <detail>The result of this function is always nonnegative.</detail>
        <error code="17010">If <p>bits</p> is less than 1 or greater than 63, an &quot;unrepresentable unsigned number&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="cast.int">
      <sig>
        <par name="x">int</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">float</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Cast <p>x</p> to an integer, rounding if necessary.</desc>
        <error code="17020">Results outside of -2147483648 and 2147483647 (inclusive) produce an &quot;int overflow&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.long">
      <sig>
        <par name="x">int</par>
        <ret>long</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <ret>long</ret>
      </sig>
      <sig>
        <par name="x">float</par>
        <ret>long</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>long</ret>
      </sig>
      <doc>
        <desc>Cast <p>x</p> to a 64-bit integer, rounding if necessary.</desc>
        <error code="17030">Results outside of -9223372036854775808 and 9223372036854775807 (inclusive) produce a &quot;long overflow&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.float">
      <sig>
        <par name="x">int</par>
        <ret>float</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <ret>float</ret>
      </sig>
      <sig>
        <par name="x">float</par>
        <ret>float</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>float</ret>
      </sig>
      <doc>
        <desc>Cast <p>x</p> to a single-precision floating point number, rounding if necessary.</desc>
      </doc>
    </fcn>

    <fcn name="cast.double">
      <sig>
        <par name="x">int</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">long</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">float</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Cast <p>x</p> to a double-precision floating point number.</desc>
      </doc>
    </fcn>

    <fcn name="cast.fanoutBoolean">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret><array>boolean</array></ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <par name="dictionary"><array>string</array></par>
        <par name="outOfRange">boolean</par>
        <ret><array>boolean</array></ret>
      </sig>
      <sig>
        <par name="x">int</par>
        <par name="minimum">int</par>
        <par name="maximum">int</par>
        <par name="outOfRange">boolean</par>
        <ret><array>boolean</array></ret>
      </sig>
      <doc>
        <desc>Fanout <p>x</p> to an array of booleans, all <c>false</c> except the matching value.</desc>
        <param name="x">Categorical datum</param>
        <param name="dictionary">Possible values of <p>x</p>, which is needed if <p>x</p> is an arbitrary string.</param>
        <param name="minimum">Inclusive minimum value of <p>x</p>.</param>
        <param name="maximum">Excluded maximum value of <p>x</p>.</param>
        <param name="outOfRange">If <c>true</c>, include an extra item in the output to represent values of <p>x</p> that are outside of the specified range.</param>
        <error code="17060">If not all values in <p>dictionary</p> are unique, this function raises a &quot;non-distinct values in dictionary&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.fanoutInt">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret><array>int</array></ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <par name="dictionary"><array>string</array></par>
        <par name="outOfRange">boolean</par>
        <ret><array>int</array></ret>
      </sig>
      <sig>
        <par name="x">int</par>
        <par name="minimum">int</par>
        <par name="maximum">int</par>
        <par name="outOfRange">boolean</par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Fanout <p>x</p> to an array of booleans, all <c>false</c> except the matching value.</desc>
        <param name="x">Categorical datum</param>
        <param name="dictionary">Possible values of <p>x</p>, which is needed if <p>x</p> is an arbitrary string.</param>
        <param name="minimum">Inclusive minimum value of <p>x</p>.</param>
        <param name="maximum">Excluded maximum value of <p>x</p>.</param>
        <param name="outOfRange">If <c>true</c>, include an extra item in the output to represent values of <p>x</p> that are outside of the specified range.</param>
        <error code="17070">If not all values in <p>dictionary</p> are unique, this function raises a &quot;non-distinct values in dictionary&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.fanoutLong">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret><array>long</array></ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <par name="dictionary"><array>string</array></par>
        <par name="outOfRange">boolean</par>
        <ret><array>long</array></ret>
      </sig>
      <sig>
        <par name="x">int</par>
        <par name="minimum">int</par>
        <par name="maximum">int</par>
        <par name="outOfRange">boolean</par>
        <ret><array>long</array></ret>
      </sig>
      <doc>
        <desc>Fanout <p>x</p> to an array of booleans, all <c>false</c> except the matching value.</desc>
        <param name="x">Categorical datum</param>
        <param name="dictionary">Possible values of <p>x</p>, which is needed if <p>x</p> is an arbitrary string.</param>
        <param name="minimum">Inclusive minimum value of <p>x</p>.</param>
        <param name="maximum">Excluded maximum value of <p>x</p>.</param>
        <param name="outOfRange">If <c>true</c>, include an extra item in the output to represent values of <p>x</p> that are outside of the specified range.</param>
        <error code="17080">If not all values in <p>dictionary</p> are unique, this function raises a &quot;non-distinct values in dictionary&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.fanoutFloat">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret><array>float</array></ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <par name="dictionary"><array>string</array></par>
        <par name="outOfRange">boolean</par>
        <ret><array>float</array></ret>
      </sig>
      <sig>
        <par name="x">int</par>
        <par name="minimum">int</par>
        <par name="maximum">int</par>
        <par name="outOfRange">boolean</par>
        <ret><array>float</array></ret>
      </sig>
      <doc>
        <desc>Fanout <p>x</p> to an array of booleans, all <c>false</c> except the matching value.</desc>
        <param name="x">Categorical datum</param>
        <param name="dictionary">Possible values of <p>x</p>, which is needed if <p>x</p> is an arbitrary string.</param>
        <param name="minimum">Inclusive minimum value of <p>x</p>.</param>
        <param name="maximum">Excluded maximum value of <p>x</p>.</param>
        <param name="outOfRange">If <c>true</c>, include an extra item in the output to represent values of <p>x</p> that are outside of the specified range.</param>
        <error code="17090">If not all values in <p>dictionary</p> are unique, this function raises a &quot;non-distinct values in dictionary&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.fanoutDouble">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <par name="dictionary"><array>string</array></par>
        <par name="outOfRange">boolean</par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x">int</par>
        <par name="minimum">int</par>
        <par name="maximum">int</par>
        <par name="outOfRange">boolean</par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Fanout <p>x</p> to an array of booleans, all <c>false</c> except the matching value.</desc>
        <param name="x">Categorical datum</param>
        <param name="dictionary">Possible values of <p>x</p>, which is needed if <p>x</p> is an arbitrary string.</param>
        <param name="minimum">Inclusive minimum value of <p>x</p>.</param>
        <param name="maximum">Excluded maximum value of <p>x</p>.</param>
        <param name="outOfRange">If <c>true</c>, include an extra item in the output to represent values of <p>x</p> that are outside of the specified range.</param>
        <error code="17100">If not all values in <p>dictionary</p> are unique, this function raises a &quot;non-distinct values in dictionary&quot; runtime error.</error>
      </doc>
    </fcn>

    <fcn name="cast.avro">
      <sig>
        <par name="x"><any label="A"/></par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode an arbitrary object as Avro bytes.</desc>
        <detail>May be composed with <f>bytes.toBase64</f> to get an efficient string representation (e.g. for map keys).</detail>
      </doc>
    </fcn>

    <fcn name="cast.json">
      <sig>
        <par name="x"><any label="A"/></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Encode an arbitrary object as a JSON string.</desc>
        <detail>The form of this JSON string (spacing, order of keys in objects, etc.) is not guaranteed from one system to another.</detail>
        <detail>Should exclude unnecessary whitespace.</detail>
        <nondeterministic type="unstable"/>
      </doc>
    </fcn>

    <fcn name="a.len">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the length of array <p>a</p>.</desc>
      </doc>
    </fcn>

    <fcn name="a.subseq">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="start">int</par>
        <par name="end">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the subsequence of <p>a</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive).</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail>
      </doc>
    </fcn>

    <fcn name="a.head">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the first item of the array.</desc>
        <error code="15020">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.tail">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return all but the first item of the array.</desc>
        <error code="15030">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.last">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the last item of the array.</desc>
        <error code="15040">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.init">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return all but the last item of the array.</desc>
        <error code="15050">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.subseqto">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="start">int</par>
        <par name="end">int</par>
        <par name="replacement"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by replacing <p>a</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive) with <p>replacement</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail>
      </doc>
    </fcn>

    <fcn name="a.contains">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>haystack</p> contains <p>needle</p> or the <p>needle</p> function evaluates to <c>true</c>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.count">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Count the number of times <p>needle</p> appears in <p>haystack</p> or the number of times the <p>needle</p> function evaluates to <c>true</c>.</desc>
        <detail>If the <p>needle</p> is an empty array, the result is zero.</detail>
      </doc>
    </fcn>

    <fcn name="a.index">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the lowest index where <p>haystack</p> contains <p>needle</p> or the <p>needle</p> function evaluates to <c>true</c>, <m>-1</m> if there is no such element.</desc>
      </doc>
    </fcn>

    <fcn name="a.rindex">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the highest index where <p>haystack</p> contains <p>needle</p> or the <p>needle</p> function evaluates to <c>true</c>, <m>-1</m> if there is no such element.</desc>
      </doc>
    </fcn>

    <fcn name="a.startswith">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the first (leftmost) subseqence of <p>haystack</p> is equal to <p>needle</p>, false otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.endswith">
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="haystack"><array><any label="A"/></array></par>
        <par name="needle"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the last (rightmost) subseqence of <p>haystack</p> is equal to <p>needle</p>, false otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.concat">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Concatenate <p>a</p> and <p>b</p> to make a new array of the same type.</desc>
        <detail>The length of the returned array is the sum of the lengths of <p>a</p> and <p>b</p>.</detail>
      </doc>
    </fcn>

    <fcn name="a.append">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="item"><ref label="A"/></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by adding <p>item</p> at the end of <p>a</p>.</desc><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>The length of the returned array is one more than <p>a</p>.</detail>
      </doc>
    </fcn>

    <fcn name="a.cycle">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="item"><ref label="A"/></par>
        <par name="maxLength">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by adding <p>item</p> at the end of <p>a</p>, but keep the length less than or equal to <p>maxLength</p> by removing items from the beginning.</desc><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail>
        <error code="15150">If <p>maxLength</p> is less than 0, this function raises a &quot;maxLength out of range&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="a.insert">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="index">int</par>
        <par name="item"><ref label="A"/></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by inserting <p>item</p> at <p>index</p> of <p>a</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), following Python's index behavior.</detail><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail><error code="15160">If <p>index</p> is beyond the range of <p>a</p>, an &quot;index out of range&quot; runtime error is raised.</error>
        <detail>The length of the returned array is one more than <p>a</p>.</detail>
      </doc>
    </fcn>

    <fcn name="a.replace">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="index">int</par>
        <par name="item"><ref label="A"/></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by replacing <p>index</p> of <p>a</p> with <p>item</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), following Python's index behavior.</detail><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail><error code="15170">If <p>index</p> is beyond the range of <p>a</p>, an &quot;index out of range&quot; runtime error is raised.</error>
        <detail>The length of the returned array is equal to that of <p>a</p>.</detail>
      </doc>
    </fcn>

    <fcn name="a.remove">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="start">int</par>
        <par name="end">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="index">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return a new array by removing elements from <p>a</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive) or just a single <p>index</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail><error code="15180">If <p>index</p> is beyond the range of <p>a</p>, an &quot;index out of range&quot; runtime error is raised.</error>
        <detail>The length of the returned array is one less than <p>a</p>.</detail>
      </doc>
    </fcn>

    <fcn name="a.rotate">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="steps">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array formed by rotating <p>a</p> left <p>steps</p> spaces.</desc>
        <error code="15190">If <p>steps</p> is less than zero, a &quot;steps out of range&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.sort">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array with the same elements as <p>a</p> but in ascending order (as defined by Avro's sort order).</desc><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail>
      </doc>
    </fcn>

    <fcn name="a.sortLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array with the same elements as <p>a</p> but in ascending order as defined by the <p>lessThan</p> function.</desc><detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function.</detail>
      </doc>
    </fcn>

    <fcn name="a.shuffle">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array with the same elements as <p>a</p> but in a random order.</desc>
        <detail>Note: <p>a</p> is not changed in-place; this is a side-effect-free function (except for updating the random number generator).</detail>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="a.reverse">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the elements of <p>a</p> in reversed order.</desc>
      </doc>
    </fcn>

    <fcn name="a.max">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the maximum value in <p>a</p> (as defined by Avro's sort order).</desc><error code="15240">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.min">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the minimum value in <p>a</p> (as defined by Avro's sort order).</desc><error code="15250">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.maxLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the maximum value in <p>a</p> as defined by the <p>lessThan</p> function.</desc><error code="15260">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.minLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the minimum value in <p>a</p> as defined by the <p>lessThan</p> function.</desc><error code="15270">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.maxN">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the <p>n</p> highest values in <p>a</p> (as defined by Avro's sort order).</desc><error code="15280">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15281">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.minN">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the <p>n</p> lowest values in <p>a</p> (as defined by Avro's sort order).</desc><error code="15290">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15291">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.maxNLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the <p>n</p> highest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc><error code="15300">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15301">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.minNLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the <p>n</p> lowest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc><error code="15310">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15311">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argmax">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the index of the maximum value in <p>a</p> (as defined by Avro's sort order).</desc><detail>If the maximum is not unique, this function returns the index of the first maximal value.</detail><error code="15320">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argmin">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the index of the minimum value in <p>a</p> (as defined by Avro's sort order).</desc><detail>If the minimum is not unique, this function returns the index of the first minimal value.</detail><error code="15330">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argmaxLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the index of the maximum value in <p>a</p> as defined by the <p>lessThan</p> function.</desc><detail>If the maximum is not unique, this function returns the index of the first maximal value.</detail><error code="15340">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argminLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the index of the minimum value in <p>a</p> as defined by the <p>lessThan</p> function.</desc><detail>If the minimum is not unique, this function returns the index of the first minimal value.</detail><error code="15350">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argmaxN">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the indexes of the <p>n</p> highest values in <p>a</p> (as defined by Avro's sort order).</desc><detail>If any values are not unique, their indexes will be returned in ascending order.</detail><error code="15360">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15361">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argminN">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the indexes of the <p>n</p> lowest values in <p>a</p> (as defined by Avro's sort order).</desc><detail>If any values are not unique, their indexes will be returned in ascending order.</detail><error code="15370">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15371">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argmaxNLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the indexes of the <p>n</p> highest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc><detail>If any values are not unique, their indexes will be returned in ascending order.</detail><error code="15380">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15381">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.argminNLT">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array>int</array></ret>
      </sig>
      <doc>
        <desc>Return the indexes of the <p>n</p> lowest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc><detail>If any values are not unique, their indexes will be returned in ascending order.</detail><error code="15390">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error><error code="15391">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.sum">
      <sig>
        <par name="a"><array><any label="A" of="int, long, float, double"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the sum of numbers in <p>a</p>.</desc>
        <detail>Returns zero if the array is empty.</detail>
        <error code="15400">If the array items have integer type and the final result is too large or small to be represented as an integer, an &quot;int overflow&quot; error is raised.</error>
        <error code="15401">If the array items have long integer type and the final result is too large or small to be represented as a long integer, an &quot;long overflow&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.product">
      <sig>
        <par name="a"><array><any label="A" of="int, long, float, double"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the product of numbers in <p>a</p>.</desc>
        <detail>Returns one if the array is empty.</detail>
        <error code="15410">If the array items have integer type and the final result is too large or small to be represented as an integer, an &quot;int overflow&quot; error is raised.</error>
        <error code="15411">If the array items have long integer type and the final result is too large or small to be represented as a long integer, an &quot;long overflow&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.lnsum">
      <sig>
        <par name="a"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the sum of the natural logarithm of numbers in <p>a</p>.</desc>
        <detail>Returns zero if the array is empty and <c>NaN</c> if any value in the array is zero or negative.</detail>
      </doc>
    </fcn>

    <fcn name="a.mean">
      <sig>
        <par name="a"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the arithmetic mean of numbers in <p>a</p>.</desc>
        <detail>Returns <c>NaN</c> if the array is empty.</detail>
      </doc>
    </fcn>

    <fcn name="a.geomean">
      <sig>
        <par name="a"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the geometric mean of numbers in <p>a</p>.</desc>
        <detail>Returns <c>NaN</c> if the array is empty.</detail>
      </doc>
    </fcn>

    <fcn name="a.median">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the value that is in the center of a sorted version of <p>a</p>.</desc>
        <detail>If <p>a</p> has an odd number of elements, the median is the exact center of the sorted array.  If <p>a</p> has an even number of elements and is a <c>float</c> or <c>double</c>, the median is the average of the two elements closest to the center of the sorted array.  For any other type, the median is the left (first) of the two elements closest to the center of the sorted array.</detail><error code="15450">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.ntile">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="p">double</par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the value that is at the &quot;n-tile&quot; of <p>a</p> (like a percentile).</desc>
        <param name="a">Array of objects to be take the percentile of.</param>
        <param name="p">A double between 0 and 1.</param>
        <detail>If <p>a</p> has an even number of elements and is a <c>float</c> or <c>double</c>, this function will take the average of the two elements closest to the center of the sorted array.  For any other type, it returns the left (first) of the two elements closest to the center of the sorted array.  If <p>p</p> is exactly one (or greater), the max of the array is returned.  If <p>p</p> is zero (or less), the min of the array is returned.</detail><error code="15460">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
        <error code="15461">If <p>p</p> is NaN, this function raises a &quot;p not a number&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="a.mode">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Return the mode (most common) value of <p>a</p>.</desc>
        <detail>If several different values are equally common, the median of these is returned.</detail><error code="15470">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.logsumexp">
      <sig>
        <par name="a"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute <m>z = \\log(\\sum_{n = 1}^{N} e^{x_n})</m> in a numerically stable way.</desc>
        <detail>Returns <c>NaN</c> if the array is empty.</detail>
      </doc>
    </fcn>

    <fcn name="a.distinct">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array with the same contents as <p>a</p> but with duplicates removed.</desc>
        <detail>The order of the original array is preserved.</detail>
      </doc>
    </fcn>

    <fcn name="a.seteq">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>a</p> and <p>b</p> are equivalent, ignoring order and duplicates, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.union">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array that represents the union of <p>a</p> and <p>b</p>, treated as sets (ignoring order and duplicates).</desc>
        <detail>The order of the original arrays is preserved.</detail>
      </doc>
    </fcn>

    <fcn name="a.intersection">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array that represents the intersection of <p>a</p> and <p>b</p>, treated as sets (ignoring order and duplicates).</desc>
        <detail>The order of the original arrays is preserved.</detail>
      </doc>
    </fcn>

    <fcn name="a.diff">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array that represents the difference of <p>a</p> and <p>b</p>, treated as sets (ignoring order and duplicates).</desc>
        <detail>The order of the original arrays is preserved.</detail>
      </doc>
    </fcn>

    <fcn name="a.symdiff">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return an array that represents the symmetric difference of <p>a</p> and <p>b</p>, treated as sets (ignoring order and duplicates).</desc>
        <detail>The symmetric difference is (<p>a</p> diff <p>b</p>) union (<p>b</p> diff <p>a</p>).</detail>
        <detail>The order of the original arrays is preserved.</detail>
      </doc>
    </fcn>

    <fcn name="a.subset">
      <sig>
        <par name="little"><array><any label="A"/></array></par>
        <par name="big"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>little</p> is a subset of <p>big</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.disjoint">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><ref label="A"/></array></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>a</p> and <p>b</p> are disjoint, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="a.map">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><any label="B"/></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and return an array of the results.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.mapWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <ret><any label="B"/></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to index, element pairs from <p>a</p> and return an array of the results.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.filter">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and return an array of the elements for which <p>fcn</p> returns <c>true</c>.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.filterWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each index, element pair of <p>a</p> and return an array of the elements for which <p>fcn</p> returns <c>true</c>.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.filterMap">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><union><any label="B"/></union><union>null</union></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and return an array of the results that are not <c>null</c>.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.filterMapWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <ret><union><any label="B"/></union><union>null</union></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each index, element pair of <p>a</p> and return an array of the results that are not <c>null</c>.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.flatMap">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><array><any label="B"/></array></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and flatten the resulting arrays into a single array.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.flatMapWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <ret><array><any label="B"/></array></ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each index, element pair of <p>a</p> and flatten the resulting arrays into a single array.</desc><detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it will be called exactly once for each element.</detail>
      </doc>
    </fcn>

    <fcn name="a.zipmap">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="c"><array><any label="C"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="c"><array><any label="C"/></array></par>
        <par name="d"><array><any label="D"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <par><ref label="D"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to the elements of <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> in lock-step and return a result for row.</desc>
        <error code="15650">Raises a &quot;misaligned arrays&quot; error if <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> do not all have the same length.</error>
      </doc>
    </fcn>

    <fcn name="a.zipmapWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="c"><array><any label="C"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="c"><array><any label="C"/></array></par>
        <par name="d"><array><any label="D"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <par><ref label="D"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><array><ref label="Z"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to the indexes and elements of <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> in lock-step and return a result for row.</desc>
        <error code="15660">Raises a &quot;misaligned arrays&quot; error if <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> do not all have the same length.</error>
      </doc>
    </fcn>

    <fcn name="a.reduce">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret><ref label="A"/></ret>
          </function></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and accumulate a tally.</desc>
        <detail>The first parameter of <p>fcn</p> is the running tally and the second parameter is an element from <p>a</p>.</detail>
        <detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, <p>fcn</p> should be associative.  It need not be commutative.</detail><error code="15670">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.reduceRight">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret><ref label="A"/></ret>
          </function></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and accumulate a tally.</desc>
        <detail>The first parameter of <p>fcn</p> is an element from <p>a</p> and the second parameter is the running tally.</detail>
        <detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, <p>fcn</p> should be associative.  It need not be commutative.</detail><error code="15680">If <p>a</p> is empty, an &quot;empty array&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.fold">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="zero"><any label="B"/></par>
        <par name="fcn">
          <function>
            <par><ref label="B"/></par>
            <par><ref label="A"/></par>
            <ret><ref label="B"/></ret>
          </function></par>
        <ret><ref label="B"/></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and accumulate a tally, starting with <p>zero</p>.</desc>
        <detail>The first parameter of <p>fcn</p> is the running tally and the second parameter is an element from <p>a</p>.</detail>
        <detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it accumulates from left (beginning) to right (end), called exactly once for each element.  For predictable results, <p>fcn</p> should be associative with <p>zero</p> as its identity; that is, <c>fcn(zero, zero) = zero</c>.  It need not be commutative.</detail>
      </doc>
    </fcn>

    <fcn name="a.foldRight">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="zero"><any label="B"/></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret><ref label="B"/></ret>
          </function></par>
        <ret><ref label="B"/></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each element of <p>a</p> and accumulate a tally, starting with <p>zero</p>.</desc>
        <detail>The first parameter of <p>fcn</p> is an element from <p>a</p> and the second parameter is the running tally.</detail>
        <detail>The order in which <p>fcn</p> is called on elements of <p>a</p> is not guaranteed, though it accumulates from right (end) to left (beginning), called exactly once for each element.  For predictable results, <p>fcn</p> should be associative with <p>zero</p> as its identity; that is, <c>fcn(zero, zero) = zero</c>.  It need not be commutative.</detail>
      </doc>
    </fcn>

    <fcn name="a.takeWhile">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to elements of <p>a</p> and create an array of the longest prefix that returns <c>true</c>, stopping with the first <c>false</c>.</desc>
        <detail>Beyond the prefix, the number of <p>fcn</p> calls is not guaranteed.</detail>
      </doc>
    </fcn>

    <fcn name="a.dropWhile">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to elements of <p>a</p> and create an array of all elements after the longest prefix that returns <c>true</c>.</desc>
        <detail>Beyond the prefix, the number of <p>fcn</p> calls is not guaranteed.</detail>
      </doc>
    </fcn>

    <fcn name="a.any">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> for any element in <p>a</p> (logical or).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
      </doc>
    </fcn>

    <fcn name="a.all">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> for all elements in <p>a</p> (logical and).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
      </doc>
    </fcn>

    <fcn name="a.corresponds">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> when applied to all pairs of elements, one from <p>a</p> and the other from <p>b</p> (logical relation).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
        <detail>If the lengths of <p>a</p> and <p>b</p> are not equal, this function returns <c>false</c>.</detail>
      </doc>
    </fcn>

    <fcn name="a.correspondsWithIndex">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="b"><array><any label="B"/></array></par>
        <par name="fcn">
          <function>
            <par>int</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> when applied to all triples of index, element from <p>a</p>, element from <p>b</p> (logical relation).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
        <detail>If the lengths of <p>a</p> and <p>b</p> are not equal, this function returns <c>false</c>.</detail>
      </doc>
    </fcn>

    <fcn name="a.slidingWindow">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="size">int</par>
        <par name="step">int</par>
        <ret><array><array><ref label="A"/></array></array></ret>
      </sig>
      <doc>
        <desc>Return an array of subsequences of <p>a</p> with length <p>size</p> that slide through <p>a</p> in steps of length <p>step</p> from left to right.</desc>
        <error code="15770">If <p>size</p> is non-positive, a &quot;size &lt; 1&quot; runtime error is raised.</error>
        <error code="15771">If <p>step</p> is non-positive, a &quot;step &lt; 1&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.combinations">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="size">int</par>
        <ret><array><array><ref label="A"/></array></array></ret>
      </sig>
      <doc>
        <desc>Return all combinations of elements of <p>a</p> with length <p>size</p>.</desc>
        <error code="15780">If <p>size</p> is non-positive, a &quot;size &lt; 1&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="a.permutations">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><array><array><ref label="A"/></array></array></ret>
      </sig>
      <doc>
        <desc>Return all permutations of elements of <p>a</p>.</desc><detail>This function scales rapidly with the length of the array.  For reasonably large arrays, it will result in timeout exceptions.</detail>
      </doc>
    </fcn>

    <fcn name="a.flatten">
      <sig>
        <par name="a"><array><array><any label="A"/></array></array></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Concatenate the arrays in <p>a</p>.</desc>
      </doc>
    </fcn>

    <fcn name="a.groupby">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>string</ret>
          </function></par>
        <ret><map><array><ref label="A"/></array></map></ret>
      </sig>
      <doc>
        <desc>Groups elements of <p>a</p> by the string that <p>fcn</p> maps them to.</desc>
      </doc>
    </fcn>

    <fcn name="map.len">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the length of a map.</desc>
      </doc>
    </fcn>

    <fcn name="map.keys">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Return the keys of a map (in no particular order).</desc>
        <nondeterministic type="unordered"/>
      </doc>
    </fcn>

    <fcn name="map.values">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Return the values of a map (in no particular order).</desc>
        <nondeterministic type="unordered"/>
      </doc>
    </fcn>

    <fcn name="map.containsKey">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="key">string</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the keys of <p>m</p> contains <p>key</p> or <p>fcn</p> evaluates to <c>true</c> for some key of <p>m</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="map.containsValue">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="value"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if the values of <p>m</p> contains <p>value</p> or <p>fcn</p> evaluates to <c>true</c> for some key of <p>m</p>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="map.add">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="key">string</par>
        <par name="value"><ref label="A"/></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="item"><ref label="A"/></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return a new map by adding the <p>key</p> <p>value</p> pair to <p>m</p> or a new set by adding the <p>item</p> to set <p>m</p>, where a set is represented as a map from serialized objects to objects.</desc><detail>Note: <p>m</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>If <p>key</p> is in <p>m</p>, its value will be replaced.</detail>
        <detail>The serialization format for keys of sets is base64-encoded Avro.</detail>
      </doc>
    </fcn>

    <fcn name="map.remove">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="key">string</par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return a new map by removing <p>key</p> from <p>m</p>.</desc><detail>Note: <p>m</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>If <p>key</p> is not in <p>m</p>, the return value is simply <p>m</p>.</detail>
      </doc>
    </fcn>

    <fcn name="map.only">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="keys"><array>string</array></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return a new map, keeping only <p>keys</p> from <p>m</p>.</desc><detail>Note: <p>m</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>If some <p>keys</p> are not in <p>m</p>, they are ignored and do not appear in the return value.</detail>
      </doc>
    </fcn>

    <fcn name="map.except">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="keys"><array>string</array></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return a new map, keeping all but <p>keys</p> from <p>m</p>.</desc><detail>Note: <p>m</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>If some <p>keys</p> are not in <p>m</p>, they are ignored and do not appear in the return value.</detail>
      </doc>
    </fcn>

    <fcn name="map.update">
      <sig>
        <par name="base"><map><any label="A"/></map></par>
        <par name="overlay"><map><ref label="A"/></map></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return a new map with key-value pairs from <p>overlay</p> in place of or in addition to key-value pairs from <p>base</p>.</desc><detail>Note: <p>m</p> is not changed in-place; this is a side-effect-free function.</detail>
        <detail>Keys of <p>overlay</p> that are not in <p>base</p> are added to those in <p>base</p> and keys of <p>overlay</p> that are in <p>base</p> supersede those in <p>base</p>.</detail>
      </doc>
    </fcn>

    <fcn name="map.split">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret><array><map><ref label="A"/></map></array></ret>
      </sig>
      <doc>
        <desc>Split the map into an array of maps, each containing only one key-value pair (in no particular order).</desc>
        <nondeterministic type="unordered"/>
      </doc>
    </fcn>

    <fcn name="map.join">
      <sig>
        <par name="a"><array><map><any label="A"/></map></array></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Join an array of maps into one map, overlaying from left to right.</desc>
      </doc>
    </fcn>

    <fcn name="map.argmax">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the key of the highest value in <p>m</p> (as defined by Avro's sort order).</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26120">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argmin">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the key of the lowest value in <p>m</p> (as defined by Avro's sort order).</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26130">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argmaxLT">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the key of the highest value in <p>m</p> as defined by the <p>lessThan</p> function.</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26140">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argminLT">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the key of the lowest value in <p>m</p> as defined by the <p>lessThan</p> function.</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26150">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argmaxN">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="n">int</par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Return the keys of the <p>n</p> highest values in <p>m</p> (as defined by Avro's sort order).</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26160">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error><error code="26161">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argminN">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="n">int</par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Return the keys of the <p>n</p> lowest values in <p>m</p> (as defined by Avro's sort order).</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26170">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error><error code="26171">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argmaxNLT">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Return the keys of the <p>n</p> highest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26180">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error><error code="26181">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.argminNLT">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array>string</array></ret>
      </sig>
      <doc>
        <desc>Return the keys of the <p>n</p> highest values in <p>a</p> as defined by the <p>lessThan</p> function.</desc>
        <detail>If any values are not unique, their keys will be returned in lexicographic order.</detail><error code="26190">If <p>m</p> is empty, an &quot;empty map&quot; runtime error is raised.</error><error code="26191">If <p>n</p> is negative, an &quot;n &lt; 0&quot; runtime error is raised.</error>
      </doc>
    </fcn>

    <fcn name="map.toset">
      <sig>
        <par name="a"><array><any label="A"/></array></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Convert an array of objects into a set of objects, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
      </doc>
    </fcn>

    <fcn name="map.fromset">
      <sig>
        <par name="s"><map><any label="A"/></map></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Convert a set of objects into an array of objects (in no particular order), where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only values, not keys.</detail>
        <nondeterministic type="unordered"/>
      </doc>
    </fcn>

    <fcn name="map.in">
      <sig>
        <par name="s"><map><any label="A"/></map></par>
        <par name="x"><ref label="A"/></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is contained in set <p>s</p>, <c>false</c> otherwise, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.union">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><ref label="A"/></map></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return the union of sets <p>a</p> and <p>b</p>, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.intersection">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><ref label="A"/></map></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return the intersection of sets <p>a</p> and <p>b</p>, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.diff">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><ref label="A"/></map></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return the difference of sets <p>a</p> and <p>b</p>, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.symdiff">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><ref label="A"/></map></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Return the difference of sets <p>a</p> and <p>b</p>, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.subset">
      <sig>
        <par name="little"><map><any label="A"/></map></par>
        <par name="big"><map><ref label="A"/></map></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if set <p>little</p> is a subset of set <p>big</p>, <c>false</c> otherwise, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.disjoint">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><ref label="A"/></map></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if set <p>a</p> and set <p>b</p> are disjoint, <c>false</c> otherwise, where a set is represented as a map from serialized objects to objects.</desc>
        <detail>The serialization format is base64-encoded Avro.</detail>
        <detail>This function does not verify that the serialized objects (keys) and objects (values) match: it considers only keys, not values.</detail>
      </doc>
    </fcn>

    <fcn name="map.map">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><any label="B"/></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each value of <p>m</p> and return a map of transformed values (keys are unchanged).</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
        <detail>To transform both keys and values, consider applying <f>map.split</f>, <f>a.map</f>, then <f>map.join</f>.</detail>
      </doc>
    </fcn>

    <fcn name="map.mapWithKey">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <ret><any label="B"/></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each key, value pair of <p>m</p> and return a map of transformed values (keys are unchanged).</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
        <detail>To transform both keys and values, consider applying <f>map.split</f>, <f>a.map</f>, then <f>map.join</f>.</detail>
      </doc>
    </fcn>

    <fcn name="map.filter">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each value of <p>m</p> and return a map of the values for which <p>fcn</p> returns <c>true</c> (keys are unchanged).</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.filterWithKey">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><map><ref label="A"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each value of <p>m</p> and return a map of the values for which <p>fcn</p> returns <c>true</c> (keys are unchanged).</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.filterMap">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><union><any label="B"/></union><union>null</union></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each value of <p>m</p> and return a map of the results that are not <c>null</c>.</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.filterMapWithKey">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <ret><union><any label="B"/></union><union>null</union></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each key-value pair of <p>m</p> and return a map of the results that are not <c>null</c>.</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.flatMap">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <ret><map><any label="B"/></map></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each value of <p>m</p> and return a map of overlaid results.</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.flatMapWithKey">
      <sig>
        <par name="m"><map><any label="A"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <ret><map><any label="B"/></map></ret>
          </function></par>
        <ret><map><ref label="B"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to each key-value pair of <p>m</p> and return a map of overlaid results.</desc><detail>The order in which <p>fcn</p> is called on items in <p>m</p> is not guaranteed, though it will be called exactly once for each value.</detail>
      </doc>
    </fcn>

    <fcn name="map.zipmap">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="c"><map><any label="C"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="c"><map><any label="C"/></map></par>
        <par name="d"><map><any label="D"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <par><ref label="D"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to the elements of <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> in lock-step and return a result for row.</desc>
        <error code="26370">Raises a &quot;misaligned maps&quot; error if <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> do not all have the same keys.</error>
      </doc>
    </fcn>

    <fcn name="map.zipmapWithKey">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="c"><map><any label="C"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="c"><map><any label="C"/></map></par>
        <par name="d"><map><any label="D"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <par><ref label="C"/></par>
            <par><ref label="D"/></par>
            <ret><any label="Z"/></ret>
          </function></par>
        <ret><map><ref label="Z"/></map></ret>
      </sig>
      <doc>
        <desc>Apply <p>fcn</p> to the keys and elements of <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> in lock-step and return a result for row.</desc>
        <error code="26380">Raises a &quot;misaligned maps&quot; error if <p>a</p>, <p>b</p>, <p>c</p>, <p>d</p> do not all have the same keys.</error>
      </doc>
    </fcn>

    <fcn name="map.corresponds">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="fcn">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> when applied to all pairs of values, one from <p>a</p> and the other from <p>b</p> (logical relation).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
        <detail>If the key sets of <p>a</p> and <p>b</p> are not equal, this function returns <c>false</c>.</detail>
      </doc>
    </fcn>

    <fcn name="map.correspondsWithKey">
      <sig>
        <par name="a"><map><any label="A"/></map></par>
        <par name="b"><map><any label="B"/></map></par>
        <par name="fcn">
          <function>
            <par>string</par>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>fcn</p> is <c>true</c> when applied to all triples of key, value from <p>a</p>, value from <p>b</p> (logical relation).</desc>
        <detail>The number of <p>fcn</p> calls is not guaranteed.</detail>
        <detail>If the key sets of <p>a</p> and <p>b</p> are not equal, this function returns <c>false</c>.</detail>
      </doc>
    </fcn>

    <fcn name="bytes.len">
      <sig>
        <par name="x">bytes</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the length of byte array <p>x</p>.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.subseq">
      <sig>
        <par name="x">bytes</par>
        <par name="start">int</par>
        <par name="end">int</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Return the subsequence of <p>x</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive).</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail>
      </doc>
    </fcn>

    <fcn name="bytes.subseqto">
      <sig>
        <par name="x">bytes</par>
        <par name="start">int</par>
        <par name="end">int</par>
        <par name="replacement">bytes</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Replace <p>x</p> from <p>start</p> (inclusive) until <p>end</p> (exclusive) with <p>replacement</p>.</desc><detail>Negative indexes count from the right (-1 is just before the last item), indexes beyond the legal range are truncated, and <p>end</p> ≤ <p>start</p> specifies a zero-length subsequence just before the <p>start</p> character.  All of these rules follow Python's slice behavior.</detail>
      </doc>
    </fcn>

    <fcn name="bytes.isAscii">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid ASCII; <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.isLatin1">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid latin-1 (ISO-8859-1); <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.isUtf8">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid utf-8; <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.isUtf16">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid utf-16 (byte order identified by optional byte-order mark); <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.isUtf16be">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid big endian utf-16; <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.isUtf16le">
      <sig>
        <par name="x">bytes</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if <p>x</p> is valid little endian utf-16; <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="bytes.decodeAscii">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as an ASCII string.</desc>
        <error code="16090">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.decodeLatin1">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as a latin-1 (ISO-8859-1) string.</desc>
        <error code="16100">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.decodeUtf8">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as a utf-8 string.</desc>
        <error code="16110">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.decodeUtf16">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as a utf-16 (byte order identified by optional byte-order mark) string.</desc>
        <error code="16120">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.decodeUtf16be">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as a big endian utf-16 string.</desc>
        <error code="16130">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.decodeUtf16le">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Decode a bytes object as a little endian utf-16 string.</desc>
        <error code="16140">Raises an &quot;invalid bytes&quot; error if the bytes cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeAscii">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as ASCII bytes.</desc>
        <error code="16150">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeLatin1">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as latin-1 (ISO-8859-1) bytes.</desc>
        <error code="16160">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeUtf8">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as utf-8 bytes.</desc>
        <error code="16170">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeUtf16">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as utf-16 (byte order identified by optional byte-order mark) bytes.</desc>
        <nondeterministic type="unstable"/>
        <error code="16180">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeUtf16be">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as big endian utf-16 bytes.</desc>
        <error code="16190">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.encodeUtf16le">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Encode a string as little endian utf-16 bytes.</desc>
        <error code="16200">Raises an &quot;invalid string&quot; error if the string cannot be converted.</error>
      </doc>
    </fcn>

    <fcn name="bytes.toBase64">
      <sig>
        <par name="x">bytes</par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Convert an arbitrary bytes object to a base64-encoded string.</desc>
    </doc>
    </fcn>

    <fcn name="bytes.fromBase64">
      <sig>
        <par name="s">string</par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Convert a base64-encoded string to a bytes object.</desc>
        <error code="16220">Raises an &quot;invalid base64&quot; error if the string is not valid base64.</error>
    </doc>
    </fcn>

    <fcn name="fixed.toBytes">
      <sig>
        <par name="x"><fixed label="A"/></par>
        <ret>bytes</ret>
      </sig>
      <doc>
        <desc>Convert fixed-length, named bytes into arbitrary-length, anonymous bytes.</desc>
      </doc>
    </fcn>

    <fcn name="fixed.fromBytes">
      <sig>
        <par name="original"><fixed label="A"/></par>
        <par name="replacement">bytes</par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Overlay <p>replacement</p> on top of <p>original</p>.</desc>
        <detail>If <p>replacement</p> is shorter than <p>original</p>, the bytes beyond <p>replacement</p>'s length are taken from <p>original</p>.</detail>
        <detail>If <p>replacement</p> is longer than <p>original</p>, the excess bytes are truncated.</detail>
      </doc>
    </fcn>

    <fcn name="enum.toString">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret>string</ret>
      </sig>
      <doc>
        <desc>Return the string representation of an enum.</desc>
      </doc>
    </fcn>

    <fcn name="enum.toInt">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the integer representation of an enum.</desc>
      </doc>
    </fcn>

    <fcn name="enum.numSymbols">
      <sig>
        <par name="x"><enum label="A"/></par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Return the number of symbols associated with this enum (a constant).</desc>
      </doc>
    </fcn>

    <fcn name="time.year">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the four-digit year that the timestamp falls within.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40000">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40001">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.monthOfYear">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the month that the timestamp falls within, with 1 being January and 12 being December.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40010">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40011">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.dayOfYear">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the day of the year that the timestamp falls within, from 1 to 365 or 366 inclusive, depending on leap year.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40020">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40021">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.dayOfMonth">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the day of the month that the timestamp falls within, a number from 1 to 28, 29, 30, or 31, inclusive, depending on month.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40030">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40031">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.dayOfWeek">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the day of the week that the timestamp falls within, with 0 being Monday and 6 being Sunday.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40040">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40041">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.hourOfDay">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the hour of the day that the timestamp falls within, from 0 to 23 inclusive.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40050">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40051">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.minuteOfHour">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Get the minute of the hour that the timestamp falls within, from 0 to 59 inclusive.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40060">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40061">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.secondOfMinute">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>int</ret>
      </sig>
      <doc>
      <desc>Get the second of the minute that the timestamp falls within, from 0 to 59 inclusive.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40070">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40071">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
    </doc>
    </fcn>

    <fcn name="time.makeTimestamp">
      <sig>
        <par name="year">int</par>
        <par name="month">int</par>
        <par name="day">int</par>
        <par name="hour">int</par>
        <par name="minute">int</par>
        <par name="second">int</par>
        <par name="millisecond">int</par>
        <par name="zone">string</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Given the date and time that this time occurs in, return the timestamp.</desc>
        <param name="year">The four-digit year, from 1 to 9999 inclusive.</param>
        <param name="month">The month of the year, from 1 to 12 inclusive.</param>
        <param name="day">The day of the month, from 1 to 28, 29, 30, or 31 inclusive, depending on month.</param>
        <param name="hour">The hour of the day, from 0 to 23 inclusive.</param>
        <param name="minute">The minute of the hour, from 0 to 59 inclusive.</param>
        <param name="second">The second of the minute, from 0 to 59 inclusive.</param>
        <param name="millisecond">The millisecond of the second, from 0 to 999 inclusive.</param>
        <param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <ret>The number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</ret>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40080">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error>
        <error code="40081">Raises &quot;timestamp undefined for given parameters&quot; if any one (or more) of the inputs have impossible values.</error>
      </doc>
    </fcn>

    <fcn name="time.isSecondOfMinute">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified number of seconds in any minute.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum number of seconds (inclusive).</param>
        <param name="high">Maximum number of seconds (exclusive).</param>
        <error code="40090">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40091">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40092">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
    </doc>
    </fcn>

    <fcn name="time.isMinuteOfHour">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified number of minutes in any hour.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum number of minutes (inclusive)</param>
        <param name="high">Maximum number of minutes (exclusive).</param>
        <error code="40100">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40101">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40102">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isHourOfDay">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified number of hours in any day.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum number of hours (inclusive).</param>
        <param name="high">Maximum number of hours (exclusive).</param>
        <error code="40110">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40111">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40112">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isDayOfWeek">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified day of week range, with 0 being Monday and 6 being Sunday.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum day of the week (inclusive).</param>
        <param name="high">Maximum day of the week (exclusive).</param>
        <error code="40120">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40121">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40122">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isDayOfMonth">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified day of month range, with 1 being the first of the month..</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum day of the month (inclusive).</param>
        <param name="high">Maximum day of the month (exclusive).</param>
        <error code="40130">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40131">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40132">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isMonthOfYear">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified month of year range, with 1 being January and 12 being December.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum month of the year (inclusive).</param>
        <param name="high">Maximum month of the year (exclusive).</param>
        <error code="40140">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40141">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40142">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isDayOfYear">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determines if a timestamp falls within a specified day of year range, with 1 being the first of the year.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param>
        <param name="low">Minimum day of year (inclusive).</param>
        <param name="high">Maximum day of year (exclusive).</param>
        <error code="40150">Raises &quot;bad time range&quot; if low <m>\mathrm{low} \geq \mathrm{high}</m>.</error>
        <detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40151">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40152">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isWeekend">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if the timestamp falls on a Saturday or Sunday, <c>false</c> otherwise.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40160">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40161">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="time.isWorkHours">
      <sig>
        <par name="ts">double</par>
        <par name="zone">string</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Returns <c>true</c> if the timestamp falls between 9 am (inclusive) and 5 pm (exclusive) on Monday through Friday, otherwise <c>false</c>.</desc>
        <param name="ts">Number of seconds since the beginning (just after midnight) of Jan 1, 1970 C.E. in UTC.</param><param name="zone">Timezone name from the Olson timezone database, version 2015f (UTC if blank).</param><detail>The earliest expressible date is the beginning (just after midnight) of Jan 1, 1 C.E. in UTC on the proleptic Gregorian calendar, which is a timestamp of -62135596800. The latest expressible date is the end (just before midnight) of Dec 31, 9999 C.E. in UTC on the Gregorian calendar, which is a timestamp of 253402300799.</detail><error code="40170">Raises &quot;unrecognized timezone string&quot; if <p>zone</p> is not in the Olson 2015f database.</error><error code="40171">Raises &quot;timestamp out of range&quot; if <p>ts</p> less than -62135596800 or greater than 253402300799.</error>
      </doc>
    </fcn>

    <fcn name="impute.errorOnNull">
      <sig>
        <par name="x"><union><any label="A"/></union><union>null</union></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Skip an action by raising a runtime error when <p>x</p> is <c>null</c>.</desc>
        <error code="21000">Raises an &quot;encountered null&quot; error if <p>x</p> is <c>null</c>.</error>
      </doc>
    </fcn>

    <fcn name="impute.defaultOnNull">
      <sig>
        <par name="x"><union><any label="A"/></union><union>null</union></par>
        <par name="default"><ref label="A"/></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Replace <c>null</c> values in <p>x</p> with <p>default</p>.</desc>
      </doc>
    </fcn>

    <fcn name="impute.isnan">
      <sig>
        <par name="x">float</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is <c>nan</c>, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="impute.isinf">
      <sig>
        <par name="x">float</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is positive or negative infinity, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="impute.isnum">
      <sig>
        <par name="x">float</par>
        <ret>boolean</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Return <c>true</c> if <p>x</p> is neither <c>nan</c> nor infinite, <c>false</c> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="impute.errorOnNonNum">
      <sig>
        <par name="x">float</par>
        <ret>float</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Pass through <p>x</p> if it is neither <c>nan</c> nor infinite, but raise an error otherwise.</desc>
        <error code="21050">Raises an &quot;encountered nan&quot; if <p>x</p> is <c>nan</c>.</error>
        <error code="21051">Raises an &quot;encountered +inf&quot; if <p>x</p> is positive infinity.</error>
        <error code="21052">Raises an &quot;encountered -inf&quot; if <p>x</p> is negative infinity.</error>
      </doc>
    </fcn>

    <fcn name="impute.defaultOnNonNum">
      <sig>
        <par name="x">float</par>
        <par name="default">float</par>
        <ret>float</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="default">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Pass through <p>x</p> if it is neither <c>nan</c> nor infinite, and return <p>default</p> otherwise.</desc>
      </doc>
    </fcn>

    <fcn name="interp.bin">
      <sig>
        <par name="x">double</par>
        <par name="numbins">int</par>
        <par name="low">double</par>
        <par name="high">double</par>
        <ret>int</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="origin">double</par>
        <par name="width">double</par>
        <ret>int</ret>
      </sig>
      <doc>
        <desc>Finds the bin that contains <p>x</p>, declared either as <p>numbins</p> between two endpoints or a bin <p>width</p> starting at some <p>origin</p>.</desc>
        <detail>Bins are inclusive on the low end and exclusive on the high end, so if <p>x</p> equal <p>low</p> or <p>origin</p>, the resulting bin is <c>0</c>, but if <p>x</p> is equal to <p>high</p>, it is out of range.</detail>
        <detail>If the first signature is used, the resulting bin must be between <c>0</c> (inclusive) and <p>numbins</p> (exclusive). If the second signature is used, the resulting bin may be any integer, including negative numbers.</detail>
        <error code="22000">If <p>low</p> is greater or equal to <p>high</p> or <p>origin</p> is not finite, raises &quot;bad histogram range&quot;</error>
        <error code="22001">If <p>numbins</p> is less than <c>1</c> or <p>width</p> is less or equal to <c>0</c>, raises &quot;bad histogram scale&quot;</error>
        <error code="22002">Raises &quot;x out of range&quot; if <p>x</p> is less than <p>low</p> or greater or equal to <p>high</p>.</error>
      </doc>
    </fcn>

    <fcn name="interp.nearest">
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to"><any label="T"/></field></record></array></par>
        <ret><ref label="T"/></ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <par name="table"><array><record label="R"><field name="x"><array>double</array></field><field name="to"><any label="T"/></field></record></array></par>
        <ret><ref label="T"/></ret>
      </sig>
      <sig>
        <par name="x"><any label="X1"/></par>
        <par name="table"><array><record label="R"><field name="x"><any label="X2"/></field><field name="to"><any label="T"/></field></record></array></par>
        <par name="metric">
          <function>
            <par><ref label="X1"/></par>
            <par><ref label="X2"/></par>
            <ret>double</ret>
          </function></par>
        <ret><ref label="T"/></ret>
      </sig>
      <doc>
        <desc>Finds the closest <pf>x</pf> value in the <p>table</p> to the input <p>x</p> and returns the corresponding <pf>to</pf> value.</desc>
        <detail>Any ties in distance are resolved in favor of the first instance in the <p>table</p>.</detail>
        <error code="22010">Raises a &quot;table must have at least one entry&quot; error if <p>table</p> has fewer than one entry.</error>
        <error code="22011">Raises an &quot;inconsistent dimensionality&quot; error if any input <p>x</p> and record <pf>x</pf> have different numbers of dimensions.</error>
      </doc>
    </fcn>

    <fcn name="interp.linear">
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to">double</field></record></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to"><array>double</array></field></record></array></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Finds the closest <pf>x</pf> values in the <p>table</p> that are below and above the input <p>x</p> and linearly projects their <pf>to</pf> values to the input <p>x</p>.</desc>
        <detail>Any ties in distance are resolved in favor of the first instance in the <p>table</p>.</detail>
        <detail>If the <pf>to</pf> values are arrays, each component will be interpolated.</detail>
        <error code="22020">Raises a &quot;table must have at least two distinct x values&quot; error if fewer than two of the <p>table</p> <pf>x</pf> entries are unique.</error>
        <error code="22021">Raises an &quot;inconsistent dimensionality&quot; error if the <pf>to</pf> values of the two closest entries have different numbers of dimensions.</error>
      </doc>
    </fcn>

    <fcn name="interp.linearFlat">
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to">double</field></record></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to"><array>double</array></field></record></array></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Like <f>interp.linear</f>, but returns the closest entry's <pf>to</pf> if the input <p>x</p> is beyond the <p>table</p>.</desc>
        <detail>Any ties in distance are resolved in favor of the first instance in the <p>table</p>.</detail>
        <detail>If the <pf>to</pf> values are arrays, each component will be interpolated.</detail>
        <error code="22030">Raises a &quot;table must have at least two distinct x values&quot; error if <p>table</p> has fewer than two entries.</error>
        <error code="22031">Raises an &quot;inconsistent dimensionality&quot; error if the <pf>to</pf> values of the two closest entries have different numbers of dimensions.</error>
      </doc>
    </fcn>

    <fcn name="interp.linearMissing">
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to">double</field></record></array></par>
        <ret><union>null</union><union>double</union></ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to"><array>double</array></field></record></array></par>
        <ret><union>null</union><union><array>double</array></union></ret>
      </sig>
      <doc>
        <desc>Like <f>interp.linear</f>, but returns a missing value (<c>null</c>) if the input <p>x</p> is beyond the <p>table</p>.</desc>
        <detail>Any ties in distance are resolved in favor of the first instance in the <p>table</p>.</detail>
        <detail>If the <pf>to</pf> values are arrays, each component will be interpolated.</detail>
        <error code="22040">Raises a &quot;table must have at least two distinct x values&quot; error if <p>table</p> has fewer than two entries.</error>
        <error code="22041">Raises an &quot;inconsistent dimensionality&quot; error if the <pf>to</pf> values of the two closest entries have different numbers of dimensions.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gaussianLL">
      <sig>
        <par name="x">double</par>
        <par name="mu">double</par>
        <par name="sigma">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="params"><record label="A"><field name="mean">double</field><field name="variance">double</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the log-likelihood of a Gaussian (normal) distribution parameterized by <p>mu</p> and <p>sigma</p> or a record <p>params</p>.</desc>
        <param name="x">Value at which to compute the log-likelihood.</param>
        <param name="mu">Centroid of the distribution (same as <pf>mean</pf>).</param>
        <param name="sigma">Width of the distribution (same as the square root of <pf>variance</pf>).</param>
        <param name="params">Alternate way of specifying the parameters of the distribution; this record could be created by <f>stat.sample.update</f>.</param>
        <ret>With <m>\mu</m> = <p>mu</p> or <pf>mean</pf> and <m>\sigma</m> = <p>sigma</p> or the square root of <pf>variance</pf>, this function returns <m>-(x - \mu)^2/(2 \sigma^2) - \log(\sigma \sqrt{2\pi})</m>.</ret>
        <error code="13000">Raises an &quot;invalid parameterization&quot; error if <p>sigma</p> or <pf>variance</pf> is negative or any argument is not finite.</error>
        <error code="13001">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gaussianCDF">
      <sig>
        <par name="x">double</par>
        <par name="mu">double</par>
        <par name="sigma">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="params"><record label="A"><field name="mean">double</field><field name="variance">double</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the cumultive distribution function (CDF) for the normal distribution, parameterized by <p>mu</p> and <p>sigma</p> or a record <p>params</p>.</desc>
        <param name="x">Value at which to compute the CDF.</param>
        <param name="mu">Centroid of the distribution (same as <pf>mean</pf>).</param>
        <param name="sigma">Width of the distribution (same as the square root of <pf>variance</pf>).</param>
        <param name="params">Alternate way of specifying the parameters of the distribution; this record could be created by <f>stat.sample.update</f>.</param>
        <ret>With <m>\mu</m> = <p>mu</p> or <pf>mean</pf> and <m>\sigma</m> = <p>sigma</p> or the square root of <pf>variance</pf>, this function returns <m>0.5 * ( 1.0 + \mathrm{Erf}(\frac{x - \mu}{\sigma \sqrt{2}}))</m>.</ret>
        <error code="13010">Raises an &quot;invalid parameterization&quot; error if <p>sigma</p> or <pf>variance</pf> is negative or any argument is not finite.</error>
        <error code="13011">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gaussianQF">
      <sig>
        <par name="p">double</par>
        <par name="mu">double</par>
        <par name="sigma">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="p">double</par>
        <par name="params"><record label="A"><field name="mean">double</field><field name="variance">double</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the normal quantile (QF, the inverse of the CDF) parameterized by <p>mu</p> and <p>sigma</p> or a record <p>params</p>.</desc>
        <param name="p">Probability at which to compute the QF.  Must be a value between 0 and 1.</param>
        <param name="mu">Centroid of the distribution (same as <pf>mean</pf>).</param>
        <param name="sigma">Width of the distribution (same as the square root of <pf>variance</pf>).</param>
        <param name="params">Alternate way of specifying the parameters of the distribution; this record could be created by <f>stat.sample.update</f>.</param>
        <ret>With <m>\mu</m> = <p>mu</p> or <pf>mean</pf> and <m>\sigma</m> = <p>sigma</p> or the square root of <pf>variance</pf>, this function returns <m>\mu + \sigma \sqrt{2} \mathrm{Erf}^{-1} (2p - 1)</m>.</ret>
        <error code="13020">Raises an &quot;invalid parameterization&quot; error if <p>sigma</p> or <pf>variance</pf> is negative or any argument is not finite.</error>
        <error code="13021">Raises an &quot;invalid input&quot; error if <p>p</p> is less than zero or greater than one.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.exponentialPDF">
      <sig>
        <par name="x">double</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the exponential distribution parameterized by <p>lambda</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="lambda">Rate parameter.</param>

        <ret>With <m>lambda</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\lambda \mathrm{e}^{- \lambda x}</m>.</ret>
        <error code="13030">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
        <error code="13031">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.exponentialCDF">
      <sig>
        <par name="x">double</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the exponential distribution parameterized by <p>lambda</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="lambda">Rate parameter.</param>
        <ret>With <m>lambda</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13040">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
        <error code="13041">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.exponentialQF">
      <sig>
        <par name="p">double</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the exponential distribution parameterized by <p>lambda</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="lambda">Rate parameter.</param>
        <ret>With <m>lambda</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13050">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
        <error code="13051">Raises an &quot;invalid input&quot; error if <p>p</p> is less than zero or greater than one.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.chi2PDF">
      <sig>
        <par name="x">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the Chi-squared distribution parameterized by its degrees of freedom <p>dof</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="dof">Degrees of freedom parameter.</param>

        <ret>With <m>dof</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{1}{2^{\frac{\mathrm{df}}{2}} \Gamma(\frac{\mathrm{df}}{2})} x^{\frac{\mathrm{df}}{2}-1}\mathrm{e}^{-\frac{x}{2}}</m>.</ret> 
        <error code="13060">Raises &quot;invalid parameterization&quot; if <p>dof</p> &lt; 0 or any argument is not finite.</error>
        <error code="13061">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.chi2CDF">
      <sig>
        <par name="x">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the Chi-squared distribution parameterized by its degrees of freedom <p>dof</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="dof">Degrees of freedom parameter.</param>
        <ret>With <m>x1</m>, <m>x1</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13070">Raises &quot;invalid parameterization&quot; if <p>dof</p> &lt; 0 or any argument is not finite.</error>
        <error code="13071">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.chi2QF">
      <sig>
        <par name="p">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the Chi-squared distribution parameterized by its degrees of freedom <p>dof</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="dof">Degrees of freedom parameter.</param>
        <ret>With <m>x1</m>, <m>x1</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13080">Raises &quot;invalid parameterization&quot; if <p>dof</p> &lt; 0 or any argument is not finite.</error>
        <error code="13081">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.poissonPDF">
      <sig>
        <par name="x">int</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the poisson distribution parameterized by <p>lambda</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="lambda">Mean and variance parameter.</param>
        <ret>With <m>lambda</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\lambda^{x}}{x!} \mathrm{e}^{-\lambda}</m>.</ret> 
        <error code="13090">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.poissonCDF">
      <sig>
        <par name="x">int</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the poisson distribution parameterized by <p>lambda</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="lambda">Mean and variance parameter.</param>
        <ret>With <m>lambda</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13100">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
        <error code="13101">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.poissonQF">
      <sig>
        <par name="p">double</par>
        <par name="lambda">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the poisson distribution parameterized by <p>lambda</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="lambda">Mean and variance parameter.</param>
        <ret>With <m>lambda</m>, <m>lambda</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13110">Raises &quot;invalid parameterization&quot; if <m>lambda &lt; 0</m> or any argument is not finite.</error>
        <error code="13111">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gammaPDF">
      <sig>
        <par name="x">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the gamma distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="shape">Shape parameter (a).</param>
          <param name="scale">Scale parameter (s).</param>

        <ret>With <m>shape</m>, <m>scale</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{1}{s^{a} \Gamma(a)} x^{a - 1} \mathrm{e}^{-\frac{x}{s}}  </m>.</ret> 
        <error code="13120">Raises &quot;invalid parameterization&quot; if the <m>shape &lt; 0</m> OR if <m>scale &lt; 0</m> or any argument is not finite.</error>
        <error code="13121">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gammaCDF">
      <sig>
        <par name="x">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the gamma distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="shape">Shape parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>shape</m>, <m>scale</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x)~= P(X~\leq~x)</m>. </ret> 
        <error code="13130">Raises &quot;invalid parameterization&quot; if the <m>shape &lt; 0</m> OR if <m>scale &lt; 0</m> or any argument is not finite.</error>
        <error code="13131">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.gammaQF">
      <sig>
        <par name="p">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the gamma distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="shape">Shape parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>shape</m>, <m>scale</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x)~:= P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13140">Raises &quot;invalid parameterization&quot; if the <m>shape \leq 0</m> OR if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13141">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.betaPDF">
      <sig>
        <par name="x">double</par>
        <par name="a">double</par>
        <par name="b">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the beta distribution parameterized by <p>shape1</p> and <p>shape2</p>.</desc>
          <param name="x">Value at which to compute the PDF, defined between zero and one.</param>
          <param name="a">First shape parameter.</param>
          <param name="b">Second shape parameter.</param>
        <ret>With <m>a</m>, <m>b</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\Gamma(a + n)}{\Gamma(a)\Gamma(b)} x^{a-1}(1-x)^{b-1}</m>.</ret> 
        <error code="13150">Raises &quot;invalid parameterization&quot; if <m>a \leq 0</m> OR if <m>b \leq 0</m> or any argument is not finite.</error>
        <error code="13151">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.betaCDF">
      <sig>
        <par name="x">double</par>
        <par name="a">double</par>
        <par name="b">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the beta distribution parameterized by <p>shape1</p> and <p>shape2</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="a">First shape parameter.</param>
          <param name="b">Second shape parameter.</param>
        <ret>With <m>a</m>, <m>b</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13160">Raises &quot;invalid parameterization&quot; if <m>a \leq 0</m> OR if <m>b \leq 0</m> or any argument is not finite.</error>
        <error code="13161">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.betaQF">
      <sig>
        <par name="p">double</par>
        <par name="a">double</par>
        <par name="b">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the beta distribution parameterized by <p>shape1</p> and <p>shape2</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="a">First shape parameter.</param>
          <param name="b">Second shape parameter.</param>
        <ret>With <m>a</m>, <m>b</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13170">Raises &quot;invalid parameterization&quot; if the <m>a \leq 0</m> OR if <m>b \leq 0</m> or any argument is not finite.</error>
        <error code="13171">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.cauchyPDF">
      <sig>
        <par name="x">double</par>
        <par name="location">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the cauchy distribution parameterized by <p>location</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="location">Location parameter (l).</param>
          <param name="scale">Scale parameter (s).</param>

        <ret>With <m>location</m>, <m>scale</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{1}{(\pi s (1 + (\frac{x - l}{s})^{2})) }</m>.</ret> 
        <error code="13180">Raises &quot;invalid parameterization&quot; if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13181">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.cauchyCDF">
      <sig>
        <par name="x">double</par>
        <par name="location">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the cauchy distribution parameterized by <p>location</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="location">Location parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>location</m>, <m>scale</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13190">Raises &quot;invalid parameterization&quot; if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13191">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.cauchyQF">
      <sig>
        <par name="p">double</par>
        <par name="location">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the cauchy distribution parameterized by <p>location</p> and <p>scale</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="location">Location parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>location</m>, <m>scale</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
      <error code="13200">Raises &quot;invalid parameterization&quot; if <m>scale \leq 0</m> or any argument is not finite.</error>
      <error code="13201">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
    </doc>
    </fcn>

    <fcn name="prob.dist.fPDF">
      <sig>
        <par name="x">double</par>
        <par name="d1">int</par>
        <par name="d2">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the F distribution parameterized by <p>d1</p> and <p>d2</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="d1">Numerator degrees of freedom parameter.</param>
          <param name="d2">Denominator degrees of freedom parameter.</param>

        <ret>With <m>d1</m>, <m>d2</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\Gamma(\frac{d1 + d2}{2})}{\Gamma(\frac{d1}{2})\Gamma(\frac{d2}{2})} \frac{d1}{d2}^{\frac{d1}{2}-1}(1 + \frac{d1}{d2} x)^{-\frac{d1 + d2}{2}}</m>.</ret> 
        <error code="13210">Raises &quot;invalid parameterization&quot; if the <m>d1 \leq 0</m> OR if <m>d2 \leq 0</m> or any argument is not finite.</error>
        <error code="13211">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.fCDF">
      <sig>
        <par name="x">double</par>
        <par name="d1">int</par>
        <par name="d2">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the F distribution parameterized by <p>d1</p> and <p>d2</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="d1">Numerator degrees of freedom parameter.</param>
          <param name="d2">Denominator degrees of freedom parameter.</param>
        <ret>With <m>d1</m>, <m>d2</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13220">Raises &quot;invalid parameterization&quot; if the <m>d1 \leq 0</m> OR if <m>d2 \leq 0</m> or any argument is not finite.</error>
        <error code="13221">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.fQF">
      <sig>
        <par name="p">double</par>
        <par name="d1">int</par>
        <par name="d2">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the F distribution parameterized by <p>d1</p> and <p>d2</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="d1">Numerator degrees of freedom parameter.</param>
          <param name="d2">Denominator degrees of freedom parameter.</param>
        <ret>With <m>d1</m>, <m>d2</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13230">Raises &quot;invalid parameterization&quot; if the <m>d1 \leq 0</m> OR if <m>d2 \leq 0</m> or any argument is not finite.</error>
        <error code="13231">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.lognormalPDF">
      <sig>
        <par name="x">double</par>
        <par name="meanlog">double</par>
        <par name="sdlog">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the lognormal distribution parameterized by <p>meanlog</p> and <p>sdlog</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="meanlog">Mean of the distribution on the log scale (<m>\mu</m>).</param>
          <param name="sdlog">Standard deviation of the distribution on the log scale (<m>\sigma</m>).</param>

        <ret>With <m>meanlog</m>, <m>sdlog</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{1}{\sqrt{2 \pi} \sigma x} \mathrm{e}^{-\frac{\mathrm{log}(x) - \mu}{2 \sigma^{2}}}</m>.</ret> 
        <error code="13240">Raises &quot;invalid parameterization&quot; if <m>sdlog \leq 0</m> or any argument is not finite.</error>
        <error code="13241">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.lognormalCDF">
      <sig>
        <par name="x">double</par>
        <par name="meanlog">double</par>
        <par name="sdlog">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the lognormal distribution parameterized by <p>meanlog</p> and <p>sdlog</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="meanlog">Mean of the distribution on the log scale.</param>
          <param name="sdlog">Standard deviation of the distribution on the log scale.</param>
        <ret>With <m>meanlog</m>, <m>sdlog</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13250">Raises &quot;invalid parameterization&quot; if <m>sdlog \leq 0</m> or any argument is not finite.</error>
        <error code="13251">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.lognormalQF">
      <sig>
        <par name="p">double</par>
        <par name="meanlog">double</par>
        <par name="sdlog">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the lognormal distribution parameterized by <p>meanlog</p> and <p>sdlog</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="meanlog">Mean of the distribution on the log scale.</param>
          <param name="sdlog">Standard deviation of the distribution on the log scale.</param>
        <ret>With <m>meanlog</m>, <m>sdlog</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13260">Raises &quot;invalid parameterization&quot; if <m>sdlog \leq 0</m> or any argument is not finite.</error>
        <error code="13261">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.tPDF">
      <sig>
        <par name="x">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the student's t distribution parameterized by <p>dof</p> and <p>x2</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="dof">Degrees of freedom parameter.</param>
        <ret>With <m>dof</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\Gamma(\frac{\mathrm{df}+1}{2})}{\sqrt{\mathrm{df}\pi} \Gamma{\frac{\mathrm{df}}{2}}}(1 + x^{\frac{2}{n}})^{-\frac{\mathrm{df} + 1}{2}}</m>.</ret> 
        <error code="13270">Raises &quot;invalid parameterization&quot; if <m>df \leq 0</m> or any argument is not finite.</error>
        <error code="13271">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.tCDF">
      <sig>
        <par name="x">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the student's t distribution parameterized by <p>dof</p> and <p>x2</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="dof">Degrees of freedom parameter.</param>
        <ret>With <m>dof</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13280">Raises &quot;invalid parameterization&quot; if <m>df \leq 0</m> or any argument is not finite.</error>
        <error code="13281">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.tQF">
      <sig>
        <par name="p">double</par>
        <par name="dof">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the student's t distribution parameterized by <p>dof</p> and <p>x2</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="dof">Degrees of freedom parameter.</param>
        <ret>With <m>dof</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13290">Raises &quot;invalid parameterization&quot; if <m>df \leq 0</m> or any argument is not finite.</error>
        <error code="13291">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.binomialPDF">
      <sig>
        <par name="x">int</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="size">The number of trials (n).</param>
          <param name="prob">The probability of success in each trial (p).</param>

        <ret>With <m>size</m>, <m>prob</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\mathrm{choose}(n, x) p^{x} (1 - p)^{n - x}</m>.</ret> 
        <error code="13300">Raises &quot;invalid parameterization&quot; if <m>size &lt; 0</m> OR if <m>prob &lt; 0</m> OR if <m>prob &gt; 1</m> or any argument is not finite.</error>
        <error code="13301">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.binomialCDF">
      <sig>
        <par name="x">double</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="size">The number of trials.</param>
         <param name="prob">The probability of success in each trial.</param>
        <ret>With <m>size</m>, <m>prob</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13310">Raises &quot;invalid parameterization&quot; if <m>size &lt; 0</m> OR if <m>prob &lt; 0</m> OR if <m>prob &gt; 1</m> or any argument is not finite.</error>
        <error code="13311">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
     </doc>
    </fcn>

    <fcn name="prob.dist.binomialQF">
      <sig>
        <par name="p">double</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="size">The number of trials.</param>
          <param name="prob">The probability of success in each trial.</param>
        <ret>With <m>size</m>, <m>prob</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x)~:= P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13320">Raises &quot;invalid parameterization&quot; if <m>size &lt; 0</m> OR if <m>prob &lt; 0</m> OR if <m>prob &gt; 1</m> or any argument is not finite.</error>
        <error code="13321">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.uniformPDF">
      <sig>
        <par name="x">double</par>
        <par name="min">double</par>
        <par name="max">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the uniform distribution parameterized by <p>min</p> and <p>max</p>.</desc>
         <param name="x">Value at which to compute the PDF.</param>
         <param name="min">Lower bound.</param>
         <param name="max">Upper bound.</param>
        <ret>With <m>min</m>, <m>max</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{1}{\mathrm{max} - \mathrm{min}}</m>.</ret> 
        <error code="13330">Raises &quot;invalid parameterization&quot; if <m>min \geq max</m> or any argument is not finite.</error>
        <error code="13331">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.uniformCDF">
      <sig>
        <par name="x">double</par>
        <par name="min">double</par>
        <par name="max">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the uniform distribution parameterized by <p>min</p> and <p>max</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="min">Lower bound.</param>
          <param name="max">Upper bound.</param>
        <ret>With <m>min</m>, <m>max</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13340">Raises &quot;invalid parameterization&quot; if <m>min \geq max</m> or any argument is not finite.</error>
        <error code="13341">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.uniformQF">
      <sig>
        <par name="p">double</par>
        <par name="min">double</par>
        <par name="max">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the uniform distribution parameterized by <p>min</p> and <p>max</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="min">Lower bound.</param>
          <param name="max">Upper bound.</param>
        <ret>With <m>min</m>, <m>max</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13350">Raises &quot;invalid parameterization&quot; if <m>min \geq max</m> or any argument is not finite.</error>
        <error code="13351">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.geometricPDF">
      <sig>
        <par name="x">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the geometric distribution parameterized by <p>prob</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="prob">Probability of success of each trial (p).</param>
        <ret>With <m>prob</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>p (1 - p)^{x}</m>.</ret> 
        <error code="13360">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} \leq 0</m> OR if <m>\mathrm{prob} &gt; 1</m> or any argument is not finite.</error>
        <error code="13361">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.geometricCDF">
      <sig>
        <par name="x">double</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the geometric distribution parameterized by <p>prob</p>.</desc>
           <param name="x">Value at which to compute the CDF.</param>
           <param name="prob">Probability of success of each trial.</param>
        <ret>With <m>prob</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13370">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} \leq 0</m> OR if <m>\mathrm{prob} &gt; 1</m> or any argument is not finite.</error>
        <error code="13371">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.geometricQF">
      <sig>
        <par name="p">double</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the geometric distribution parameterized by <p>prob</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="prob">Probability of success of each trial.</param>
        <ret>With <m>prob</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13380">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} \leq 0</m> OR if <m>\mathrm{prob} &gt; 1</m> or any argument is not finite.</error>
        <error code="13381">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.hypergeometricPDF">
      <sig>
        <par name="x">int</par>
        <par name="m">int</par>
        <par name="n">int</par>
        <par name="k">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the hypergeometric distribution parameterized by <p>m</p>, <p>n</p> and <p>k</p>.</desc>
          <param name="x">The number of white balls drawn without replacement from the urn.</param>
          <param name="m">The number of white balls in the urn.</param>
          <param name="n">The number of black balls in the urn.</param>
          <param name="k">The number of balls drawn from the urn.</param>
        <ret>With <m>m</m>, <m>n</m> and <m>k</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\mathrm{choose}(m, x) \mathrm{choose}(n, k-x)}{\mathrm{choose}(m+n, k)} </m>. </ret> 
        <error code="13390">Raises &quot;invalid parameterization&quot; if <m>\mathrm{m} + \mathrm{n} &lt; \mathrm{k}</m>, <m>m &lt; 0</m>, <m>n &lt; 0</m>, <m>m + n = 0</m>, or <m>k &lt; 0</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.hypergeometricCDF">
      <sig>
        <par name="x">int</par>
        <par name="m">int</par>
        <par name="n">int</par>
        <par name="k">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the hypergeometric distribution parameterized by <p>m</p>, <p>n</p> and <p>k</p>.</desc>
          <param name="x">The number of white balls drawn without replacement.</param>
          <param name="m">The number of white balls in the urn.</param>
          <param name="n">The number of black balls in the urn.</param>
          <param name="k">The number of balls drawn from the urn.</param>
        <ret>With <m>m</m>, <m>n</m> and <m>k</m> at <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13400">Raises &quot;invalid parameterization&quot; if <m>\mathrm{m} + \mathrm{n} &lt; \mathrm{k}</m>, <m>m &lt; 0</m>, <m>n &lt; 0</m>, <m>m + n = 0</m>, or <m>k &lt; 0</m>.</error>
        <error code="13401">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.hypergeometricQF">
      <sig>
        <par name="p">double</par>
        <par name="m">int</par>
        <par name="n">int</par>
        <par name="k">int</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the hypergeometric distribution parameterized by <p>m</p>, <p>n</p> and <p>k</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="m">The number of white balls in the urn.</param>
          <param name="n">The number of black balls in the urn.</param>
          <param name="k">The number of balls drawn from the urn.</param>
        <ret>With <m>m</m>, <m>n</m> and <m>k</m> at <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x)~:= P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13410">Raises &quot;invalid parameterization&quot; if <m>\mathrm{m} + \mathrm{n} &lt; \mathrm{k}</m>, <m>m &lt; 0</m>, <m>n &lt; 0</m>, <m>m + n = 0</m>, or <m>k &lt; 0</m> or any argument is not finite.</error>
        <error code="13411">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.weibullPDF">
      <sig>
        <par name="x">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the weibull distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the PDF.</param>
          <param name="shape">Shape parameter (a).</param>
          <param name="scale">Scale parameter (b).</param>
         <ret>With <m>shape</m>, <m>scale</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{a}{b}(\frac{x}{b})^{a - 1}\mathrm{e}^{-(\frac{x}{b})^{a}}</m>.</ret> 
         <error code="13420">Raises &quot;invalid parameterization&quot; if the <m>shape \leq 0</m> OR if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13421">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.weibullCDF">
      <sig>
        <par name="x">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the weibull distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="shape">Shape parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>shape</m>, <m>scale</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X~\leq~x)</m>. </ret> 
        <error code="13430">Raises &quot;invalid parameterization&quot; if the <m>shape \leq 0</m> OR if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13431">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.weibullQF">
      <sig>
        <par name="p">double</par>
        <par name="shape">double</par>
        <par name="scale">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the weibull distribution parameterized by <p>shape</p> and <p>scale</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="shape">Shape parameter.</param>
          <param name="scale">Scale parameter.</param>
        <ret>With <m>shape</m>, <m>scale</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X~\leq~x)~=~p</m>. </ret> 
        <error code="13440">Raises &quot;invalid parameterization&quot; if the <m>shape \leq 0</m> OR if <m>scale \leq 0</m> or any argument is not finite.</error>
        <error code="13441">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.negativeBinomialPDF">
      <sig>
        <par name="x">int</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the density (PDF) of the negative binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="x">Value at which to compute the PDF (integer) .</param>
          <param name="size">Size parameter (integer).  Target number of successful trials (n).</param>
          <param name="prob">Probability of success in each trial (p).</param>
        <ret>With <m>size</m>, <m>prob</m> and <m>x</m>, this function evaluates the probability density function at <m>x</m>.  The PDF implemented is <m>\frac{\Gamma(x+n)}{\Gamma(n) x!} p^{n} (1-p)^{x}</m>.</ret> 
        <error code="13450">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} &lt; 0</m>, if <m>\mathrm{prob} &gt; 1</m> or if <m>size &lt; 0</m> or any argument is not finite.</error>
        <error code="13451">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.negativeBinomialCDF">
      <sig>
        <par name="x">double</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the distribution function (CDF) of the negative binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="x">Value at which to compute the CDF.</param>
          <param name="size">Size parameter (integer).  Target number of successful trials.</param>
          <param name="prob">Probability of success in each trial.</param>
        <ret>With <m>size</m>, <m>prob</m> and <m>x</m>, this function returns the value <m>p</m> where <m>p = F_{X}(x) = P(X \leq x)</m>. </ret> 
        <error code="13460">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} &lt; 0</m>, if <m>\mathrm{prob} &gt; 1</m>, or if <m>size &lt; 0</m> or any argument is not finite.</error>
        <error code="13461">Raises &quot;invalid input&quot; if <p>x</p> is not finite.</error>
      </doc>
    </fcn>

    <fcn name="prob.dist.negativeBinomialQF">
      <sig>
        <par name="p">double</par>
        <par name="size">int</par>
        <par name="prob">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compute the quantile function (QF) of the negative binomial distribution parameterized by <p>size</p> and <p>prob</p>.</desc>
          <param name="p">Value at which to compute the QF.  Must be a value between 0 and 1.</param>
          <param name="size">Size parameter (integer).  Target number of successful trials.</param>
          <param name="prob">Probability of success in each trial.</param>
        <ret>With <m>size</m>, <m>prob</m> and <m>p</m>, this function returns the value <m>x</m> such that <m>F_{X}(x) := P(X \leq x) = p</m>. </ret> 
        <error code="13470">Raises &quot;invalid parameterization&quot; if <m>\mathrm{prob} &lt; 0</m>, if <m>\mathrm{prob} &gt; 1</m>, or if <m>size \leq 0</m>, or if <m>size</m> or any argument is not finite.</error>
        <error code="13471">Raises &quot;invalid input&quot; if <m>p &lt; 0</m> OR if <m>p &gt; 1</m>.</error>
      </doc>
    </fcn>

    <fcn name="stat.test.kolmogorov">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="y"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compare two datasets using the Kolmogorov-Smirnov test to determine if they might have been drawn from the same parent distribution.</desc>
        <param name="x">A bag of data.</param>
        <param name="y">Another bag of data.</param>
        <ret>Returns a value between 0.0 and 1.0 representing the cumulative probability that <p>x</p> and <p>y</p> were drawn from the same distribution: 1.0 indicates a perfect match.</ret>
        <detail>If both datasets (ignoring NaN values) are empty, this function returns 1.0</detail>
      </doc>
    </fcn>

    <fcn name="stat.test.residual">
      <sig>
        <par name="observation">double</par>
        <par name="prediciton">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="observation"><array>double</array></par>
        <par name="prediciton"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="observation"><map>double</map></par>
        <par name="prediciton"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by element-wise subtraction.</desc>
        <param name="observation">Scalar or vector of observations.</param>
        <param name="prediction">Scalar or vector of predictions.</param>
        <ret>Scalar or vector of <p>observation</p> minus <p>prediction</p>.</ret>
        <error code="38010">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes or keys as <p>observation</p>.</error>
      </doc>
    </fcn>

    <fcn name="stat.test.pull">
      <sig>
        <par name="observation">double</par>
        <par name="prediciton">double</par>
        <par name="uncertainty">double</par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="observation"><array>double</array></par>
        <par name="prediciton"><array>double</array></par>
        <par name="uncertainty"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="observation"><map>double</map></par>
        <par name="prediciton"><map>double</map></par>
        <par name="uncertainty"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties.</desc>
        <param name="observation">Scalar or vector of observations.</param>
        <param name="prediction">Scalar or vector of predictions.</param>
        <param name="uncertainty">Scalar or vector of predictions.</param>
        <ret>Scalar or vector of <p>observation</p> minus <p>prediction</p> divided by <p>uncertainty</p>.</ret>
        <error code="38020">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes or keys as <p>observation</p>.</error>
        <error code="38021">Raises a &quot;misaligned uncertainty&quot; error if <p>prediction</p> does not have the same indexes or keys as <p>uncertainty</p>.</error>
      </doc>
    </fcn>

    <fcn name="stat.test.mahalanobis">
      <sig>
        <par name="observation"><array>double</array></par>
        <par name="prediction"><array>double</array></par>
        <par name="covariance"><array><array>double</array></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="observation"><map>double</map></par>
        <par name="prediction"><map>double</map></par>
        <par name="covariance"><map><map>double</map></map></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix.</desc>
        <param name="observation">Vector of observations <m>\vec{o}</m>.</param>
        <param name="prediction">Vector of predictions <m>\vec{p}</m>.</param>
        <param name="covariance">Matrix of covariance <m>C</m>.</param>
        <ret>Scalar result of a similarity transformation: <m>\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}</m>.</ret>
        <error code="38030">Raises a &quot;too few rows/cols&quot; error if <p>observation</p> has fewer than one element.</error>
        <error code="38031">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes or keys as <p>observation</p>.</error>
        <error code="38032">Raises a &quot;misaligned covariance&quot; error if <p>covariance</p> does not have the same indexes or keys as <p>observation</p>.</error>
      </doc>
    </fcn>

    <fcn name="stat.test.updateChi2">
      <sig>
        <par name="pull">double</par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="dof">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig>
        <par name="pull"><array>double</array></par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="dof">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig>
        <par name="pull"><map>double</map></par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="dof">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a chi-square calculation.</desc>
        <param name="pull">Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.</param>
        <param name="state">Record of the previous <pf>chi2</pf> and <pf>dof</pf>.</param>
      </doc>
    </fcn>

    <fcn name="stat.test.reducedChi2">
      <sig>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="dof">int</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the reduced chi-square, which is <pf>chi2</pf>/<pf>dof</pf>.</desc>
        <param name="state">Record of the <pf>chi2</pf> and <pf>dof</pf>.</param>
      </doc>
    </fcn>

    <fcn name="stat.test.chi2Prob">
      <sig>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="dof">int</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the chi-square probability, which is the CDF of the chi-square function.</desc>
        <param name="state">Record of the <pf>chi2</pf> and <pf>dof</pf>.</param>
        <error code="38060">Raises &quot;invalid parameterization&quot; if <pf>dof</pf> is less than zero.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.update">
      <sig>
        <par name="x">double</par>
        <par name="w">double</par>
        <par name="state"><record label="A"><field name="count">double</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a counter, a counter and a mean, or a counter, mean, and variance.</desc>
        <param name="x">Sample value.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="state">Record of the previous <pf>count</pf>, <pf>mean</pf>, and/or <pf>variance</pf>.
          <paramField name="count">The sum of weights <p>w</p>.</paramField>
          <paramField name="mean">The mean of <p>x</p>, weighted by <p>w</p>.  This field is optional, but if provided, it must be a <c>double</c>.</paramField>
          <paramField name="variance">The variance of <m>x - \mbox{mean}</m>, weighted by <p>w</p>.  This field is optional, but if it is provided, it must be a <c>double</c>, and there must be a <pf>mean</pf> as well.  No attempt is made to unbias the estimator, so multiply this by <m>\mbox{count}/(\mbox{count} - 1)</m> to correct for the bias due to centering on the mean.</paramField>
        </param>
        <ret>Returns an updated version of <p>state</p> with <pf>count</pf> incremented by <p>w</p>, <pf>mean</pf> updated to the current mean of all <p>x</p>, and <pf>variance</pf> updated to the current variance of all <p>x</p>.  If the <p>state</p> has fields other than <pf>count</pf>, <pf>mean</pf>, and <pf>variance</pf>, they are copied unaltered to the output state.</ret>
    </doc>
    </fcn>

    <fcn name="stat.sample.updateCovariance">
      <sig>
        <par name="x"><array>double</array></par>
        <par name="w">double</par>
        <par name="state"><record label="A"><field name="count">double</field><field name="mean"><array>double</array></field><field name="covariance"><array><array>double</array></array></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig>
        <par name="x"><map>double</map></par>
        <par name="w">double</par>
        <par name="state"><record label="A"><field name="count"><map><map>double</map></map></field><field name="mean"><map>double</map></field><field name="covariance"><map><map>double</map></map></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a covariance calculation.</desc>
        <param name="x">Sample vector, expressed as an array or map; must have at least two components.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="state">Record of the previous <pf>count</pf>, <pf>mean</pf>, and <pf>covariance</pf>.
          <paramField name="count">The sum of weights <p>w</p>.  If <p>x</p> is an array, then <pf>count</pf> is a single value representing the sum of weights for all records seen so far.  If <p>x</p> is a map, then <pf>count</pf> is a matrix in which entry <m>i</m>, <m>j</m> is the sum of weights for records in which key <m>i</m> and key <m>j</m> both appear in <p>x</p>.</paramField>
          <paramField name="mean">The componentwise mean of <p>x</p>, weighted by <p>w</p>.</paramField>
          <paramField name="covariance">The covariance matrix of all pairs of components of <p>x</p>, weighted by <p>w</p>.  If <p>x</p> is an array, this matrix is represented by a list of lists.  If <p>x</p> is a map, this matrix is represented by a map of maps.</paramField>
        </param>
        <ret>Returns an updated version of <p>state</p> with <pf>count</pf> incremented by <p>w</p>, <pf>mean</pf> updated to the current componentwise mean of all <p>x</p>, and <pf>covariance</pf> updated to the current covariance matrix of all <p>x</p>.  If the <p>state</p> has fields other than <pf>count</pf>, <pf>mean</pf>, and <pf>covariance</pf>, they are copied unaltered to the output state.</ret>
        <detail>Like most functions that deal with matrices, this function has an array signature and a map signature.  In the array signature, indexes of <p>x</p> correspond to the same indexes of <pf>mean</pf> and rows and columns of <pf>covariance</pf>, where a row is an index of <pf>covariance</pf> and a column is an index of an element of <pf>covariance</pf>.  In the map signature, keys of <p>x</p> correspond to the same keys of <pf>mean</pf>, as well as rows and columns of <pf>count</pf> and <pf>covariance</pf>, where a row is a key of the object and a column is a key of a value of the object.  In the array signature, all arrays must have equal length (including the nested arrays within <pf>covariance</pf>) and all components are updated with each call.  In the map signature, a previously unseen key in <p>x</p> creates a new key in <pf>mean</pf> with value <p>x</p>, a new row and column in <pf>count</pf> with value <p>w</p> for all key pairs existing in <p>x</p> and zero for key pairs not in <p>x</p>, as well as a new row and column in <pf>covariance</pf> filled with zeros.</detail>
        <detail>In the map signature, missing keys in <p>x</p> are equivalent to contributions with zero weight.</detail>
        <error code="14011">If <p>x</p> has fewer than 2 components, a &quot;too few components&quot; error is raised.</error>
        <error code="14012">If <p>x</p>, <pf>mean</pf>, and <pf>covariance</pf> are arrays with unequal lengths, an &quot;unequal length arrays&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.updateWindow">
      <sig>
        <par name="x">double</par>
        <par name="w">double</par>
        <par name="state"><array><record label="A"><field name="x">double</field><field name="w">double</field><field name="count">double</field></record></array></par>
        <par name="windowSize">int</par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Update the state of a counter, a counter and a mean, or a counter, mean, and variance, within a window of <p>windowSize</p> recent samples.</desc>
        <param name="x">Sample value.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="state">Array of previous <pf>count</pf>, <pf>mean</pf>, and/or <pf>variance</pf> and samples in the window.
          <paramField name="x">Sample value, saved so that it can be removed from the running mean and variance when it goes out of scope.</paramField>
          <paramField name="w">Sample weight, saved for the same reason.</paramField>
          <paramField name="count">The sum of weights <p>w</p> within the window.</paramField>
          <paramField name="mean">The mean of <p>x</p> within the window, weighted by <p>w</p>.  This field is optional, but if provided, it must be a <c>double</c>.</paramField>
          <paramField name="variance">The variance of <m>x - \mbox{mean}</m> within the window, weighted by <p>w</p>.  This field is optional, but if it is provided, it must be a <c>double</c>, and there must be a <pf>mean</pf> as well.  No attempt is made to unbias the estimator, so multiply this by <m>\mbox{count}/(\mbox{count} - 1)</m> to correct for the bias due to centering on the mean.</paramField>
        </param>
        <param name="windowSize">Size of the window.  When the length of <p>state</p> is less than <p>windowSize</p>, this function is equivalent to <f>stat.sample.update</f>.</param>
        <ret>If the length of <p>state</p> is zero, this function returns a singleton array with <pf>count</pf> = <p>w</p>, <pf>mean</pf> = <p>x</p>, and/or <pf>variance</pf> = 0.  If the length of <p>state</p> is less than <p>windowSize</p>, then it returns a copy of <p>state</p> with the next record added.  Otherwise, it is trunctated to <p>windowSize</p>, removing the old values from the running count/mean/variance.  In all cases, the <f>a.last</f> item is the latest result.</ret>
        <error code="14020">If <p>windowSize</p> is less than 2, a &quot;windowSize must be at least 2&quot; error is raised.</error>
        <error code="14021">If <p>state</p> is empty and the record type has fields other than <pf>x</pf>, <pf>w</pf>, <pf>count</pf>, <pf>mean</pf>, and <pf>variance</pf>, then a &quot;cannot initialize unrecognized fields&quot; error is raised.  Unrecognized fields are only allowed if an initial record is provided.</error>
    </doc>
    </fcn>

    <fcn name="stat.sample.updateEWMA">
      <sig>
        <par name="x">double</par>
        <par name="alpha">double</par>
        <par name="state"><record label="A"><field name="mean">double</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of an exponentially weighted moving average (EWMA).</desc>
        <param name="x">Sample value.</param>
        <param name="alpha">Weighting factor (usually a constant) between 0 and 1, inclusive.  If <p>alpha</p> is close to 1, recent data are heavily weighted at the expense of old data; if <p>alpha</p> is close to 0, the EWMA approaches a simple mean.</param>
        <param name="state">Record of the previous <pf>mean</pf> and <pf>variance</pf>.
          <paramField name="mean">The exponentially weighted mean of <p>x</p>, weighted by <p>alpha</p>.</paramField>
          <paramField name="variance">The exponentially weighted variance of <p>x</p>, weighted by <p>alpha</p>.  This field is optional, but if provided, it must be a <c>double</c>.</paramField>
        </param>
        <ret>Returns a new record with updated <pf>mean</pf> and <pf>variance</pf>.  If the input <p>state</p> has fields other than <pf>mean</pf> and <pf>variance</pf>, they are copied unaltered to the output state.</ret>
        <error code="14030">If <p>alpha</p> is less than 0 or greater than 1, an &quot;alpha out of range&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.updateHoltWinters">
      <sig>
        <par name="x">double</par>
        <par name="alpha">double</par>
        <par name="beta">double</par>
        <par name="state"><record label="A"><field name="level">double</field><field name="trend">double</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a time series analysis with an exponentially weighted linear fit.</desc>
        <param name="x">Sample value.</param>
        <param name="alpha">Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <pf>level</pf>.  If <p>alpha</p> is close to 1, recent data are heavily weighted at the expense of old data.</param>
        <param name="beta">Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <pf>trend</pf>.  If <p>beta</p> is close to 1, recent data are heavily weighted at the expense of old data.</param>
        <param name="state">Record of the previous <pf>level</pf> and <pf>trend</pf>.
          <paramField name="level">The constant term in an exponentially weighted linear fit of recent data, weighted by <p>alpha</p>.</paramField>
          <paramField name="trend">The linear term in an exponentially weighted linear fit of recent data, weighted by <p>beta</p>.</paramField>
        </param>
        <ret>Returns an updated version of the <p>state</p>.</ret>
        <detail>Use <f>stat.sample.forecast1HoltWinters</f> or <f>stat.sample.forecastHoltWinters</f> to make predictions from the state record.</detail>
        <detail>For <m>a_t</m> = the <pf>level</pf> at a time <m>t</m> and <m>b_t</m> = the <pf>trend</pf> at a time <m>t</m>, <m>a_t = \alpha x + (1 - \alpha)(a_{t-1} + b_{t-1})</m> and <m>b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}</m>.</detail>
        <error code="14040">If <p>alpha</p> is less than 0 or greater than 1, an &quot;alpha out of range&quot; error is raised.</error>
        <error code="14041">If <p>beta</p> is less than 0 or greater than 1, an &quot;beta out of range&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.updateHoltWintersPeriodic">
      <sig>
        <par name="x">double</par>
        <par name="alpha">double</par>
        <par name="beta">double</par>
        <par name="gamma">double</par>
        <par name="state"><record label="A"><field name="level">double</field><field name="trend">double</field><field name="cycle"><array>double</array></field><field name="multiplicative">boolean</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a time series analysis with an exponentially weighted periodic-plus-linear fit.</desc>
        <param name="x">Sample value.</param>
        <param name="alpha">Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <pf>level</pf>.  If <p>alpha</p> is close to 1, recent data are heavily weighted at the expense of old data.</param>
        <param name="beta">Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <pf>trend</pf>.  If <p>beta</p> is close to 1, recent data are heavily weighted at the expense of old data.</param>
        <param name="gamma">Weighting factor (usually a constant) between 0 and 1, inclusive, that governs the responsiveness of the <pf>cycle</pf>.  If <p>gamma</p> is close to 1, recent data are heavily weighted at the expense of old data.</param>
        <param name="state">Record of the previous <pf>level</pf>, <pf>trend</pf>, and <pf>cycle</pf>.
          <paramField name="level">The constant term in an exponentially weighted linear fit of recent data, weighted by <p>alpha</p>.</paramField>
          <paramField name="trend">The linear term in an exponentially weighted linear fit of recent data, weighted by <p>beta</p>.</paramField>
          <paramField name="cycle">The history of the previous cycle, weighted by <p>gamma</p>.  If the length of this array is <m>L</m>, then the built-in period is <m>L</m> time steps long.</paramField>
          <paramField name="multiplicative">If <c>true</c>, interpret <pf>cycle</pf> as multiplicative; if <c>false</c>, interpret it as additive.</paramField>
        </param>
        <ret>Returns an updated version of the <p>state</p>.</ret>
        <detail>Use <f>stat.sample.forecast1HoltWinters</f> or <f>stat.sample.forecastHoltWinters</f> to make predictions from the state record.</detail>
        <detail>For <m>a_t</m> = the <pf>level</pf> at a time <m>t</m>, <m>b_t</m> = the <pf>trend</pf> at a time <m>t</m>, and <m>c_t</m> = the <pf>cycle</pf> at a time <m>t</m> with period <m>L</m>, <m>a_t = \alpha x_t / c_{t-L} + (1 - \alpha)(a_{t-1} + b_{t-1})</m>, <m>b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}</m>, and <m>c_t = \gamma x_t / a_t + (1 - \gamma) c_{t-L}</m> for the multiplicative case and <m>a_t = \alpha (x_t - c_{t-L}) + (1 - \alpha)(a_{t-1} + b_{t-1})</m>, <m>b_t = \beta (a_t - a_{t-1}) + (1 - \beta) b_{t-1}</m>, and <m>c_t = \gamma (x_t - a_t) + (1 - \gamma) c_{t-L}</m> for the additive case.</detail>
        <detail>In each call to this function, <pf>cycle</pf> is rotated left, such that the first item is <m>c_t</m>.</detail>
        <error code="14050">If <p>alpha</p> is less than 0 or greater than 1, an &quot;alpha out of range&quot; error is raised.</error>
        <error code="14051">If <p>beta</p> is less than 0 or greater than 1, an &quot;beta out of range&quot; error is raised.</error>
        <error code="14052">If <p>gamma</p> is less than 0 or greater than 1, an &quot;gamma out of range&quot; error is raised.</error>
        <error code="14053">If <pf>cycle</pf> is empty, an &quot;empty cycle&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.forecast1HoltWinters">
      <sig>
        <par name="state"><record label="A"><field name="level">double</field><field name="trend">double</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Forecast one time-step from a state record prepared by <f>stat.state.updateHoltWinters</f> or <f>stat.state.updateHoltWintersPeriodic</f>.</desc>
        <param name="state">Record of <pf>level</pf>, <pf>trend</pf>, and possibly <pf>cycle</pf> and <pf>multiplicative</pf>.
          <paramField name="level">The constant term in an exponentially weighted linear fit of recent data.</paramField>
          <paramField name="trend">The linear term in an exponentially weighted linear fit of recent data.</paramField>
          <paramField name="cycle">The history of the previous cycle.  This field is optional, but if provided, it must be an array of <c>double</c> and must be accompanied by <pf>multiplicative</pf>.</paramField>
          <paramField name="multiplicative">If <c>true</c>, interpret <pf>cycle</pf> as multiplicative; if <c>false</c>, interpret it as additive.  This field is optional, but if provided, it must be a <c>boolean</c> and must be accompanied by <pf>cycle</pf>.</paramField>
        </param>
        <ret>Returns a prediction of the next time-step.</ret>
        <detail>For <m>a_t</m> = the <pf>level</pf> at a time <m>t</m>, <m>b_t</m> = the <pf>trend</pf> at a time <m>t</m>, and <m>c_t</m> = the <pf>cycle</pf> at a time <m>t</m> with period <m>L</m>, this function returns <m>a_t + b_t</m> (non-periodic), <m>(a_t + b_t) c_{t+1}</m> (multiplicative), or <m>a_t + b_t + c_{t+1}</m> (additive) for each <m>i</m> from <m>0</m> to <m>n - 1</m></detail>
        <error code="14060">If <pf>cycle</pf> is empty, an &quot;empty cycle&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.forecastHoltWinters">
      <sig>
        <par name="n">int</par>
        <par name="state"><record label="A"><field name="level">double</field><field name="trend">double</field></record></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Forecast <p>n</p> time-steps from a state record prepared by <f>stat.state.updateHoltWinters</f> or <f>stat.state.updateHoltWintersPeriodic</f>.</desc>
        <param name="state">Record of <pf>level</pf>, <pf>trend</pf>, and possibly <pf>cycle</pf> and <pf>multiplicative</pf>.
          <paramField name="level">The constant term in an exponentially weighted linear fit of recent data.</paramField>
          <paramField name="trend">The linear term in an exponentially weighted linear fit of recent data.</paramField>
          <paramField name="cycle">The history of the previous cycle.  This field is optional, but if provided, it must be a <c>double</c> and must be accompanied by <pf>multiplicative</pf>.</paramField>
          <paramField name="multiplicative">If <c>true</c>, interpret <pf>cycle</pf> as multiplicative; if <c>false</c>, interpret it as additive.  This field is optional, but if provided, it must be a <c>boolean</c> and must be accompanied by <pf>cycle</pf>.</paramField>
        </param>
        <ret>Returns a series of predictions for the next <p>n</p> time-steps.</ret>
        <detail>For <m>a_t</m> = the <pf>level</pf> at a time <m>t</m>, <m>b_t</m> = the <pf>trend</pf> at a time <m>t</m>, and <m>c_t</m> = the <pf>cycle</pf> at a time <m>t</m> with period <m>L</m>, this function returns <m>a_t + i b_t</m> (non-periodic), <m>(a_t + i b_t) c_{(t + i) \mbox{mod} n}</m> (multiplicative), or <m>a_t + i b_t + c_{(t + i) \mbox{mod} n}</m> (additive) for each <m>i</m> from <m>1</m> to <m>n</m></detail>
        <error code="14070">If <pf>cycle</pf> is empty, an &quot;empty cycle&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.fillHistogram">
      <sig>
        <par name="x">double</par>
        <par name="w">double</par>
        <par name="histogram"><record label="A"><field name="numbins">int</field><field name="low">double</field><field name="high">double</field><field name="values"><array>double</array></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="w">double</par>
        <par name="histogram"><record label="A"><field name="low">double</field><field name="binsize">double</field><field name="values"><array>double</array></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="w">double</par>
        <par name="histogram"><record label="A"><field name="ranges"><array><array>double</array></array></field><field name="values"><array>double</array></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update a histogram by filling it with one value.</desc>
        <param name="x">Sample value.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="histogram">The histogram prior to filling.  It must have <pf>numbins</pf>, <pf>low</pf>, <pf>high</pf>, and <pf>values</pf> (fixed bins) xor it must have <pf>low</pf>, <pf>binsize</pf>, and <pf>values</pf> (number of equal-sized bins grows), xor it must have <pf>ranges</pf> and <pf>values</pf> (arbitrary interval bins).  Only one set of required fields is allowed (semantic error otherwise), and the rest of the fields are optional.
          <paramField name="numbins">The fixed number of bins in the histogram.</paramField>
          <paramField name="low">The low edge of the histogram range (inclusive).</paramField>
          <paramField name="high">The high edge of the histogram range (exclusive).</paramField>
          <paramField name="binsize">The size of a bin for a histogram whose number of bins and right edge grows with the data.</paramField>
          <paramField name="ranges">Pairs of values describing arbitrary interval bins.  The first number of each pair is the inclusive left edge and the second number is the exclusive right edge.</paramField>
          <paramField name="values">Histogram contents, which are updated by this function.</paramField>
          <paramField name="underflow">If present, this double-valued field counts <p>x</p> values that are less than <pf>low</pf> or not contained in any <pf>ranges</pf>.</paramField>
          <paramField name="overflow">If present, this double-valued field counts <p>x</p> values that are greater than <pf>high</pf>.</paramField>
          <paramField name="nanflow">If present, this double-valued field counts <p>x</p> values that are <c>nan</c>.  <c>nan</c> values would never enter <pf>values</pf>, <pf>underflow</pf>, or <pf>overflow</pf>.</paramField>
          <paramField anme="infflow">If present, this double-valued field counts <p>x</p> values that are infinite.  Infinite values would only enter <pf>underflow</pf> or <pf>overflow</pf> if <pf>infflow</pf> is not present, so that they are not double-counted.</paramField>
        </param>
        <ret>Returns an updated version of <p>histogram</p>: all fields are unchanged except for <pf>values</pf>, <pf>underflow</pf>, <pf>overflow</pf>, <pf>nanflow</pf>, and <pf>infflow</pf>.</ret>
        <detail>If the histogram is growable (described by <pf>low</pf> and <pf>binsize</pf>) and <p>x</p> minus <pf>low</pf> is greater than or equal to <pf>binsize</pf> times the length of <pf>values</pf>, the <pf>values</pf> will be padded with zeros to reach it.</detail>
        <detail>If the histogram is growable (described by <pf>low</pf> and <pf>binsize</pf>), only finite values can extend the size of the histogram: infinite values are entered into <pf>overflow</pf> or <pf>infflow</pf>, depending on whether <pf>infflow</pf> is present.</detail>
        <detail>If the histogram is described by <pf>ranges</pf> and an element of <pf>ranges</pf> contains two equal values, then <p>x</p> is considered in the interval if it is exactly equal to the value.</detail>
        <detail>If the histogram is described by <pf>ranges</pf> and <p>x</p> falls within multiple, overlapping intervals, then all matching counters are updated (values can be double-counted).</detail>
        <error code="14080">If the length of <pf>values</pf> is not equal to <pf>numbins</pf> or the length of <pf>ranges</pf>, then a &quot;wrong histogram size&quot; error is raised.</error>
        <error code="14081">If <pf>low</pf> is greater than or equal to <pf>high</pf>, then a &quot;bad histogram range&quot; error is raised.</error>
        <error code="14082">If <pf>numbins</pf> is less than 1 or <pf>binsize</pf> is less than or equal to 0, then a &quot;bad histogram scale&quot; error is raised.</error>
        <error code="14083">If <pf>ranges</pf> contains an array of doubles with length not equal to 2 or if the first element is greater than the second element, then a &quot;bad histogram ranges&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.fillHistogram2d">
      <sig>
        <par name="x">double</par>
        <par name="y">double</par>
        <par name="w">double</par>
        <par name="histogram"><record label="A"><field name="xnumbins">int</field><field name="xlow">double</field><field name="xhigh">double</field><field name="ynumbins">int</field><field name="ylow">double</field><field name="yhigh">double</field><field name="values"><array><array>double</array></array></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update a two-dimensional histogram by filling it with one value.</desc>
        <param name="x">Sample x value.</param>
        <param name="y">Sample y value.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="histogram">The histogram prior to filling.
          <paramField name="xnumbins">The number of bins in the x dimension.</paramField>
          <paramField name="xlow">The low edge of the histogram range in the x dimension (inclusive).</paramField>
          <paramField name="xhigh">The high edge of the histogram range in the x dimension (exclusive).</paramField>
          <paramField name="ynumbins">The number of bins in the y dimension.</paramField>
          <paramField name="ylow">The low edge of the histogram range in the y dimension (inclusive).</paramField>
          <paramField name="yhigh">The high edge of the histogram range in the y dimension (exclusive).</paramField>
          <paramField name="values">Histogram contents, which are updated by this function.  The outer array iterates over <p>x</p> and the inner array iterates over <p>y</p>.</paramField>
          <paramField name="underunderflow">If present, this double-valued field counts instances in which <p>x</p> is less than <pf>xlow</pf> and <p>y</p> is less than <pf>ylow</pf>.</paramField>
          <paramField name="undermidflow">If present, this double-valued field counts instances in which <p>x</p> is less than <pf>xlow</pf> and <p>y</p> between <pf>ylow</pf> (inclusive) and <pf>yhigh</pf> (exclusive).</paramField>
          <paramField name="underoverflow">If present, this double-valued field counts instances in which <p>x</p> is less than <pf>xlow</pf> and <p>y</p> is greater than or equal to <pf>yhigh</pf>.</paramField>
          <paramField name="midunderflow">If present, this double-valued field counts instances in which <p>x</p> is between <pf>xlow</pf> (inclusive) and <pf>xhigh</pf> (exclusive) and <p>y</p> is less than <pf>ylow</pf>.</paramField>
          <paramField name="midoverflow">If present, this double-valued field counts instances in which <p>x</p> is between <pf>xlow</pf> (inclusive) and <pf>xhigh</pf> (exclusive) and <p>y</p> is greater than or equal to <pf>yhigh</pf>.</paramField>
          <paramField name="overunderflow">If present, this double-valued field counts instances in which <p>x</p> is greater than or equal to <pf>xhigh</pf> and <p>y</p> is less than <pf>ylow</pf>.</paramField>
          <paramField name="overmidflow">If present, this double-valued field counts instances in which <p>x</p> is greater than or equal to <pf>xhigh</pf> and <p>y</p> between <pf>ylow</pf> (inclusive) and <pf>yhigh</pf> (exclusive).</paramField>
          <paramField name="overoverflow">If present, this double-valued field counts instances in which <p>x</p> is greater than or equal to <pf>xhigh</pf> and <p>y</p> is greater than or equal to <pf>yhigh</pf>.</paramField>
          <paramField name="nanflow">If present, this double-valued field counts instances in which <p>x</p> or <p>y</p> is <c>nan</c>.  <c>nan</c> values would never enter any other counter.</paramField>
          <paramField name="infflow">If present, this double-valued field counts instances in which <p>x</p> or <p>y</p> is infinite.  Infinite values would only enter the other under/mid/overflow counters if <pf>infflow</pf> were not present, so that they are not double-counted.</paramField>
        </param>
        <ret>Returns an updated version of <p>histogram</p>: all fields are unchanged except for <pf>values</pf> and the under/mid/over/nan/infflow counters.</ret>
        <detail>If <p>x</p> is infinite and <p>y</p> is <c>nan</c> or <p>x</p> is <c>nan</c> and <p>y</p> is infinite, the entry is counted as <c>nan</c>, rather than infinite.</detail>
        <error code="14090">If the length of <pf>values</pf> is not equal to <pf>xnumbins</pf> or the length of any element of <pf>values</pf> is not equal to <pf>ynumbins</pf>, then a &quot;wrong histogram size&quot; error is raised.</error>
        <error code="14091">If <pf>xlow</pf> is greater than or equal to <pf>xhigh</pf> or if <pf>ylow</pf> is greater than or equal to <pf>yhigh</pf>, then a &quot;bad histogram range&quot; error is raised.</error>
        <error code="14092">If <pf>xnumbins</pf> is less than 1 or <pf>ynumbins</pf> is less than 1, then a &quot;bad histogram scale&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.sample.fillCounter">
      <sig>
        <par name="x">string</par>
        <par name="w">double</par>
        <par name="counter"><record label="A"><field name="values"><map>double</map></field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update a counter (sparse histogram) by filling it with one value.</desc>
        <param name="x">Sample category.</param>
        <param name="w">Sample weight; set to 1 for no weights.</param>
        <param name="histogram">The counter prior to filling.
          <paramField name="values">Number of instances seen of each category.</paramField>
        </param>
        <ret>Returns the updated counter.</ret>
        <detail>If a category is not present in the initial <pf>values</pf>, it is added with initial value zero prior to filling.</detail>
      </doc>
    </fcn>

    <fcn name="stat.sample.topN">
      <sig>
        <par name="x"><any label="A"/></par>
        <par name="top"><array><ref label="A"/></array></par>
        <par name="n">int</par>
        <par name="lessThan">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="A"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><array><ref label="A"/></array></ret>
      </sig>
      <doc>
        <desc>Update an array of the top <p>n</p> sorted items by potentially adding <p>x</p> to that array, using <p>lessThan</p> as a comparison function.</desc>
        <param name="x">Sample value.</param>
        <param name="top">Array of items to which <p>x</p> might be added.  This array is assumed to be sorted according to <p>lessThan</p>.</param>
        <param name="n">Maximum number of items to keep.</param>
        <param name="lessThan">Comparison function; should return <c>true</c> if its first argument is less than its second argument, <c>false</c> otherwise.</param>
        <ret>Returns an updated version of <p>top</p>.  If <p>x</p> is among the top <p>n</p> values seen, then it is included in the output.  Otherwise, the output is <p>top</p>.</ret>
        <detail>The <p>x</p> value is inserted after the first element of <p>top</p> that it is greater than or equal to (<p>lessThan</p> applied to that array element and <p>x</p> returns <c>true</c>) and the result is truncated to size <p>n</p>.  Thus, the result only represents a top-n list if <p>top</p> is already sorted and equal elements already in the array get precedence.</detail>
        <detail>The <p>top</p> array is unchanged by this function because all values in PFA are immutable.  The updated array is the return value.</detail>
      </doc>
    </fcn>

    <fcn name="stat.change.updateTrigger">
      <sig>
        <par name="predicate">boolean</par>
        <par name="history"><record label="A"><field name="numEvents">int</field><field name="numRuns">int</field><field name="currentRun">int</field><field name="longestRun">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a trigger that counts the number of times <p>predicate</p> is satisfied (<c>true</c>), as well as the number and lengths of runs of <c>true</c>.</desc>
        <param name="predicate">Expression that evaluates to <c>true</c> or <c>false</c>.</param>
        <param name="history">Summary of previous results of the <p>predicate</p>.
          <paramField name="numEvents">The number of times <p>predicate</p> evaluated to <c>true</c>.</paramField>
          <paramField name="numRuns">The number of contiguous intervals in which <p>predicate</p> was <c>true</c>, including the current one.</paramField>
          <paramField name="currentRun">If <p>predicate</p> is <c>false</c>, <pf>currentRun</pf> is 0.  Otherwise, <pf>currentRun</pf> is incremented (greater than or equal to 1 if <p>predicate</p> evaluated to <c>true</c>).</paramField>
          <paramField name="longestRun">The longest run observed so far; may be equal to <pf>currentRun</pf>.</paramField>
        </param>
        <ret>Returns a new record with updated fields: <pf>numEvents</pf> is always incremented; <pf>numRuns</pf> is incremented if <p>predicate</p> is <c>true</c> and <pf>currentRun</pf> is zero; <pf>currentRun</pf> is incremented if <p>predicate</p> is <c>true</c> and set to zero if <p>predicate</p> is <c>false</c>; <pf>longestRun</pf> is set to <pf>currentRun</pf> if <p>predicate</p> is <c>true</c> and <pf>currentRun</pf> is longer than <pf>longestRun</pf>.  If the input <p>history</p> has fields other than <pf>numEvents</pf>, <pf>numRuns</pf>, <pf>currentRun</pf>, or <pf>longestRun</pf>, they are copied unaltered to the output.</ret>
        <error code="37000">If any of <pf>numEvents</pf>, <pf>numRuns</pf>, <pf>currentRun</pf>, and <pf>longestRun</pf> are less than 0, a &quot;counter out of range&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="stat.change.zValue">
      <sig>
        <par name="x">double</par>
        <par name="meanVariance"><record label="A"><field name="mean">double</field><field name="variance">double</field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="meanVariance"><record label="A"><field name="count">double</field><field name="mean">double</field><field name="variance">double</field></record></par>
        <par name="unbiased">boolean</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Calculate the z-value between <p>x</p> and a normal distribution with a given mean and variance.</desc>
        <param name="x">Value to test.</param>
        <param name="meanVariance">A record with <pf>mean</pf>, <pf>variance</pf>, and possibly <pf>count</pf>, such as the output of <f>stat.sample.Update</f>.</param>
        <param name="unbiased">If <c>true</c>, use <pf>count</pf> to correct for the bias due to the fact that a variance centered on the mean has one fewer degrees of freedom than the dataset that it was sampled from (Bessel's correction).</param>
        <ret>If <p>unbiased</p> is <c>false</c>, <m>(x - mean)/\sqrt{variance}</m>; otherwise <m>(x - mean)(1/\sqrt{variance})\sqrt{count/(count - 1)}</m>.</ret>
      </doc>
    </fcn>

    <fcn name="stat.change.updateCUSUM">
      <sig>
        <par name="logLikelihoodRatio">double</par>
        <par name="last">double</par>
        <par name="reset">double</par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Update a cumulative sum (CUSUM) to detect the transition of a dataset from one distribution to another.</desc>
        <param name="logLikelihoodRatio">The logarithm of the ratio of the likelihood of a value for the alterate and baseline distributions: <m>\ln(\mbox{alt}_{L}/\mbox{base}_{L})</m>, which is <m>\mbox{alt}_{LL} - \mbox{base}_{LL}</m> where <m>L</m> is likelihood and <m>LL</m> is log-likelihood.  Consider using something like <c>{&quot;-&quot;: [{&quot;prob.dist.gaussianLL&quot;: [...]}, {&quot;prob.dist.gaussianLL&quot;: [...]}]}</c>.</param>
        <param name="last">The previous return value from this function.</param>
        <param name="reset">A low value (usually consistent with the baseline hypothesis, such as 0) at which the cumulative sum resets, rather than accumulate very low values and become insensitive to future changes.</param>
        <ret>An incremented cumulative sum.  The output is <m>\max\{logLikelihoodRatio + last, reset\}</m>.</ret>
      </doc>
    </fcn>

    <fcn name="model.reg.linear">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><record label="M"><field name="coeff"><array>double</array></field><field name="const">double</field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><record label="M"><field name="coeff"><array><array>double</array></array></field><field name="const"><array>double</array></field></record></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="model"><record label="M"><field name="coeff"><map>double</map></field><field name="const">double</field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="model"><record label="M"><field name="coeff"><map><map>double</map></map></field><field name="const"><map>double</map></field></record></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Apply matrix <p>model</p> to independent variables <p>datum</p> to predict the dependent, predicted variables.</desc>
        <param name="datum">Vector of independent variables with <m>d</m> dimensions.</param>
        <param name="model">Parameters of the linear model.
          <paramField name="coeff">Vector or matrix of coefficients that multiply the input variables, which has <m>p</m> rows and <m>d</m> columns.</paramField>
          <paramField name="const">Scalar or vector of constant offsets, which has <m>p</m> dimensions.</paramField>
        </param>
        <ret>Returns a <m>p</m> dimensional vector of dependent, predicted variables.</ret>
        <detail>The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in <p>x</p> must be equal to the number of rows and/or columns of <p>y</p>, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).</detail>
        <detail>The simpler signature is may be used in the <m>p = 1</m>case.</detail>
        <error code="31000">The array signature raises a &quot;misaligned coeff&quot; error if any row of <pf>coeff</pf> does not have the same indexes as <p>datum</p>.</error>
        <error code="31001">The array signature raises a &quot;misaligned const&quot; error if <pf>const</pf> does not have the same indexes as <p>coeff</p>.</error>
      </doc>
    </fcn>

    <fcn name="model.reg.linearVariance">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><record label="M"><field name="covar"><array><array>double</array></array></field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><record label="M"><field name="covar"><array><array><array>double</array></array></array></field></record></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="model"><record label="M"><field name="covar"><map><map>double</map></map></field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="model"><record label="M"><field name="covar"><map><map><map>double</map></map></map></field></record></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Propagate variances from <p>model</p> <pf>covar</pf> (covariance matrix) to the dependent, predicted variable(s).</desc>
        <param name="datum">Vector of independent variables <m>\vec{o}</m> with <m>d</m> dimensions.</param>
        <param name="model">Parameters of the linear model.
          <paramField name="covar">Covariance matrix <m>C</m> or array/map of covariance matrices, one for each dependent, predicted variable.  Each matrix has <m>d + 1</m> rows and <m>d + 1</m> columns: the last (array) or empty string (map) row and column corresponds to the model's constant term.  If there are <m>p</m> dependent, predicted variables, the outermost array/map has <m>p</m> items.</paramField>
        </param>
        <ret>Propagated variance(s) <m>\vec{o}^T C \vec{o}</m> for each dependent, predicted variable.</ret>
        <detail>The &quot;error&quot; or &quot;uncertainty&quot; in the predicted variable(s) is the square root of this value/these values.</detail>
        <detail>The vectors and matrix may be expressed as arrays (indexed by integers) or maps (indexed by strings). In the array signature, the number of rows and/or columns in <p>x</p> must be equal to the number of rows and/or columns of <p>y</p>, respectively (dense matrix). In the map signature, missing row-column combinations are assumed to be zero (sparse matrix).</detail>
        <error code="31010">The array signature raises a &quot;misaligned covariance&quot; error if any covariance matrix does not have the same indexes as <p>datum</p> plus the implicit index for a constant (last in array signature).</error>
      </doc>
    </fcn>

    <fcn name="model.reg.gaussianProcess">
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to">double</field></record></array></par>
        <par name="krigingWeight"><union>null</union><union>double</union></par>
        <par name="kernel">
          <function>
            <par><array>double</array></par>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x">double</par>
        <par name="table"><array><record label="R"><field name="x">double</field><field name="to"><array>double</array></field></record></array></par>
        <par name="krigingWeight"><union>null</union><union>double</union></par>
        <par name="kernel">
          <function>
            <par><array>double</array></par>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <par name="table"><array><record label="R"><field name="x"><array>double</array></field><field name="to">double</field></record></array></par>
        <par name="krigingWeight"><union>null</union><union>double</union></par>
        <par name="kernel">
          <function>
            <par><array>double</array></par>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="x"><array>double</array></par>
        <par name="table"><array><record label="R"><field name="x"><array>double</array></field><field name="to"><array>double</array></field></record></array></par>
        <par name="krigingWeight"><union>null</union><union>double</union></par>
        <par name="kernel">
          <function>
            <par><array>double</array></par>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Fit the training data in <p>table</p> with a Gaussian Process model and predict the value of model at <p>x</p>.</desc>
        <param name="x">Position (scalar or vector) at which to predict the value of the model.</param>
        <param name="table">Training data for the Gaussian Process.
          <paramField name="x">Independent variable (scalar or vector, but same as <p>x</p>) of a training datum.</paramField>
          <paramField name="to">Dependent variable (scalar or vector) of a training datum.</paramField>
          <paramField name="sigma">Optional uncertainty for the datum. If present, it must have the same type as <pf>to</pf> and is used in the Gaussian Process fit as a nugget.</paramField>
        </param>
        <param name="krigingWeight">If a number, the Gaussian Process is performed with the specified Kriging weight. If <c>null</c>, universal Kriging is performed.</param>
        <param name="kernel">A function to use as a kernel. For instance, <f>m.kernel.rbf</f> (radial basis function) with partially applied <c>gamma</c> is a squared exponential kernel.</param>
        <ret>Returns a scalar or vector prediction with the same type as <pf>to</pf>.</ret>
        <nondeterministic type="unstable"/>
        <error code="31080">If <p>table</p> is empty, a &quot;table must have at least 1 entry&quot; error is raised.</error>
        <error code="31081">If <p>x</p> is an empty array, an &quot;x must have at least 1 feature&quot; error is raised.</error>
        <error code="31082">If any <pf>x</pf> in the <p>table</p> has a different length than the input parameter <p>x</p>, a &quot;table must have the same number of features as x&quot; error is raised.</error>
        <error code="31083">If any <pf>to</pf> in the <p>table</p> is an empty array, a &quot;table outputs must have at least 1 dimension&quot; error is raised.</error>
        <error code="31084">If the <pf>to</pf> fields in <p>table</p> do not all have the same dimensions, a &quot;table outputs must all have the same number of dimensions&quot; error is raised.</error>
        <error code="31085">If <p>x</p> or a component of <p>x</p> is not finite, an &quot;x is not finite&quot; error is raised.</error>
        <error code="31086">If any value in the <p>table</p> is not finite, a &quot;table value is not finite&quot; error is raised.</error>
        <error code="31087">If <p>krigingWeight</p> is a number but is not finite, a &quot;krigingWeight is not finite&quot; error is raised.</error>
        <error code="31088">If evaluating <p>kernel</p> on all combinations of <p>table</p> <pf>x</pf> (with <m>1 + (\mbox{sigma}/\mbox{to})^2</m> on the diagonal) yields a non-positive definite matrix, a &quot;matrix of kernel results is not positive definite&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="model.reg.residual">
      <sig contingency="use stat.test.residual instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation">double</par>
        <par name="prediciton">double</par>
        <ret>double</ret>
      </sig>
      <sig contingency="use stat.test.residual instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><array>double</array></par>
        <par name="prediciton"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig contingency="use stat.test.residual instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><map>double</map></par>
        <par name="prediciton"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by element-wise subtraction.</desc>
        <param name="observation">Scalar or vector of observations.</param>
        <param name="prediction">Scalar or vector of predictions.</param>
        <ret>Scalar or vector of <p>observation</p> minus <p>prediction</p>.</ret>
        <error code="31020">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes as <p>observation</p>.</error>
      </doc>
    </fcn>

    <fcn name="model.reg.pull">
      <sig contingency="use stat.test.pull instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation">double</par>
        <par name="prediciton">double</par>
        <par name="uncertainty">double</par>
        <ret>double</ret>
      </sig>
      <sig contingency="use stat.test.pull instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><array>double</array></par>
        <par name="prediciton"><array>double</array></par>
        <par name="uncertainty"><array>double</array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig contingency="use stat.test.pull instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><map>double</map></par>
        <par name="prediciton"><map>double</map></par>
        <par name="uncertainty"><map>double</map></par>
        <ret><map>double</map></ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by element-wise subtraction, weighted by element-wise uncertainties.</desc>
        <param name="observation">Scalar or vector of observations.</param>
        <param name="prediction">Scalar or vector of predictions.</param>
        <param name="uncertainty">Scalar or vector of predictions.</param>
        <ret>Scalar or vector of <p>observation</p> minus <p>prediction</p> divided by <p>uncertainty</p>.</ret>
        <error code="31030">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes as <p>observation</p>.</error>
        <error code="31031">Raises a &quot;misaligned uncertainty&quot; error if <p>prediction</p> does not have the same indexes as <p>uncertainty</p>.</error>
      </doc>
    </fcn>

    <fcn name="model.reg.mahalanobis">
      <sig contingency="use stat.test.mahalanobis instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><array>double</array></par>
        <par name="prediction"><array>double</array></par>
        <par name="covariance"><array><array>double</array></array></par>
        <ret>double</ret>
      </sig>
      <sig contingency="use stat.test.mahalanobis instead" death="0.9.0" deprecation="0.7.2">
        <par name="observation"><map>double</map></par>
        <par name="prediction"><map>double</map></par>
        <par name="covariance"><map><map>double</map></map></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Compare an observation with its prediction by computing the Mahalanobis distance for a given covariance matrix.</desc>
        <param name="observation">Vector of observations <m>\vec{o}</m>.</param>
        <param name="prediction">Vector of predictions <m>\vec{p}</m>.</param>
        <param name="covariance">Matrix of covariance <m>C</m>.</param>
        <ret>Scalar result of a similarity transformation: <m>\sqrt{(\vec{o} - \vec{p})^T C^{-1} (\vec{o} - \vec{p})}</m>.</ret>
        <error code="31040">Raises a &quot;too few rows/cols&quot; error if <p>observation</p> has fewer than one element.</error>
        <error code="31041">Raises a &quot;misaligned prediction&quot; error if <p>prediction</p> does not have the same indexes as <p>observation</p>.</error>
        <error code="31042">Raises a &quot;misaligned covariance&quot; error if <p>covariance</p> does not have the same indexes as <p>observation</p>.</error>
      </doc>
    </fcn>

    <fcn name="model.reg.updateChi2">
      <sig contingency="use stat.test.updateChi2 instead" death="0.9.0" deprecation="0.7.2">
        <par name="pull">double</par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="DOF">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig contingency="use stat.test.updateChi2 instead" death="0.9.0" deprecation="0.7.2">
        <par name="pull"><array>double</array></par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="DOF">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <sig contingency="use stat.test.updateChi2 instead" death="0.9.0" deprecation="0.7.2">
        <par name="pull"><map>double</map></par>
        <par name="state"><record label="A"><field name="chi2">double</field><field name="DOF">int</field></record></par>
        <ret><ref label="A"/></ret>
      </sig>
      <doc>
        <desc>Update the state of a chi-square calculation.</desc>
        <param name="pull">Observation minus prediction divided by uncertainty.  If this is a scalar, it will be squared and added to the chi-square.  If a vector, each component will be squared and added to the chi-square.</param>
        <param name="state">Record of the previous <pf>chi2</pf> and <pf>DOF</pf>.</param>
      </doc>
    </fcn>

    <fcn name="model.reg.reducedChi2">
      <sig contingency="use stat.test.reducedChi2 instead" death="0.9.0" deprecation="0.7.2">
        <par name="state"><record label="A"><field name="chi2">double</field><field name="DOF">int</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the reduced chi-square, which is <pf>chi2</pf>/<pf>DOF</pf>.</desc>
        <param name="state">Record of the <pf>chi2</pf> and <pf>DOF</pf>.</param>
      </doc>
    </fcn>

    <fcn name="model.reg.chi2Prob">
      <sig contingency="use stat.test.chi2Prob instead" death="0.9.0" deprecation="0.7.2">
        <par name="state"><record label="A"><field name="chi2">double</field><field name="DOF">int</field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Return the chi-square probability, which is the CDF of the chi-square function.</desc>
        <param name="state">Record of the <pf>chi2</pf> and <pf>DOF</pf>.</param>
        <error code="31070">Raises &quot;invalid parameterization&quot; if <pf>DOF</pf> is less than zero.</error>
      </doc>
    </fcn>

    <fcn name="model.tree.simpleTest">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="comparison"><record label="T"><field name="field"><enum label="F" ofRecord="D"/></field><field name="operator">string</field><field name="value"><any label="V"/></field></record></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Determine if <p>datum</p> passes a test defined by <p>comparison</p>.</desc>
        <param name="datum">Sample value to test.</param>
        <param name="comparison">Record that describes a test.
          <paramField name="field">Field name from <p>datum</p>: the enumeration type must include all fields of <tp>D</tp> in their declaration order.</paramField>
          <paramField name="operator">One of the following: &quot;==&quot; (equal), &quot;!=&quot; (not equal), &quot;&lt;&quot; (less than), &quot;&lt;=&quot; (less or equal), &quot;&gt;&quot; (greater than), &quot;&gt;=&quot; (greater or equal), &quot;in&quot; (member of a set), &quot;notIn&quot; (not a member of a set), &quot;alwaysTrue&quot; (ignore <pf>value</pf>, return <c>true</c>), &quot;alwaysFalse&quot; (ignore <pf>value</pf>, return <c>false</c>), &quot;isMissing&quot; (ignore <pf>value</pf>, return <c>true</c> iff the field of <p>datum</p> is <c>null</c>), and &quot;notMissing&quot; (ignore <pf>value</pf>, return <c>false</c> iff the field of <p>datum</p> is <c>null</c>).</paramField>
          <paramField name="value">Value to which the field of <p>datum</p> is compared.</paramField>
        </param>
        <ret>Returns <c>true</c> if the field of <p>datum</p> &lt;op&gt; <pf>value</pf> is <c>true</c>, <c>false</c> otherwise, where &lt;op&gt; is the <pf>operator</pf>.</ret>
        <error code="32000">Raises an &quot;invalid comparison operator&quot; if <pf>operator</pf> is not one of &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;in&quot;, &quot;notIn&quot;, &quot;alwaysTrue&quot;, &quot;alwaysFalse&quot;, &quot;isMissing&quot;, &quot;notMissing&quot;.</error>
        <error code="32001">Raises a &quot;bad value type&quot; if the <pf>field</pf> of <p>datum</p> and <tp>V</tp> are not both numbers and the <pf>field</pf> cannot be upcast to <tp>V</tp>.</error>
      </doc>
    </fcn>

    <fcn name="model.tree.missingTest">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="comparison"><record label="T"><field name="field"><enum label="F" ofRecord="D"/></field><field name="operator">string</field><field name="value"><any label="V"/></field></record></par>
        <ret><union>null</union><union>boolean</union></ret>
      </sig>
      <doc>
        <desc>Determine if <p>datum</p> passes a test defined by <p>comparison</p>, allowing for missing values.</desc>
        <param name="datum">Sample value to test.</param>
        <param name="comparison">Record that describes a test.
          <paramField name="field">Field name from <p>datum</p>: the enumeration type must include all fields of <tp>D</tp> in their declaration order.</paramField>
          <paramField name="operator">One of the following: &quot;==&quot; (equal), &quot;!=&quot; (not equal), &quot;&lt;&quot; (less than), &quot;&lt;=&quot; (less or equal), &quot;&gt;&quot; (greater than), &quot;&gt;=&quot; (greater or equal), &quot;in&quot; (member of a set), &quot;notIn&quot; (not a member of a set), &quot;alwaysTrue&quot; (ignore <pf>value</pf>, return <c>true</c>), &quot;alwaysFalse&quot; (ignore <pf>value</pf>, return <c>false</c>).</paramField>
          <paramField name="value">Value to which the field of <p>datum</p> is compared.</paramField>
        </param>
        <ret>If the field of <p>datum</p> is <c>null</c>, this function returns <c>null</c> (unknown test result).  Otherwise, it returns <p>datum</p> field &lt;op&gt; <pf>value</pf>, where &lt;op&gt; is the <pf>operator</pf></ret>
        <error code="32010">Raises an &quot;invalid comparison operator&quot; if <pf>operator</pf> is not one of &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;in&quot;, &quot;notIn&quot;, &quot;alwaysTrue&quot;, &quot;alwaysFalse&quot;.</error>
        <error code="32011">Raises a &quot;bad value type&quot; if the <pf>field</pf> of <p>datum</p> and <tp>V</tp> are not both numbers and the <pf>field</pf> cannot be upcast to <tp>V</tp>.</error>
      </doc>
    </fcn>

    <fcn name="model.tree.compoundTest">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="operator">string</par>
        <par name="comparisons"><array><record label="T"/></array></par>
        <par name="test">
          <function>
            <par><ref label="D"/></par>
            <par><ref label="T"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Apply <p>test</p> to an array of <p>comparisons</p>, returning their logical and, or, or xor, depending on <p>operator</p>.</desc>
        <param name="datum">Simple value to test.</param>
        <param name="operator">If &quot;and&quot;, return <c>true</c> if no <c>false</c> is encountered, if &quot;or&quot;, return <c>true</c> if any <c>true</c> is encountered, and if &quot;xor&quot;, return <c>true</c> if an odd number of <c>true</c> is encountered among the <p>comparisons</p>.</param>
        <param name="comparisons">Array of records that describe the tests.</param>
        <param name="test">Test function applied to each item of <p>comparisons</p> until the result is certain.</param>
        <ret>Logical combination of <p>comparisons</p>.</ret>
        <detail>If <p>operator</p> is &quot;and&quot;, the <p>test</p> will only be applied until the first <c>false</c> is encountered. If <p>operator</p> is &quot;or&quot;, the <p>test</p> will only be applied until the first <c>true</c> is encountered. If <p>operator</p> is &quot;xor&quot;, the <p>test</p> will be applied to all items of <p>comparisons</p>.</detail>
        <error code="32020">If <p>operator</p> is not &quot;and&quot;, &quot;or&quot;, or &quot;xor&quot;, an &quot;unrecognized logical operator&quot; error is raised.</error>
      </doc>
    </fcn>

    <fcn name="model.tree.surrogateTest">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="comparisons"><array><record label="T"/></array></par>
        <par name="missingTest">
          <function>
            <par><ref label="D"/></par>
            <par><ref label="T"/></par>
            <ret><union>null</union><union>boolean</union></ret>
          </function></par>
        <ret>boolean</ret>
      </sig>
      <doc>
        <desc>Apply <p>missingTest</p> to an array of <p>comparisons</p> until one yields a non-null result.</desc>
        <param name="datum">Sample value to test.</param>
        <param name="comparisons">Array of records that describe the tests.</param>
        <param name="missingTest">Test function applied to each item of <p>comparisons</p> until one returns a non-null result.</param>
        <ret>Returns the value of the first test that returns <c>true</c> or <c>false</c>.</ret>
        <error code="32030">If all tests return <c>null</c>, this function raises a &quot;no successful surrogate&quot; error.</error>
      </doc>
    </fcn>

    <fcn name="model.tree.simpleWalk">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="treeNode"><record label="T"><field name="pass"><union><ref label="T"/></union><union><any label="S"/></union></field><field name="fail"><union><ref label="T"/></union><union><ref label="S"/></union></field></record></par>
        <par name="test">
          <function>
            <par><ref label="D"/></par>
            <par><ref label="T"/></par>
            <ret>boolean</ret>
          </function></par>
        <ret><ref label="S"/></ret>
      </sig>
      <doc>
        <desc>Descend through a tree, testing the fields of <p>datum</p> with the <p>test</p> function using <p>treeNode</p> to define the comparison, continuing to <pf>pass</pf> or <pf>fail</pf> until reaching a leaf node of type <tp>S</tp> (score).</desc>
        <param name="datum">Sample value to test.</param>
        <param name="treeNode">Node of the tree, which contains a predicate to be interpreted by <p>test</p>.
          <paramField name="pass">Branch to follow if <p>test</p> returns <c>true</c>.</paramField>
          <paramField name="fail">Branch to follow if <p>test</p> returns <c>false</c>.</paramField>
        </param>
        <param name="test">Test function that converts <p>datum</p> and <p>treeNode</p> into <c>true</c> or <c>false</c>.</param>
        <ret>Leaf node of type <tp>S</tp>, which must be different from the tree nodes.  For a classification tree, <tp>S</tp> could be a string or an enumeration set.  For a regression tree, <tp>S</tp> would be a numerical type.  For a multivariate regression tree, <tp>S</tp> would be an array of numbers, etc.</ret>
      </doc>
    </fcn>

    <fcn name="model.tree.missingWalk">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="treeNode"><record label="T"><field name="pass"><union><ref label="T"/></union><union><any label="S"/></union></field><field name="fail"><union><ref label="T"/></union><union><ref label="S"/></union></field><field name="missing"><union><ref label="T"/></union><union><ref label="S"/></union></field></record></par>
        <par name="test">
          <function>
            <par><ref label="D"/></par>
            <par><ref label="T"/></par>
            <ret><union>null</union><union>boolean</union></ret>
          </function></par>
        <ret><ref label="S"/></ret>
      </sig>
      <doc>
        <desc>Descend through a tree, testing the fields of <p>datum</p> with the <p>test</p> function using <p>treeNode</p> to define the comparison, continuing to <pf>pass</pf>, <pf>fail</pf>, or <pf>missing</pf> until reaching a leaf node of type <tp>S</tp> (score).</desc>
        <param name="datum">Sample value to test.</param>
        <param name="treeNode">Node of the tree, which contains a predicate to be interpreted by <p>test</p>.
          <paramField name="pass">Branch to follow if <p>test</p> returns <c>true</c>.</paramField>
          <paramField name="fail">Branch to follow if <p>test</p> returns <c>false</c>.</paramField>
          <paramField name="missing">Branch to follow if <p>test</p> returns <c>null</c>.</paramField>
        </param>
        <param name="test">Test function that converts <p>datum</p> and <p>treeNode</p> into <c>true</c>, <c>false</c>, or <c>null</c>.</param>
        <ret>Leaf node of type <tp>S</tp>, which must be different from the tree nodes.  For a classification tree, <tp>S</tp> could be a string or an enumeration set.  For a regression tree, <tp>S</tp> would be a numerical type.  For a multivariate regression tree, <tp>S</tp> would be an array of numbers, etc.</ret>
      </doc>
    </fcn>

    <fcn name="model.tree.simpleTree">
      <sig>
        <par name="datum"><record label="D"/></par>
        <par name="treeNode"><record label="T"><field name="field"><enum label="F" ofRecord="D"/></field><field name="operator">string</field><field name="value"><any label="V"/></field><field name="pass"><union><ref label="T"/></union><union><any label="S"/></union></field><field name="fail"><union><ref label="T"/></union><union><ref label="S"/></union></field></record></par>
        <ret><ref label="S"/></ret>
      </sig>
      <doc>
        <desc>Descend through a tree, testing <p>datum</p> with <pf>field</pf>, <pf>operator</pf>, <pf>value</pf>, following <pf>pass</pf> or <pf>fail</pf> until reaching a leaf node of type <tp>S</tp> (score).</desc>
        <param name="datum">Sample value to test.</param>
        <param name="treeNode">Record that describes a tree node (predicate test with branches).
          <paramField name="field">Field name from <p>datum</p>: the enumeration type must include all fields of <tp>D</tp> in their declaration order.</paramField>
          <paramField name="operator">One of the following: &quot;==&quot; (equal), &quot;!=&quot; (not equal), &quot;&lt;&quot; (less than), &quot;&lt;=&quot; (less or equal), &quot;&gt;&quot; (greater than), &quot;&gt;=&quot; (greater or equal), &quot;in&quot; (member of a set), &quot;notIn&quot; (not a member of a set), &quot;alwaysTrue&quot; (ignore <pf>value</pf>, return <c>true</c>), &quot;alwaysFalse&quot; (ignore <pf>value</pf>, return <c>false</c>), &quot;isMissing&quot; (ignore <pf>value</pf>, return <c>true</c> iff the field of <p>datum</p> is <c>null</c>), and &quot;notMissing&quot; (ignore <pf>value</pf>, return <c>false</c> iff the field of <p>datum</p> is <c>null</c>).</paramField>
          <paramField name="value">Value to which the field of <p>datum</p> is compared.</paramField>
          <paramField name="pass">Branch to follow if the comparison is successful.</paramField>
          <paramField name="fail">Branch to follow if the comparison fails.</paramField>
        </param>
        <ret>Leaf node of type <tp>S</tp>, which must be different from the tree nodes.  For a classification tree, <tp>S</tp> could be a string or an enumeration set.  For a regression tree, <tp>S</tp> would be a numerical type.  For a multivariate regression tree, <tp>S</tp> would be an array of numbers, etc.</ret>
        <detail>This is a convenience function, a combination of <f>model.tree.simpleWalk</f> with <f>model.tree.simpleTest</f>.</detail>
        <error code="32060">Raises an &quot;invalid comparison operator&quot; if <pf>operator</pf> is not one of &quot;==&quot;, &quot;!=&quot;, &quot;&lt;&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&gt;=&quot;, &quot;in&quot;, &quot;notIn&quot;, &quot;alwaysTrue&quot;, &quot;alwaysFalse&quot;, &quot;isMissing&quot;, &quot;notMissing&quot;.</error>
        <error code="32061">Raises a &quot;bad value type&quot; if the <pf>field</pf> of <p>datum</p> and <tp>V</tp> are not both numbers and the <pf>field</pf> cannot be upcast to <tp>V</tp>.</error>
      </doc>
    </fcn>

    <fcn name="model.cluster.closest">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="clusters"><array><record label="C"><field name="center"><array>double</array></field></record></array></par>
        <ret><ref label="C"/></ret>
      </sig>
      <sig>
        <par name="datum"><any label="A"/></par>
        <par name="clusters"><array><record label="C"><field name="center"><any label="B"/></field></record></array></par>
        <par name="metric">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>double</ret>
          </function></par>
        <ret><ref label="C"/></ret>
      </sig>
      <doc>
        <desc>Find the cluster <tp>C</tp> whose <pf>center</pf> is closest to the <p>datum</p>, according to the <p>metric</p>.</desc>
        <param name="datum">Sample datum.</param>
        <param name="clusters">Set of clusters; the record type <tp>C</tp> may contain additional identifying information for post-processing.</param>
        <param name="metric">Function used to compare each <p>datum</p> with the <pf>center</pf> of the <p>clusters</p>.  (See, for example, <f>metric.euclidean</f>.)</param>
        <ret>Returns the closest cluster record.</ret>
        <error code="29000">Raises a &quot;no clusters&quot; error if <p>clusters</p> is empty.</error>
        <detail>If <p>metric</p> is not provided, a Euclidean metric over floating point numbers is assumed.</detail>
      </doc>
    </fcn>

    <fcn name="model.cluster.closestN">
      <sig>
        <par name="n">int</par>
        <par name="datum"><array>double</array></par>
        <par name="clusters"><array><record label="C"><field name="center"><array>double</array></field></record></array></par>
        <ret><array><ref label="C"/></array></ret>
      </sig>
      <sig>
        <par name="n">int</par>
        <par name="datum"><any label="A"/></par>
        <par name="clusters"><array><record label="C"><field name="center"><any label="B"/></field></record></array></par>
        <par name="metric">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>double</ret>
          </function></par>
        <ret><array><ref label="C"/></array></ret>
      </sig>
      <doc>
        <desc>Find the <p>n</p> clusters <tp>C</tp> whose <pf>centers</pf> are closest to the <p>datum</p>, according to the <p>metric</p>.</desc>
        <param name="n">Number of clusters to search for.</param>
        <param name="datum">Sample datum.</param>
        <param name="clusters">Set of clusters; the record type <tp>C</tp> may contain additional identifying information for post-processing.</param>
        <param name="metric">Function used to compare each <p>datum</p> with the <pf>center</pf> of the <p>clusters</p>.  (See, for example, <f>metric.euclidean</f>.)</param>
        <ret>An array of the closest cluster records in order from the closest to the farthest.  The length of the array is minimum of <p>n</p> and the length of <p>clusters</p>.</ret>
        <detail>If <p>metric</p> is not provided, a Euclidean metric over floating point numbers is assumed.</detail>
        <error code="29010">If <p>n</p> is negative, an &quot;n must be nonnegative&quot; error will be raised.</error>
      </doc>
    </fcn>

    <fcn name="model.cluster.randomSeeds">
      <sig>
        <par name="data"><array><array><any label="A"/></array></array></par>
        <par name="k">int</par>
        <par name="newCluster">
          <function>
            <par>int</par>
            <par><array><ref label="A"/></array></par>
            <ret><record label="C"><field name="center"><array><any label="B"/></array></field></record></ret>
          </function></par>
        <ret><array><ref label="C"/></array></ret>
      </sig>
      <doc>
        <desc>Call <p>newCluster</p> to create <p>k</p> cluster records with random, unique cluster centers drawn from <p>data</p>.</desc>
        <param name="data">Sample data.</param>
        <param name="k">Number of times to call <p>newCluster</p>.</param>
        <param name="newCluster">Function that creates a cluster record, given an index (ranges from zero up to but not including <p>k</p>) and a random vector from <p>data</p>.</param>
        <ret>The cluster records created by <p>newCluster</p>.</ret>
        <error code="29020">Raises a &quot;k must be greater than zero&quot; error if <p>k</p> is less than or equal to zero.</error>
        <error code="29021">Raises a &quot;not enough unique points&quot; error if <p>data</p> has fewer than <p>k</p> unique elements.</error>
        <error code="29022">Raises a &quot;dimensions of vectors do not match&quot; error if the elements of <p>data</p> are not all the same size.</error>
        <nondeterministic type="pseudorandom"/>
      </doc>
    </fcn>

    <fcn name="model.cluster.kmeansIteration">
      <sig>
        <par name="data"><array><array><any label="A"/></array></array></par>
        <par name="clusters"><array><record label="C"><field name="center"><array><any label="B"/></array></field></record></array></par>
        <par name="metric">
          <function>
            <par><array><ref label="A"/></array></par>
            <par><array><ref label="B"/></array></par>
            <ret>double</ret>
          </function></par>
        <par name="update">
          <function>
            <par><array><array><ref label="A"/></array></array></par>
            <par><ref label="C"/></par>
            <ret><ref label="C"/></ret>
          </function></par>
        <ret><array><ref label="C"/></array></ret>
      </sig>
      <doc>
        <desc>Update a cluster set by applying one iteration of k-means (Lloyd's algorithm).</desc>
        <param name="data">Sample data.</param>
        <param name="clusters">Set of clusters; the record type <tp>C</tp> may contain additional identifying information for post-processing.</param>
        <param name="metric">Function used to compare each <p>datum</p> with the <pf>center</pf> of the <p>clusters</p>.  (See, for example, <f>metric.euclidean</f>.)</param>
        <param name="update">Function of matched data and old cluster records that yields new cluster records.  (See, for example, <f>model.cluster.updateMean</f> with <p>weight</p> = 0.)</param>
        <detail>The <p>update</p> function is only called if the number of matched data points is greater than zero.</detail>
        <ret>Returns a new cluster set with each of the <tp>centers</tp> located at the average of all points that match the corresponding cluster in the old cluster set.</ret>
        <error code="29030">Raises a &quot;no data&quot; error if <p>data</p> is empty.</error>
        <error code="29031">Raises a &quot;no clusters&quot; error if <p>clusters</p> is empty.</error>
      </doc>
    </fcn>

    <fcn name="model.cluster.updateMean">
      <sig>
        <par name="data"><array><array>double</array></array></par>
        <par name="cluster"><record label="C"><field name="center"><array>double</array></field></record></par>
        <par name="weight">double</par>
        <ret><ref label="C"/></ret>
      </sig>
      <doc>
        <desc>Update a cluster record by computing the mean of the <p>data</p> vectors and <p>weight</p> times the old <p>cluster</p> center.</desc>
        <detail>If <p>weight</p> is zero, the new center is equal to the mean of <p>data</p>, ignoring the old <p>center</p>.</detail>
        <error code="29040">Raises a &quot;no data&quot; error if <p>data</p> is empty.</error>
        <error code="29041">Raises a &quot;dimensions of vectors do not match&quot; error if all elements of <p>data</p> and the <p>cluster</p> center do not match.</error>
      </doc>
    </fcn>

    <fcn name="model.neighbor.mean">
      <sig>
        <par name="points"><array><array>double</array></array></par>
        <ret><array>double</array></ret>
      </sig>
      <sig>
        <par name="points"><array><array>double</array></array></par>
        <par name="weight">
          <function>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Return the vector-wise mean of <p>points</p>, possibly weighted by <p>weight</p>.</desc>
        <param name="points">Points from a codebook, for instance from <f>model.neighbor.nearestK</f>.</param>
        <param name="weight">Optional weighting function from each element of <p>points</p> to a value.  If these values do not add up to 1.0, they will be internally normalized.</param>
        <ret>The vector-wise mean, which is by construction within the convex hull of the <p>points</p>.</ret>
        <error code="30000">If <p>points</p> is empty, a &quot;not enough points&quot; error will be raised.</error>
        <error code="30001">If the <p>points</p> have different sizes, an &quot;inconsistent dimensionality&quot; error will be raised.</error>
      </doc>
    </fcn>

    <fcn name="model.neighbor.nearestK">
      <sig>
        <par name="k">int</par>
        <par name="datum"><array>double</array></par>
        <par name="codebook"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="k">int</par>
        <par name="datum"><any label="A"/></par>
        <par name="codebook"><array><any label="B"/></array></par>
        <par name="metric">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>double</ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Find the <p>k</p> items in the <p>codebook</p> that are closest to the <p>datum</p>, according to the <p>metric</p>.</desc>
        <param name="k">Number of <p>codebook</p> points to attempt to return.</param>
        <param name="datum">Sample datum.</param>
        <param name="codebook">Set of training data that is compared to the <p>datum</p>.</param>
        <param name="metric">Function used to compare each <p>datum</p> to each element of the <p>codebook</p>.  (See, for example, <f>metric.euclidean</f>.)</param>
        <ret>An array of the closest <p>codebook</p> elements in any order.  The length of the array is minimum of <p>k</p> and the length of <p>codebook</p>.</ret>
        <error code="30010">If <p>k</p> is negative, an &quot;k must be nonnegative&quot; error will be raised.</error>
        <error code="30011">If arrays in the <p>codebook</p> or the <p>codebook</p> and the <p>datum</p> have different sizes (without a <p>metric</p>), an &quot;inconsistent dimensionality&quot; error will be raised.</error>
      </doc>
    </fcn>

    <fcn name="model.neighbor.ballR">
      <sig>
        <par name="r">double</par>
        <par name="datum"><array>double</array></par>
        <par name="codebook"><array><array>double</array></array></par>
        <ret><array><array>double</array></array></ret>
      </sig>
      <sig>
        <par name="r">double</par>
        <par name="datum"><any label="A"/></par>
        <par name="codebook"><array><any label="B"/></array></par>
        <par name="metric">
          <function>
            <par><ref label="A"/></par>
            <par><ref label="B"/></par>
            <ret>double</ret>
          </function></par>
        <ret><array><ref label="B"/></array></ret>
      </sig>
      <doc>
        <desc>Find the items in <p>codebook</p> that are within <p>r</p> of the <p>datum</p>, according to the <p>metric</p>.</desc>
        <param name="r">Maximum distance (exclusive) of points to return.</param>
        <param name="datum">Sample datum.</param>
        <param name="codebook">Set of training data that is compared to the <p>datum</p>.</param>
        <param name="metric">Function used to compare each <p>datum</p> to each element of the <p>codebook</p>.  (See, for example, <f>metric.euclidean</f>.)</param>
        <ret>An array of the <p>codebook</p> elements within a distance <p>r</p> in any order.  The length of the array could be as low as zero or as high as the length of <p>codebook</p>.</ret>
      </doc>
    </fcn>

    <fcn name="model.naive.gaussian">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="classModel"><array><record label="A"><field name="mean">double</field><field name="variance">double</field></record></array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="classModel"><map><record label="A"><field name="mean">double</field><field name="variance">double</field></record></map></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Score <p>datum</p> using a Gaussian Naive Bayes model.</desc>
        <param name="datum"> Vector of independent variables with <m>d</m> dimensions. </param>
        <param name="classModel"> Array or map of <m>d</m> records, each containing the <p>mean</p> and <p>variance</p> of each of independent variable, for one class. </param>
        <ret>Returns the unscaled log-likelihood that <p>datum</p> is a member of the class specified by <p>classModel</p>.</ret>
        <detail><p>datum</p> or <p>classModel</p> may be expressed as arrays (indexed by integers), or maps (indexed by strings).</detail>
        <error code="10000">Raises a &quot;datum and classModel misaligned&quot; error if <p>datum</p> and <p>classModel</p> have different lengths, of if their keys if using the map signature don't match one to one.</error>
        <error code="10001">Raises a &quot;variance less than or equal to zero&quot; error if a variance inside of <p>classModel</p> is incorrectly specified.</error>
      </doc>
    </fcn>

    <fcn name="model.naive.multinomial">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="classModel"><array>double</array></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="classModel"><map>double</map></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="classModel"><record label="C"><field name="values"><array>double</array></field></record></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><map>double</map></par>
        <par name="classModel"><record label="C"><field name="values"><map>double</map></field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Score <p>datum</p> using a Multinomial Naive Bayes model.</desc>
        <param name="datum">Vector of independent variables with <m>d</m> dimensions. </param>
        <param name="classModel">Array or map of multinomial (<m>d</m> different) likelihoods of each independent variable for this class. The record form is for histograms built by <f>stat.sample.fillHistogram</f> or <f>stat.sample.fillCounter</f>.</param>
        <ret>Returns the unscaled log-likelihood of <p>datum</p> for this class.</ret>
        <detail><p>datum</p> or <p>classModel</p> may be expressed as arrays (indexed by integers), or maps (indexed by strings).</detail>
        <error code="10010">Raises a &quot;datum and classModel misaligned&quot; error if when using the map signature the keys of <p>datum</p> and <p>classModel</p> don't match one to one, of if when using the array signature they are different lengths.</error>
        <error code="10011">Raises a &quot;classModel must be non-empty and strictly positive&quot; error if classModel is empty or any items are less than or equal to zero.</error>
      </doc>
    </fcn>

    <fcn name="model.naive.bernoulli">
      <sig>
        <par name="datum"><array>string</array></par>
        <par name="classModel"><map>double</map></par>
        <ret>double</ret>
      </sig>
      <sig>
        <par name="datum"><array>string</array></par>
        <par name="classModel"><record label="C"><field name="values"><map>double</map></field></record></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Score <p>datum</p> using a Bernoulli Naive Bayes model.</desc>
        <param name="datum">Vector of independent variables with <m>d</m> dimensions. The record form is for histograms built by <f>stat.sample.fillCounter</f>.</param>
        <param name="classModel">Array or map of <m>d</m> likelihoods of the presence of each independent variable for this class. </param>
        <ret>Returns the unscaled log-likelihood of <p>datum</p> for this class.</ret>
        <error code="10020">Raises a &quot;probability in classModel must be strictly between 0 and 1&quot; error if a value in <p>classModel</p> is not strictly between zero and one.</error>
      </doc>
    </fcn>

    <fcn name="model.neural.simpleLayers">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><array><record label="M"><field name="weights"><array><array>double</array></array></field><field name="bias"><array>double</array></field></record></array></par>
        <par name="activation">
          <function>
            <par>double</par>
            <ret>double</ret>
          </function></par>
        <ret><array>double</array></ret>
      </sig>
      <doc>
        <desc>Apply a feedforward artificial neural network <p>model</p> to an input <p>datum</p>.</desc>
        <param name="datum">Length <p>d</p> vector of independent variables.</param>
        <param name="model">Array containing the parameters of each layer of the feedforward neural network model.</param>
          <paramField name="weights">Matrix of weights.  Each of <p>i</p> rows is a node (or neuron), and in each of <p>j</p> columns are the weights for that node.  In the zeroth layer, <p>i</p> must equal <p>d</p>.</paramField>
          <paramField name="bias">Length <p>j</p> vector of biases that are added to each node output.</paramField>
        <param name="activation">Function applied at the output of each node, except the last.  Usually an &quot;S&quot;-shaped sigmoid or hyperbolic tangent.</param>
        <ret>Returns an array of network outputs.  For a neural network with a single neuron in the last layer (single output), this is an array of length one.</ret>
        <error code="11000">Raises a &quot;no layers&quot; error if the length of model is zero.</error>
        <error code="11001">Raises a &quot;weights, bias, or datum misaligned&quot; error if there is any misalignment between inputs and outputs through the layers of the network.</error>
      </doc>
    </fcn>

    <fcn name="model.svm.score">
      <sig>
        <par name="datum"><array>double</array></par>
        <par name="model"><record label="L"><field name="const">double</field><field name="posClass"><array><record label="M"><field name="supVec"><array>double</array></field><field name="coeff">double</field></record></array></field><field name="negClass"><array><record label="N"><field name="supVec"><array>double</array></field><field name="coeff">double</field></record></array></field></record></par>
        <par name="kernel">
          <function>
            <par><array>double</array></par>
            <par><array>double</array></par>
            <ret>double</ret>
          </function></par>
        <ret>double</ret>
      </sig>
      <doc>
        <desc>Score an input <p>datum</p> with a two-class support vector machine classifier given a <p>model</p> and a kernel function <p>kernel</p>.</desc>
        <param name="datum">Length <p>d</p> vector of independent variables.</param>
        <param name="model">Record containing the support vectors, dual space coefficients and constant needed to score new data.</param>
          <paramField name="const">Constant learned in training.</paramField>
          <paramField name="posClass">Length <p>i</p> array of records containing the support vectors that are in the region for which the svm returns a score greater than one.</paramField>
            <paramField name="supVec">Length <p>d</p> support vector.</paramField>
            <paramField name="coeff">Dual space coefficient associated with the support vector.</paramField>
          <paramField name="negClass">Length <p>i</p> array of records containing the support vectors that are in the region for which the svm returns a score less than one.</paramField>
            <paramField name="supVec">Length <p>d</p> support vector.</paramField>
            <paramField name="coeff">Dual space coefficient associated with the support vector.</paramField>
        <param name="kernel">Kernel function used to map data and support vectors into the dual space.</param>
        <ret>Returns the score.  If positive, datum classified as same group as <p>posClass</p> support vectors.  If negative, datum classified as same group as <p>negClass</p> support vectors.</ret>
        <error code="12000">Raises a &quot;no support vectors&quot; error if the length of <p>negClass</p> and length of <p>posClass</p> is zero.</error>
        <error code="12001">Raises a &quot;support vectors must have same length as datum&quot; error if the length of the support vectors is not the same as the length of <p>datum</p>.</error>
      </doc>
    </fcn>

    </libfcns>
</PFASpecification>
